<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Adventures of JaRomy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #0c0a1f; font-family: 'Press Start 2P', cursive; touch-action: none; }
        canvas { display: block; }
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .custom-scroll::-webkit-scrollbar-thumb { background: #f43f5e; }
        .mute-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            color: white;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 10px;
            border-radius: 4px;
        }
        .mute-button:hover {
            background: rgba(0, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <!-- Audio element for menu music -->
    <audio id="geniusMusic" loop>
        <source src="menu_music.wav" type="audio/wav">
    </audio>
    <audio id="canadaMusic" loop>
        <source src="canada.mp3" type="audio/mpeg">
    </audio>
    <audio id="koreaMusic" loop>
        <source src="korea.mp3" type="audio/mpeg">
    </audio>
    <audio id="level14Music" loop>
        <source src="level14.mp3" type="audio/mpeg">
    </audio>
    <audio id="level19Music" loop>
        <source src="level19.mp3" type="audio/mpeg">
    </audio>
    <audio id="level20Music" loop>
        <source src="level20.mp3" type="audio/mpeg">
    </audio>

    <script type="text/babel">
        const { useEffect, useRef, useCallback, useState } = React;

        /** * GLOBAL CONSTANTS & SHARED RENDERERS 
         */
        const GROUND_HEIGHT_BASE = 120;
        const PLAYER_SIZE_BASE = 80;

        const GameStatus = {
            SPLASH: 'SPLASH', // Opening splash screen
            MENU: 'MENU', SELECT_CHAR: 'SELECT_CHAR', STORY_INTRO: 'STORY_INTRO',
            PLAYING: 'PLAYING', GAMEOVER: 'GAMEOVER', LEVEL_COMPLETE: 'LEVEL_COMPLETE',
            STORY_INTERSTITIAL: 'STORY_INTERSTITIAL', PIZZA_DECISION: 'PIZZA_DECISION',
            MOUNTAIN_INSTRUCTIONS: 'MOUNTAIN_INSTRUCTIONS', POST_MOUNTAIN_STORY: 'POST_MOUNTAIN_STORY',
            LEVEL_3_PRE_SELECT: 'LEVEL_3_PRE_SELECT', LEVEL_3_CHAR_SELECT: 'LEVEL_3_CHAR_SELECT',
            LEVEL_SELECT: 'LEVEL_SELECT', DATING_BEGINS: 'DATING_BEGINS', 
            SAIPAN_PRE_INTRO: 'SAIPAN_PRE_INTRO', SAIPAN_INTRO: 'SAIPAN_INTRO',
            BALI_COMPLETE: 'BALI_COMPLETE', KBBQ_INTRO: 'KBBQ_INTRO'
        };

        const drawPixelRect = (ctx, x, y, w, h, color, shadowColor, outline = true) => {
            if (outline) { ctx.fillStyle = '#000'; ctx.fillRect(x - 2, y - 2, w + 4, h + 4); }
            ctx.fillStyle = color; ctx.fillRect(x, y, w, h);
            if (shadowColor) {
                ctx.fillStyle = shadowColor;
                ctx.fillRect(x + (w * 0.6), y, w * 0.4, h);
                ctx.fillRect(x, y + (h * 0.7), w, h * 0.3);
            }
        };

        const renderCharacterBase = (ctx, char, frame = 0, isFallingAsleep = false, noGlasses = false) => {
            const skin = '#ffd6cc';
            const skinShadow = '#e0b3a8';
            if (char === 'male') {
                drawPixelRect(ctx, 30, 60, 40, 40, '#2563eb', '#1e40af');
                drawPixelRect(ctx, 30, 20, 40, 40, skin, skinShadow);
                if (noGlasses) {
                    ctx.fillStyle = '#000'; 
                    ctx.fillRect(38, 38, 6, 6); 
                    ctx.fillRect(56, 38, 6, 6);
                } else {
                    ctx.fillStyle = '#000'; ctx.fillRect(31, 31, 14, 12); ctx.fillRect(55, 31, 14, 12); ctx.fillRect(45, 34, 10, 3);
                    ctx.fillStyle = skin; ctx.fillRect(34, 34, 8, 6); ctx.fillRect(58, 34, 8, 6);
                }
            } else {
                const hairColor = '#222'; const hairShadow = '#000';
                drawPixelRect(ctx, 24, 16, 52, 6, hairColor, hairShadow);
                drawPixelRect(ctx, 18, 22, 64, 38, hairColor, hairShadow);
                drawPixelRect(ctx, 18, 60, 15, 10, hairColor, hairShadow);
                drawPixelRect(ctx, 67, 60, 15, 10, hairColor, hairShadow);
                const faceX = 30; const faceY = 28; const faceW = 40; const faceH = 38;
                ctx.fillStyle = '#000'; ctx.fillRect(faceX - 2, faceY + 2, faceW + 4, faceH - 4); ctx.fillRect(faceX + 2, faceY - 2, faceW - 4, faceH + 4);
                ctx.fillStyle = skin; ctx.fillRect(faceX, faceY, faceW, faceH);
                ctx.fillStyle = hairColor; ctx.fillRect(faceX, faceY, 4, 4); ctx.fillRect(faceX + faceW - 4, faceY, 4, 4);
                ctx.fillStyle = skinShadow; ctx.fillRect(faceX + faceW - 12, faceY + 20, 12, 18);
                ctx.fillStyle = '#000';
                let eyeHeight = 6;
                if (isFallingAsleep) {
                    const cycle = frame % 120;
                    if (cycle < 60) eyeHeight = Math.max(1, 6 - Math.floor(cycle / 12));
                    else if (cycle < 90) eyeHeight = 1; else eyeHeight = 6;
                }
                const eyeY = 44 + (6 - eyeHeight) / 2;
                ctx.fillRect(38, eyeY, 6, eyeHeight); ctx.fillRect(56, eyeY, 6, eyeHeight); 
                drawPixelRect(ctx, 30, 66, 40, 34, '#334155', '#1e293b');
            }
        };

        const drawAvatar = (ctx, x, y, char, frame, isNPC, scale, isFallingAsleep = false, sizeBase = 80, isCelebrating = false) => {
            ctx.save(); ctx.translate(x, y); const s = (sizeBase / 100) * scale; ctx.scale(s, s); ctx.translate(-50, 0); 
            const bounce = (isNPC || isCelebrating) && !isFallingAsleep ? (Math.floor(frame / 10) % 2) * 12 : 0;
            ctx.translate(0, bounce); renderCharacterBase(ctx, char, frame, isFallingAsleep); ctx.restore();
        };

        /**
         * LEVEL LIBRARY: Modular Level Definitions
         */
        const LevelLibrary = {
            platformer: {
                getGroundY: (worldX, levelNum, height, scaleFactor, groundHeight) => {
                    if (levelNum === 1) {
                        // Level 1 - raise ground higher so thumb doesn't cover action on mobile
                        return height - (groundHeight + 150 * scaleFactor);
                    }
                    if (levelNum === 2) {
                        const startY = height - (350 * scaleFactor);
                        return startY + (worldX * 0.12);
                    }
                    return height - groundHeight;
                },
                update: (context) => {
                    const { player, config, setGameState, isCelebrating, getGroundY, scaleFactor, dimensions, PLAYER_SIZE, playLandSound } = context;
                    if (isCelebrating.current) return;

                    const wasInAir = player.vy > 0; // Track if player was falling
                    player.vy += config.gravity;
                    player.y += player.vy;
                    player.worldX += config.scrollSpeed * scaleFactor;
                    
                    const gY = getGroundY(player.worldX);
                    const playerBottom = player.y + (PLAYER_SIZE * config.charScale);
                    
                    if (playerBottom >= gY) {
                        player.y = gY - (PLAYER_SIZE * config.charScale);
                        if (wasInAir && player.vy > 2 && playLandSound) {
                            playLandSound(); // Play land sound
                        }
                        player.vy = 0;
                    }

                    let accX = 0;
                    const centerX = dimensions.width / 2;
                    config.segments.forEach(seg => {
                        const obsX = accX + seg.length / 2;
                        if (seg.type === 'obstacle') {
                            const screenObsX = obsX - player.worldX + centerX;
                            const obsY = getGroundY(obsX);
                            if (Math.abs(screenObsX - centerX) < 40 * scaleFactor && playerBottom > obsY - (30 * scaleFactor)) {
                                setGameState(prev => ({ ...prev, status: GameStatus.GAMEOVER, deathReason: 'obstacle' }));
                            }
                            if (!player.passedObstacles.has(seg.id) && player.worldX > obsX) {
                                player.passedObstacles.add(seg.id);
                                setGameState(prev => ({ ...prev, score: prev.score + 100 }));
                            }
                        }
                        accX += seg.length;
                    });

                    const totalWidth = config.segments.reduce((a, b) => a + b.length, 0);
                    const stopOffset = (context.gameState.levelNumber === 2 ? 300 : 600) * scaleFactor;
                    if (player.worldX > totalWidth - stopOffset) {
                        isCelebrating.current = true;
                        player.worldX = totalWidth - stopOffset;
                        setTimeout(() => {
                            const level = getLevel(context.gameState.levelNumber);
                            if (level.nextLevelStory) {
                                setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                            } else {
                                setGameState(s => ({ ...s, status: GameStatus.LEVEL_COMPLETE }));
                            }
                        }, 5000);
                    }
                },
                draw: (ctx, context) => {
                    const { dimensions, player, config, getGroundY, scaleFactor, gameState, isCelebrating, PLAYER_SIZE } = context;
                    const { width, height } = dimensions;
                    const centerX = width / 2;
                    const centerY = height / 2;

                    if (gameState.levelNumber === 1) {
                        // Han River Park Scene
                        // Sky - day time blue
                        const skyGrad = ctx.createLinearGradient(0, 0, 0, height * 0.6);
                        skyGrad.addColorStop(0, '#87CEEB'); // Sky blue
                        skyGrad.addColorStop(1, '#B0E0E6'); // Lighter blue at horizon
                        ctx.fillStyle = skyGrad; 
                        ctx.fillRect(0, 0, width, height * 0.6);
                        
                        // Han River water
                        const riverGrad = ctx.createLinearGradient(0, height * 0.55, 0, height * 0.7);
                        riverGrad.addColorStop(0, '#4A90A4'); // River blue
                        riverGrad.addColorStop(1, '#2C5F6F'); // Darker water
                        ctx.fillStyle = riverGrad;
                        ctx.fillRect(0, height * 0.55, width, height * 0.15);
                        
                        // River sparkles/waves
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        for (let i = 0; i < 15; i++) {
                            const sparkleX = (player.worldX * 0.3 + i * 80) % width;
                            const sparkleY = height * 0.58 + Math.sin(player.frame * 0.05 + i) * 10;
                            ctx.fillRect(sparkleX, sparkleY, 3 * scaleFactor, 2 * scaleFactor);
                        }
                        
                        // Distant city skyline (Seoul buildings)
                        ctx.fillStyle = '#4A5568';
                        const buildings = [
                            { x: 0.1, w: 0.08, h: 0.15 },
                            { x: 0.2, w: 0.06, h: 0.12 },
                            { x: 0.28, w: 0.1, h: 0.18 },
                            { x: 0.4, w: 0.07, h: 0.14 },
                            { x: 0.5, w: 0.09, h: 0.16 },
                            { x: 0.61, w: 0.08, h: 0.13 },
                            { x: 0.72, w: 0.1, h: 0.17 },
                            { x: 0.84, w: 0.06, h: 0.11 }
                        ];
                        buildings.forEach(b => {
                            ctx.fillRect(width * b.x, height * (0.55 - b.h), width * b.w, height * b.h);
                            // Windows
                            ctx.fillStyle = '#FDB813';
                            for (let row = 0; row < b.h * 100; row += 15) {
                                for (let col = 5; col < b.w * 100 - 5; col += 12) {
                                    ctx.fillRect(width * b.x + col * scaleFactor, height * (0.55 - b.h) + row * scaleFactor, 4 * scaleFactor, 4 * scaleFactor);
                                }
                            }
                            ctx.fillStyle = '#4A5568';
                        });
                        
                        // Park trees in foreground (parallax)
                        for (let i = 0; i < 8; i++) {
                            const treeX = (width + 100) - ((player.worldX * 0.6 + (i * 250)) % (width + 200));
                            const treeY = height * 0.7;
                            ctx.save();
                            ctx.translate(treeX, treeY);
                            ctx.scale(scaleFactor * 1.2, scaleFactor * 1.2);
                            
                            // Tree trunk
                            ctx.fillStyle = '#78350f';
                            ctx.fillRect(-8, 0, 16, 60);
                            
                            // Green foliage
                            ctx.fillStyle = '#22c55e';
                            ctx.beginPath();
                            ctx.arc(0, -20, 35, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(-20, -10, 25, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(20, -10, 25, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.restore();
                        }
                    } else if (gameState.levelNumber === 2) {
                        // Yongmasan Mountain - Forested descent with abandoned amusement park
                        
                        // Sky gradient - mountain atmosphere
                        const skyGrad = ctx.createLinearGradient(0, 0, 0, height * 0.5);
                        skyGrad.addColorStop(0, '#87CEEB');
                        skyGrad.addColorStop(1, '#E0F2FE');
                        ctx.fillStyle = skyGrad; 
                        ctx.fillRect(0, 0, width, height);
                        
                        // Distant mountain layers (parallax)
                        ctx.fillStyle = 'rgba(100, 116, 139, 0.3)';
                        ctx.beginPath();
                        ctx.moveTo(0, height * 0.4);
                        for (let x = 0; x < width; x += 50) {
                            const y = height * 0.4 + Math.sin(x * 0.01 + player.worldX * 0.001) * 30;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(width, height);
                        ctx.lineTo(0, height);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(71, 85, 105, 0.4)';
                        ctx.beginPath();
                        ctx.moveTo(0, height * 0.5);
                        for (let x = 0; x < width; x += 40) {
                            const y = height * 0.5 + Math.sin(x * 0.015 + player.worldX * 0.002) * 40;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(width, height);
                        ctx.lineTo(0, height);
                        ctx.fill();
                        
                        // Dense forest trees (background layer)
                        for (let i = 0; i < 20; i++) {
                            const treeX = (width + 100) - ((player.worldX * 0.4 + (i * 150)) % (width + 300));
                            const treeY = height * 0.55 + (i % 3) * 30;
                            ctx.save();
                            ctx.translate(treeX, treeY);
                            ctx.scale(scaleFactor * 0.8, scaleFactor * 0.8);
                            
                            // Pine tree shape
                            ctx.fillStyle = '#1e4620';
                            ctx.beginPath();
                            ctx.moveTo(0, -60);
                            ctx.lineTo(-20, -20);
                            ctx.lineTo(-15, -20);
                            ctx.lineTo(-25, 0);
                            ctx.lineTo(-18, 0);
                            ctx.lineTo(-28, 20);
                            ctx.lineTo(28, 20);
                            ctx.lineTo(18, 0);
                            ctx.lineTo(25, 0);
                            ctx.lineTo(15, -20);
                            ctx.lineTo(20, -20);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Trunk
                            ctx.fillStyle = '#78350f';
                            ctx.fillRect(-4, 20, 8, 20);
                            
                            ctx.restore();
                        }
                        
                        // ABANDONED AMUSEMENT PARK (halfway through level - around worldX 2000-3000)
                        const parkStart = 2000;
                        const parkEnd = 3500;
                        const parkScreenX = parkStart - player.worldX + centerX;
                        
                        if (player.worldX > parkStart - width && player.worldX < parkEnd + width) {
                            // Rusted Ferris wheel
                            const ferrisX = parkScreenX + 300 * scaleFactor;
                            const ferrisY = height * 0.5;
                            
                            ctx.save();
                            ctx.translate(ferrisX, ferrisY);
                            ctx.scale(scaleFactor, scaleFactor);
                            
                            // Ferris wheel structure - rusted brown
                            ctx.strokeStyle = '#8b4513';
                            ctx.lineWidth = 6;
                            ctx.beginPath();
                            ctx.arc(0, 0, 80, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Spokes
                            for (let i = 0; i < 8; i++) {
                                const angle = (i * Math.PI / 4) + (player.frame * 0.002); // Slow creaky rotation
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(Math.cos(angle) * 80, Math.sin(angle) * 80);
                                ctx.stroke();
                            }
                            
                            // Center hub
                            ctx.fillStyle = '#654321';
                            ctx.beginPath();
                            ctx.arc(0, 0, 12, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.restore();
                            
                            // Old carousel roof
                            const carouselX = parkScreenX + 600 * scaleFactor;
                            const carouselY = height * 0.6;
                            
                            ctx.fillStyle = '#dc2626'; // Faded red
                            ctx.beginPath();
                            ctx.moveTo(carouselX, carouselY - 40 * scaleFactor);
                            ctx.lineTo(carouselX - 60 * scaleFactor, carouselY);
                            ctx.lineTo(carouselX + 60 * scaleFactor, carouselY);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Carousel base
                            ctx.fillStyle = '#92400e';
                            ctx.fillRect(carouselX - 50 * scaleFactor, carouselY, 100 * scaleFactor, 30 * scaleFactor);
                            
                            // Broken sign
                            const signX = parkScreenX + 900 * scaleFactor;
                            const signY = height * 0.55;
                            
                            ctx.fillStyle = '#1e293b';
                            ctx.fillRect(signX - 40 * scaleFactor, signY, 80 * scaleFactor, 50 * scaleFactor);
                            ctx.fillStyle = '#475569';
                            ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                            ctx.textAlign = 'center';
                            ctx.fillText('CLOSED', signX, signY + 25 * scaleFactor);
                        }
                        
                        // Foreground trees (darker, closer)
                        for (let i = 0; i < 12; i++) {
                            const treeX = (width + 100) - ((player.worldX * 0.7 + (i * 200)) % (width + 300));
                            const treeY = height * 0.65;
                            ctx.save();
                            ctx.translate(treeX, treeY);
                            ctx.scale(scaleFactor * 1.3, scaleFactor * 1.3);
                            
                            // Trunk
                            ctx.fillStyle = '#58270f';
                            ctx.fillRect(-6, 0, 12, 50);
                            
                            // Dark green foliage
                            ctx.fillStyle = '#166534';
                            ctx.beginPath();
                            ctx.moveTo(0, -70);
                            ctx.lineTo(-30, -30);
                            ctx.lineTo(-20, -30);
                            ctx.lineTo(-35, 0);
                            ctx.lineTo(35, 0);
                            ctx.lineTo(20, -30);
                            ctx.lineTo(30, -30);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.restore();
                        }
                    } else {
                        const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                        skyGrad.addColorStop(0, '#bae6fd'); skyGrad.addColorStop(1, '#fef9c3');
                        ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, width, height);
                    }

                    const cameraOffset = gameState.levelNumber === 1 ? 0 : centerY - (player.y + (PLAYER_SIZE * config.charScale) / 2);
                    let accX = 0;
                    config.segments.forEach(seg => {
                        const xStart = accX - player.worldX + centerX;
                        const yStart = getGroundY(accX);
                        const xEnd = xStart + seg.length;
                        const yEnd = getGroundY(accX + seg.length);

                        ctx.fillStyle = config.primaryColor;
                        ctx.beginPath();
                        ctx.moveTo(xStart, yStart + cameraOffset);
                        ctx.lineTo(xEnd, yEnd + cameraOffset);
                        ctx.lineTo(xEnd, yEnd + cameraOffset + 1000);
                        ctx.lineTo(xStart, yStart + cameraOffset + 1000);
                        ctx.fill();

                        ctx.fillStyle = config.shadowColor;
                        for (let i = 0; i < seg.length; i += 60 * scaleFactor) {
                            const ty = getGroundY(accX + i);
                            ctx.fillRect(xStart + i, ty + cameraOffset - 4, 8 * scaleFactor, 4);
                        }

                        if (seg.type === 'obstacle') {
                            const midX = accX + seg.length / 2;
                            const drawX = xStart + seg.length / 2;
                            const drawY = getGroundY(midX) + cameraOffset;
                            if (seg.obstacleType === 'tree') {
                                ctx.save(); ctx.translate(drawX, drawY); ctx.scale(scaleFactor, scaleFactor);
                                drawPixelRect(ctx, -10, -30, 20, 30, '#78350f', '#451a03');
                                ctx.fillStyle = '#065f46'; ctx.beginPath(); ctx.moveTo(0, -90); ctx.lineTo(-40, -30); ctx.lineTo(40, -30); ctx.fill(); ctx.restore();
                            } else {
                                // Cute pillow monster with face and shaking animation
                                ctx.save();
                                ctx.translate(drawX, drawY);
                                ctx.scale(scaleFactor, scaleFactor);
                                
                                // Cute shaking animation
                                const shake = Math.sin(player.frame * 0.3) * 3;
                                const bounce = Math.abs(Math.sin(player.frame * 0.15)) * 5;
                                ctx.translate(shake, -bounce - 50);
                                
                                // Pillow body - rounded white pillow
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(-35, 0, 70, 55);
                                
                                // Grey border for depth
                                ctx.fillStyle = '#cbd5e1';
                                ctx.fillRect(-35, 0, 70, 5); // Top
                                ctx.fillRect(-35, 50, 70, 5); // Bottom
                                ctx.fillRect(-35, 0, 5, 55); // Left
                                ctx.fillRect(30, 0, 5, 55); // Right
                                
                                // Cute face
                                // Big round eyes
                                ctx.fillStyle = '#000000';
                                ctx.beginPath();
                                ctx.arc(-15, 20, 8, 0, Math.PI * 2);
                                ctx.arc(15, 20, 8, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Eye highlights (sparkle)
                                ctx.fillStyle = '#ffffff';
                                ctx.beginPath();
                                ctx.arc(-12, 18, 3, 0, Math.PI * 2);
                                ctx.arc(18, 18, 3, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Cute smile
                                ctx.strokeStyle = '#000000';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.arc(0, 28, 12, 0.2, Math.PI - 0.2);
                                ctx.stroke();
                                
                                // Rosy cheeks
                                ctx.fillStyle = 'rgba(255, 182, 193, 0.5)';
                                ctx.beginPath();
                                ctx.arc(-22, 28, 6, 0, Math.PI * 2);
                                ctx.arc(22, 28, 6, 0, Math.PI * 2);
                                ctx.fill();
                                
                                ctx.restore();
                            }
                        }
                        if (seg.hasPartner) {
                            const pRelX = seg.length - (450 * scaleFactor);
                            const pX = xStart + pRelX; const pY = getGroundY(accX + pRelX) - (PLAYER_SIZE * config.charScale) + cameraOffset;
                            drawAvatar(ctx, pX, pY, gameState.character === 'male' ? 'female' : 'male', player.frame, true, config.charScale, false, PLAYER_SIZE, isCelebrating.current);
                            if (isCelebrating.current) {
                                const pulse = Math.sin(player.frame * 0.1) * 0.4;
                                ctx.save(); ctx.translate((centerX + pX) / 2, pY - (120 * scaleFactor));
                                ctx.scale(3.0 * scaleFactor + pulse, 3.0 * scaleFactor + pulse);
                                ctx.fillStyle = '#ef4444'; ctx.fillRect(-10, -5, 8, 5); ctx.fillRect(2, -5, 8, 5); ctx.fillRect(-12, 0, 24, 8);
                                ctx.fillRect(-10, 8, 20, 6); ctx.fillRect(-6, 14, 12, 6); ctx.fillRect(-2, 20, 4, 4); ctx.restore();
                            }
                        }
                        if (seg.hasFebreze) {
                            ctx.save(); ctx.translate(xStart + seg.length - (200 * scaleFactor), getGroundY(accX + seg.length - (200 * scaleFactor)) + cameraOffset - (90 * scaleFactor));
                            ctx.scale(scaleFactor, scaleFactor);
                            drawPixelRect(ctx, -20, 30, 40, 60, '#94a3b8', '#475569');
                            drawPixelRect(ctx, -20, 10, 40, 20, '#2563eb', '#1e3a8a'); ctx.restore();
                        }
                        accX += seg.length;
                    });
                    drawAvatar(ctx, centerX, player.y + cameraOffset, gameState.character, player.frame, false, config.charScale, false, PLAYER_SIZE, isCelebrating.current);
                }
            },
            catching: {
                update: (context) => {
                    const { player, targetX, entities, dimensions, scaleFactor, setGameState, isCelebrating } = context;
                    if (isCelebrating.current) return;
                    
                    // Ensure targetX is valid and within bounds
                    const safeTargetX = Math.max(50 * scaleFactor, Math.min(dimensions.width - 50 * scaleFactor, targetX.current));
                    
                    player.x += (safeTargetX - player.x) * 0.15;
                    player.x = Math.max(50 * scaleFactor, Math.min(dimensions.width - 50 * scaleFactor, player.x));
                    
                    if (player.frame % 35 === 0) {
                        entities.current.push({ id: Date.now(), x: Math.random() * (dimensions.width - 100) + 50, y: -80, speed: (4 + Math.random() * 4) * (scaleFactor * 1.5) });
                    }
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player, entities, gameState, setGameState, isCelebrating, PLAYER_SIZE } = context;
                    const { width, height } = dimensions;
                    ctx.fillStyle = '#1e1b4b'; ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#0f172a'; ctx.beginPath(); ctx.moveTo(0, height * 0.55); ctx.lineTo(width, height * 0.7); ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.fill();
                    ctx.fillStyle = '#271104'; ctx.fillRect(0, height - (100 * scaleFactor), width, 100 * scaleFactor);

                    // Neon CHEESEWICK sign in background
                    ctx.save();
                    ctx.translate(width * 0.5, height * 0.25);
                    
                    // Neon glow effect
                    const glowIntensity = Math.sin(player.frame * 0.1) * 0.3 + 0.7; // Flickering effect
                    
                    // Outer glow
                    ctx.shadowBlur = 30 * scaleFactor;
                    ctx.shadowColor = `rgba(255, 20, 147, ${glowIntensity})`;
                    
                    // Pink neon text
                    ctx.fillStyle = `rgba(255, 105, 180, ${glowIntensity})`;
                    ctx.strokeStyle = `rgba(255, 20, 147, ${glowIntensity})`;
                    ctx.lineWidth = 3 * scaleFactor;
                    ctx.font = `bold ${40 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Draw text with glow
                    ctx.strokeText('CHEESEWICK', 0, 0);
                    ctx.fillText('CHEESEWICK', 0, 0);
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    
                    ctx.restore();

                    entities.current = entities.current.filter(p => {
                        if (!isCelebrating.current) p.y += p.speed;
                        ctx.save(); ctx.translate(p.x, p.y); ctx.scale(scaleFactor * 2, scaleFactor * 2);
                        ctx.fillStyle = '#92400e'; ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(-24, -45); ctx.lineTo(24, -45); ctx.closePath(); ctx.fill();
                        ctx.fillStyle = '#fde047'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-18, -40); ctx.lineTo(18, -40); ctx.closePath(); ctx.fill();
                        ctx.fillStyle = '#ef4444'; ctx.fillRect(-6, -32, 6, 6); ctx.fillRect(4, -22, 6, 6); ctx.fillRect(-2, -15, 6, 6);
                        ctx.restore();

                        const charY = height - (150 * scaleFactor);
                        if (Math.abs(p.x - player.x) < 80 * scaleFactor && Math.abs(p.y - charY) < 60 * scaleFactor && !isCelebrating.current) {
                            // Play collect sound when catching pizza
                            if (context.playCollectSound) context.playCollectSound();
                            
                            setGameState(prev => {
                                const newVal = prev.pizzasCaught + 1;
                                const goal = prev.character === 'male' ? 20 : 4;
                                if (newVal >= goal) {
                                    isCelebrating.current = true;
                                    const level = getLevel(gameState.levelNumber);
                                    setTimeout(() => {
                                        if (level.nextLevelStory) {
                                            setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                                        } else {
                                            setGameState(s => ({ ...s, status: GameStatus.LEVEL_COMPLETE }));
                                        }
                                    }, 2500);
                                }
                                return { ...prev, pizzasCaught: newVal, score: prev.score + 10 };
                            });
                            return false;
                        }
                        // Check if pizza went off screen (missed)
                        const missed = p.y >= height + 100;
                        if (missed && context.playMissSound) {
                            context.playMissSound();
                        }
                        return !missed;
                    });
                    const charY = height - (100 * scaleFactor) - (PLAYER_SIZE * context.config.charScale);
                    if (!context.skipCharacter) {
                        drawAvatar(ctx, player.x, charY, gameState.character, player.frame, false, context.config.charScale, false, PLAYER_SIZE, isCelebrating.current);
                    }
                }
            },
            wakeup: {
                update: (context) => {
                    const { player, entities, dimensions } = context;
                    if (player.frame % 30 === 0) {
                        entities.current.push({ id: Math.random(), x: dimensions.width/2 + (Math.random()*40-20), y: dimensions.height/2 - 50, vx: (Math.random()-0.5)*2, vy: -1.5 - Math.random()*2, opacity: 1 });
                    }
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, entities, player } = context;
                    const { width, height } = dimensions;
                    
                    // Airport interior - tropical vibes
                    // Ceiling/upper walls - warm tropical orange
                    const ceilingGrad = ctx.createLinearGradient(0, 0, 0, height * 0.3);
                    ceilingGrad.addColorStop(0, '#fb923c'); // Warm orange
                    ceilingGrad.addColorStop(1, '#fdba74'); // Lighter orange
                    ctx.fillStyle = ceilingGrad;
                    ctx.fillRect(0, 0, width, height * 0.3);
                    
                    // Main wall - cream/beige
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(0, height * 0.3, width, height * 0.4);
                    
                    // Windows (large airport windows with tropical sky view)
                    for (let i = 0; i < 5; i++) {
                        const windowX = (i * width / 5) + width * 0.1;
                        const windowY = height * 0.35;
                        const windowW = width * 0.15;
                        const windowH = height * 0.25;
                        
                        // Sky through window - tropical blue
                        const skyGrad = ctx.createLinearGradient(windowX, windowY, windowX, windowY + windowH);
                        skyGrad.addColorStop(0, '#38bdf8');
                        skyGrad.addColorStop(1, '#7dd3fc');
                        ctx.fillStyle = skyGrad;
                        ctx.fillRect(windowX, windowY, windowW, windowH);
                        
                        // Window frame
                        ctx.strokeStyle = '#78716c';
                        ctx.lineWidth = 4 * scaleFactor;
                        ctx.strokeRect(windowX, windowY, windowW, windowH);
                        
                        // Window cross bars
                        ctx.beginPath();
                        ctx.moveTo(windowX, windowY + windowH / 2);
                        ctx.lineTo(windowX + windowW, windowY + windowH / 2);
                        ctx.stroke();
                    }
                    
                    // Airport signs/displays
                    // Departure board
                    ctx.fillStyle = '#1e293b';
                    ctx.fillRect(width * 0.15, height * 0.15, width * 0.3, height * 0.1);
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = `${8 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.fillText('DEPARTURES', width * 0.3, height * 0.19);
                    
                    // Gate sign
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(width * 0.6, height * 0.15, width * 0.25, height * 0.08);
                    ctx.fillStyle = '#fff';
                    ctx.fillText('GATE 7', width * 0.725, height * 0.185);
                    
                    // Airport chairs/seating area
                    for (let i = 0; i < 3; i++) {
                        const chairX = width * 0.15 + (i * width * 0.25);
                        const chairY = height * 0.65;
                        
                        // Chair backs
                        ctx.fillStyle = '#60a5fa';
                        ctx.fillRect(chairX, chairY - 20 * scaleFactor, 60 * scaleFactor, 50 * scaleFactor);
                        
                        // Chair seats
                        ctx.fillStyle = '#3b82f6';
                        ctx.fillRect(chairX, chairY + 20 * scaleFactor, 60 * scaleFactor, 15 * scaleFactor);
                        
                        // Metal legs
                        ctx.fillStyle = '#94a3b8';
                        ctx.fillRect(chairX + 5 * scaleFactor, chairY + 35 * scaleFactor, 5 * scaleFactor, 20 * scaleFactor);
                        ctx.fillRect(chairX + 50 * scaleFactor, chairY + 35 * scaleFactor, 5 * scaleFactor, 20 * scaleFactor);
                    }
                    
                    // Polished floor - shiny airport tile
                    const floorGrad = ctx.createLinearGradient(0, height * 0.7, 0, height);
                    floorGrad.addColorStop(0, '#cbd5e1');
                    floorGrad.addColorStop(1, '#94a3b8');
                    ctx.fillStyle = floorGrad;
                    ctx.fillRect(0, height * 0.7, width, height * 0.3);
                    
                    // Floor tiles pattern
                    ctx.strokeStyle = 'rgba(100, 116, 139, 0.3)';
                    ctx.lineWidth = 2;
                    for (let x = 0; x < width; x += 60 * scaleFactor) {
                        ctx.beginPath();
                        ctx.moveTo(x, height * 0.7);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }

                    entities.current = entities.current.filter(z => {
                        z.x += z.vx; z.y += z.vy; z.opacity -= 0.005;
                        ctx.save(); ctx.globalAlpha = z.opacity; ctx.fillStyle = '#fff';
                        ctx.font = `${24 * scaleFactor}px "Press Start 2P"`; ctx.fillText('Z', z.x, z.y); ctx.restore();
                        return z.opacity > 0;
                    });
                    drawAvatar(ctx, width/2, height/2, 'female', player.frame, true, context.config.charScale, true, context.PLAYER_SIZE);
                }
            },
            bike_chase: {
                update: (context) => {
                    const { player, scaleFactor, baliHat, setGameState, config, dimensions } = context;
                    const hat = baliHat.current;
                    const seconds = player.frame / 60;
                    
                    // For car level, always scroll. For Bali level, stop when hat is saved
                    if (config.isCarLevel || (hat && hat.state !== 'saved')) {
                        player.worldX += 6 * scaleFactor;
                    }
                    
                    // For car level (Level 14), spawn obstacles and check collisions
                    if (config.isCarLevel) {
                        // Start Level 14 music once
                        if (!player.level14MusicStarted && context.level14MusicRef?.current && !context.isMuted) {
                            context.level14MusicRef.current.play().catch(err => console.log('Audio play prevented:', err));
                            player.level14MusicStarted = true;
                        }
                        
                        // Play engine sound every 18 frames (continuous rumble)
                        if (player.frame % 18 === 0 && context.playCarEngineSound) {
                            context.playCarEngineSound();
                        }
                        
                        // Initialize car obstacles
                        if (!player.carObstacles) {
                            player.carObstacles = [];
                            player.nextObstacleSpawn = 120; // frames until next obstacle
                            player.isJumping = false;
                            player.jumpVelocity = 0;
                            player.carY = 0; // vertical offset from ground
                        }
                        
                        // Jumping physics
                        if (player.isJumping) {
                            player.jumpVelocity += 0.8 * scaleFactor; // gravity
                            player.carY += player.jumpVelocity;
                            
                            // Land back on ground
                            if (player.carY >= 0) {
                                player.carY = 0;
                                player.isJumping = false;
                                player.jumpVelocity = 0;
                            }
                        }
                        
                        // Spawn obstacles
                        player.nextObstacleSpawn--;
                        if (player.nextObstacleSpawn <= 0) {
                            const obstacleTypes = ['moose', 'camper', 'fire'];
                            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                            
                            player.carObstacles.push({
                                type,
                                x: dimensions.width + 100 * scaleFactor,
                                passed: false
                            });
                            
                            // Next obstacle in 2-4 seconds
                            player.nextObstacleSpawn = 120 + Math.random() * 120;
                        }
                        
                        // Update obstacles
                        for (let i = player.carObstacles.length - 1; i >= 0; i--) {
                            const obs = player.carObstacles[i];
                            obs.x -= 8 * scaleFactor; // Move left
                            
                            // Check collision
                            const carX = dimensions.width / 2;
                            const carWidth = 120 * scaleFactor * 1.8;
                            const obsWidth = 60 * scaleFactor * 1.5; // Adjusted for new scale
                            
                            // Collision if car is on ground (or not high enough) and obstacle overlaps car
                            if (!obs.passed && 
                                obs.x < carX + carWidth / 2 && 
                                obs.x + obsWidth > carX - carWidth / 2) {
                                
                                // Need to jump at least 80 units to clear obstacles (adjusted for shorter obstacles)
                                if (!player.isJumping || player.carY > -80 * scaleFactor) {
                                    // Hit obstacle!
                                    if (context.playCarCrashSound) context.playCarCrashSound();
                                    
                                    const deathMessages = {
                                        moose: 'HIT A MOOSE!',
                                        camper: 'CRASHED INTO A CAMPER!',
                                        fire: 'DROVE THROUGH THE FIRE!'
                                    };
                                    setGameState(prev => ({ 
                                        ...prev, 
                                        status: GameStatus.GAMEOVER, 
                                        deathReason: deathMessages[obs.type] 
                                    }));
                                }
                                obs.passed = true;
                            }
                            
                            // Remove if off screen
                            if (obs.x < -100 * scaleFactor) {
                                player.carObstacles.splice(i, 1);
                            }
                        }
                        
                        const surviveTime = config.surviveTime || 45;
                        if (seconds >= surviveTime) {
                            setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                        }
                        return;
                    }
                    
                    // Original hat mechanic for Bali level
                    // Play motorcycle engine sound continuously (every 60 frames) - but stop when hat saved
                    if (hat.state !== 'saved' && player.frame % 60 === 0 && context.playMotorcycleSound) {
                        context.playMotorcycleSound();
                    }
                    
                    // Initialize baby turtles when hat is saved
                    if (hat.state === 'saved' && !player.turtles) {
                        player.turtles = [];
                        // Spawn 8 baby turtles
                        for (let i = 0; i < 8; i++) {
                            player.turtles.push({
                                x: -50 - (i * 30), // Start off screen left
                                y: dimensions.height - 100 * scaleFactor,
                                speed: 2 + Math.random() * 1.5,
                                legPhase: Math.random() * Math.PI * 2,
                                size: 0.8 + Math.random() * 0.4
                            });
                        }
                    }
                    
                    // Update turtles
                    if (player.turtles) {
                        player.turtles.forEach(turtle => {
                            turtle.x += turtle.speed * scaleFactor;
                            turtle.legPhase += 0.2;
                        });
                    }
                    
                    if (hat.state === 'attached' && seconds >= 15) {
                        hat.state = 'flying';
                        hat.flyTimer = player.frame;
                        if (context.playHatFlySound) context.playHatFlySound(); // Play whoosh sound
                    }
                    if (hat.state === 'flying') {
                        const elapsed = player.frame - hat.flyTimer;
                        const elapsedSec = elapsed / 60;
                        if (elapsedSec >= 5) {
                            hat.velocityX -= 0.5 * scaleFactor;
                            hat.floatX += hat.velocityX;
                            if (hat.screenX < -100) setGameState(prev => ({ ...prev, status: GameStatus.GAMEOVER, deathReason: 'hat_lost' }));
                        }
                    }
                    if (hat.state === 'saved' && (player.frame - hat.saveTimer) > 300) {
                        setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                    }
                },
                draw: (ctx, context) => {
                    const { dimensions, player, scaleFactor, baliHat, config } = context;
                    const { width, height } = dimensions;
                    const hat = baliHat.current;
                    
                    // Check if this is the car level (Level 13)
                    if (config.isCarLevel) {
                        // Smoky fire background
                        const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                        skyGrad.addColorStop(0, '#78350f');
                        skyGrad.addColorStop(0.5, '#ea580c');
                        skyGrad.addColorStop(1, '#f97316');
                        ctx.fillStyle = skyGrad;
                        ctx.fillRect(0, 0, width, height);
                        
                        // Animated smoke particles (dense orange-grey)
                        for (let i = 0; i < 30; i++) {
                            const smokeX = ((player.worldX * 0.3 + i * 100) % (width + 200)) - 100;
                            const smokeY = (Math.sin(player.frame * 0.02 + i) * 50) + (i % 3) * (height / 3);
                            const smokeSize = 80 + (i % 3) * 40;
                            const smokeAlpha = 0.15 + (Math.sin(player.frame * 0.01 + i) * 0.1);
                            
                            const grad = ctx.createRadialGradient(smokeX, smokeY, 0, smokeX, smokeY, smokeSize * scaleFactor);
                            grad.addColorStop(0, `rgba(200, 100, 50, ${smokeAlpha})`);
                            grad.addColorStop(0.5, `rgba(150, 80, 40, ${smokeAlpha * 0.5})`);
                            grad.addColorStop(1, 'rgba(100, 50, 30, 0)');
                            
                            ctx.fillStyle = grad;
                            ctx.fillRect(smokeX - smokeSize * scaleFactor, smokeY - smokeSize * scaleFactor, 
                                       smokeSize * 2 * scaleFactor, smokeSize * 2 * scaleFactor);
                        }
                        
                        // Burning trees in background
                        for (let i = 0; i < 5; i++) {
                            const treeX = (width + 100) - ((player.worldX * 0.4 + (i * 400)) % (width + 200));
                            const treeY = height * (0.3 + (i % 2) * 0.1);
                            ctx.save();
                            ctx.translate(treeX, treeY);
                            ctx.scale(scaleFactor * 0.7, scaleFactor * 0.7);
                            
                            // Tree trunk
                            ctx.fillStyle = '#1a1a1a';
                            ctx.fillRect(-10, 0, 20, 80);
                            
                            // Flames
                            const flameFrame = Math.floor(player.frame / 5) % 3;
                            ctx.fillStyle = flameFrame === 0 ? '#ff4500' : (flameFrame === 1 ? '#ff6347' : '#ff8c00');
                            ctx.fillRect(-20, -40, 40, 40);
                            ctx.fillRect(-15, -60, 30, 20);
                            ctx.fillRect(-10, -75, 20, 15);
                            
                            ctx.restore();
                        }
                        
                        // Dark grey road
                        ctx.fillStyle = '#3f3f46';
                        ctx.fillRect(0, height * 0.7, width, height * 0.3);
                        
                        // Road lines
                        ctx.fillStyle = '#fbbf24';
                        const roadOff = (player.worldX * 8) % 200;
                        for (let x = -200; x < width + 200; x += 100) {
                            ctx.fillRect(x - roadOff, height * 0.75, 50, 6);
                        }
                        
                        // Grey car with James and Romy
                        const carX = width / 2;
                        const carY = height * 0.65 + (player.carY || 0); // Raised from 0.78 to 0.65 for mobile
                        const bounce = Math.sin(player.frame * 0.25) * 4;
                        const carScale = scaleFactor * 1.8;
                        
                        ctx.save();
                        ctx.translate(carX, carY + bounce);
                        ctx.scale(carScale, carScale);
                        
                        // Car body - darker grey
                        ctx.fillStyle = '#6b7280';
                        ctx.fillRect(-60, -20, 120, 40);
                        
                        // Car top/cabin
                        ctx.fillStyle = '#4b5563';
                        ctx.fillRect(-40, -45, 80, 25);
                        
                        // Windows (lighter blue/transparent)
                        ctx.fillStyle = '#bfdbfe';
                        ctx.fillRect(-35, -42, 30, 20); // Left window
                        ctx.fillRect(5, -42, 30, 20);   // Right window
                        
                        // Draw faces IN the windows - BIGGER and CENTERED - MOVED UP AND BACK
                        // Romy (driver side - left window)
                        ctx.save();
                        ctx.translate(-47, -48); // Moved back 15 more (was -32, now -47)
                        ctx.scale(0.5, 0.5); // Twice as big (was 0.25, now 0.5)
                        
                        // Romy's hair
                        ctx.fillStyle = '#222';
                        ctx.fillRect(24, 16, 52, 6);
                        ctx.fillRect(18, 22, 64, 38);
                        
                        // Romy's face
                        const skin = '#ffd6cc';
                        ctx.fillStyle = skin;
                        ctx.fillRect(30, 28, 40, 38);
                        
                        // Eyes
                        ctx.fillStyle = '#000';
                        ctx.fillRect(38, 44, 6, 6);
                        ctx.fillRect(56, 44, 6, 6);
                        
                        ctx.restore();
                        
                        // James (passenger side - right window)
                        ctx.save();
                        ctx.translate(-7, -48); // Moved back 15 more (was 8, now -7)
                        ctx.scale(0.5, 0.5); // Twice as big (was 0.25, now 0.5)
                        
                        // James's face
                        ctx.fillStyle = skin;
                        ctx.fillRect(30, 20, 40, 40);
                        
                        // Glasses
                        ctx.fillStyle = '#000';
                        ctx.fillRect(31, 31, 14, 12);
                        ctx.fillRect(55, 31, 14, 12);
                        ctx.fillRect(45, 34, 10, 3);
                        ctx.fillStyle = skin;
                        ctx.fillRect(34, 34, 8, 6);
                        ctx.fillRect(58, 34, 8, 6);
                        
                        ctx.restore();
                        
                        // Wheels
                        ctx.fillStyle = '#1f2937';
                        ctx.beginPath();
                        ctx.arc(-40, 20, 14, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(40, 20, 14, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Wheel rims
                        ctx.fillStyle = '#6b7280';
                        ctx.beginPath();
                        ctx.arc(-40, 20, 7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(40, 20, 7, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Headlights
                        ctx.fillStyle = '#fef08a';
                        ctx.fillRect(58, -8, 4, 6);
                        ctx.fillRect(58, 2, 4, 6);
                        
                        ctx.restore();
                        
                        // Draw obstacles - SHORTER
                        if (player.carObstacles) {
                            player.carObstacles.forEach(obs => {
                                ctx.save();
                                ctx.translate(obs.x, height * 0.65); // Raised from 0.78 to 0.65 to match car
                                ctx.scale(scaleFactor * 1.5, scaleFactor * 1.5); // Smaller (was 2, now 1.5)
                                
                                if (obs.type === 'moose') {
                                    // More realistic moose design
                                    ctx.fillStyle = '#5d4037'; // Brown body
                                    
                                    // Body (rounder)
                                    ctx.fillRect(-18, -35, 36, 35);
                                    
                                    // Chest (lighter brown)
                                    ctx.fillStyle = '#6d4c41';
                                    ctx.fillRect(-12, -30, 24, 25);
                                    
                                    // Head/neck
                                    ctx.fillStyle = '#5d4037';
                                    ctx.fillRect(-12, -50, 18, 20); // Neck
                                    ctx.fillRect(-15, -60, 24, 15); // Head
                                    
                                    // Snout
                                    ctx.fillStyle = '#4e342e';
                                    ctx.fillRect(-8, -55, 12, 8);
                                    
                                    // Antlers (more detailed)
                                    ctx.fillStyle = '#d7ccc8';
                                    // Left antler
                                    ctx.fillRect(-18, -70, 4, 15);
                                    ctx.fillRect(-22, -68, 6, 4);
                                    ctx.fillRect(-20, -62, 6, 4);
                                    // Right antler
                                    ctx.fillRect(14, -70, 4, 15);
                                    ctx.fillRect(16, -68, 6, 4);
                                    ctx.fillRect(14, -62, 6, 4);
                                    
                                    // Legs
                                    ctx.fillStyle = '#4e342e';
                                    ctx.fillRect(-15, 0, 6, 18);
                                    ctx.fillRect(-5, 0, 6, 18);
                                    ctx.fillRect(3, 0, 6, 18);
                                    ctx.fillRect(13, 0, 6, 18);
                                    
                                    // Hooves
                                    ctx.fillStyle = '#3e2723';
                                    ctx.fillRect(-15, 15, 6, 3);
                                    ctx.fillRect(-5, 15, 6, 3);
                                    ctx.fillRect(3, 15, 6, 3);
                                    ctx.fillRect(13, 15, 6, 3);
                                    
                                    // Eye
                                    ctx.fillStyle = '#000';
                                    ctx.fillRect(2, -56, 3, 3);
                                    
                                } else if (obs.type === 'camper') {
                                    // Crashed camper - SHORTER
                                    ctx.fillStyle = '#e5e7eb';
                                    ctx.fillRect(-25, -25, 50, 35); // Body (shorter)
                                    
                                    // Windows
                                    ctx.fillStyle = '#3b82f6';
                                    ctx.fillRect(-20, -20, 15, 10);
                                    ctx.fillRect(5, -20, 15, 10);
                                    
                                    // Wheels
                                    ctx.fillStyle = '#1f2937';
                                    ctx.fillRect(-20, 10, 10, 6);
                                    ctx.fillRect(10, 10, 10, 6);
                                    
                                    // Damage smoke
                                    ctx.fillStyle = '#52525b';
                                    ctx.fillRect(15, -30, 8, 8);
                                    ctx.fillRect(20, -35, 6, 6);
                                } else if (obs.type === 'fire') {
                                    // Fire on road - SHORTER
                                    const flameFrame = Math.floor(player.frame / 5) % 3;
                                    ctx.fillStyle = flameFrame === 0 ? '#ff4500' : (flameFrame === 1 ? '#ff6347' : '#ff8c00');
                                    
                                    // Flames (shorter)
                                    ctx.fillRect(-20, -45, 40, 40);
                                    ctx.fillRect(-15, -55, 30, 10);
                                    ctx.fillRect(-10, -60, 20, 5);
                                    
                                    // Base
                                    ctx.fillStyle = '#8b0000';
                                    ctx.fillRect(-25, -5, 50, 10);
                                }
                                
                                ctx.restore();
                            });
                        }
                        
                        return; // Exit early for car level
                    }
                    
                    // Original Bali bike level rendering below
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                    skyGrad.addColorStop(0, '#064e3b'); skyGrad.addColorStop(1, '#065f46'); 
                    ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, width, height);

                    for (let i = 0; i < 3; i++) {
                        const layerColor = i === 0 ? '#022c22' : (i === 1 ? '#064e3b' : '#065f46');
                        const speed = (i + 1) * 1.5;
                        const offset = (player.worldX * speed * 0.1) % width;
                        ctx.fillStyle = layerColor; ctx.beginPath(); ctx.moveTo(-offset, height);
                        for(let x = 0; x <= width * 2; x += 100 * scaleFactor) {
                            ctx.lineTo(x - offset, height - (250 + i * 80 + Math.sin(x/100 + player.frame/100) * 20));
                            ctx.lineTo(x + 50 * scaleFactor - offset, height - (350 + i * 80));
                        }
                        ctx.lineTo(width * 2, height); ctx.fill();
                    }

                    [0.2, 0.8, 0.5].forEach((mX, idx) => {
                        const x = (width + 100) - ((player.worldX * 0.5 + (idx * 500)) % (width + 200));
                        ctx.save(); ctx.translate(x, height * (0.35 + idx*0.05)); ctx.scale(scaleFactor * (0.8 + idx*0.1), scaleFactor * (0.8 + idx*0.1));
                        const anim = Math.sin(player.frame * 0.1) * 5;
                        ctx.strokeStyle = '#92400e'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(0, 20); ctx.quadraticCurveTo(-20, 30, -10 + anim, 40); ctx.stroke();
                        drawPixelRect(ctx, -15, -10, 30, 35, '#92400e', '#78350f'); drawPixelRect(ctx, -12, -25, 24, 22, '#92400e', '#78350f');
                        drawPixelRect(ctx, -8, -20, 16, 12, '#fdba74', null, false); ctx.fillStyle = '#000'; ctx.fillRect(-5, -16, 2, 3); ctx.fillRect(3, -16, 2, 3);
                        drawPixelRect(ctx, -18, -22, 6, 6, '#92400e', null); drawPixelRect(ctx, 12, -22, 6, 6, '#92400e', null); ctx.restore();
                    });

                    ctx.fillStyle = '#78350f'; ctx.fillRect(0, height * 0.7, width, height * 0.3);
                    ctx.fillStyle = '#451a03'; const rdOff = (player.worldX * 8) % 200;
                    for (let x = -200; x < width + 200; x += 100) { ctx.fillRect(x - rdOff, height * 0.75 + Math.sin(x) * 10, 10, 4); }

                    const bikeX = width / 2; const bikeY = height * 0.78; const bounce = Math.sin(player.frame * 0.25) * 4;
                    const bikeScale = scaleFactor * 1.6;

                    ctx.save(); ctx.translate(bikeX, bikeY + bounce); ctx.scale(bikeScale, bikeScale);
                    const drawWheel = (ctx, x, y) => { ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(x+28, y+28, 28, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#334155'; ctx.beginPath(); ctx.arc(x+28, y+28, 14, 0, Math.PI*2); ctx.fill(); };
                    drawWheel(ctx, -85, 0); drawWheel(ctx, 18, 0);
                    drawPixelRect(ctx, -35, -5, 60, 25, '#475569', '#1e293b'); drawPixelRect(ctx, -50, -15, 80, 15, '#e11d48', '#9f1239');
                    ctx.restore();

                    ctx.save(); ctx.translate(bikeX - (68 * bikeScale), (bikeY + bounce) - (110 * bikeScale)); ctx.scale(bikeScale, bikeScale); renderCharacterBase(ctx, 'female', player.frame); ctx.restore();
                    ctx.save(); ctx.translate(bikeX - (20 * bikeScale), (bikeY + bounce) - (115 * bikeScale)); ctx.scale(bikeScale, bikeScale); renderCharacterBase(ctx, 'male', player.frame); ctx.restore();

                    if (hat.state !== 'gone') {
                        ctx.save();
                        if (hat.state === 'attached' || hat.state === 'saved') {
                            hat.screenX = bikeX + ((-68 + 50) * bikeScale); hat.screenY = (bikeY + bounce) + ((-110 + 15) * bikeScale);
                        } else if (hat.state === 'flying') {
                            const el = player.frame - hat.flyTimer; const elS = el / 60;
                            const startX = bikeX + ((-68 + 50) * bikeScale); const startY = (bikeY + bounce) + ((-110 + 15) * bikeScale);
                            if (elS < 5) { hat.floatY = -280 * scaleFactor * (Math.min(1, elS * 2)); hat.floatX = Math.sin(el * 0.05) * 40 * scaleFactor; }
                            hat.screenX = startX + hat.floatX; hat.screenY = startY + hat.floatY;
                        }
                        ctx.translate(hat.screenX, hat.screenY);
                        const hW = 65 * scaleFactor; const hH = 8 * scaleFactor; const dR = 24 * scaleFactor;
                        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(0, 0, hW + 3, hH + 2, 0, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = '#fde047'; ctx.beginPath(); ctx.ellipse(0, 0, hW, hH, 0, 0, Math.PI * 2); ctx.fill();
                        ctx.beginPath(); ctx.arc(0, -5 * scaleFactor, dR, Math.PI, 0); ctx.fill();
                        ctx.fillStyle = '#f43f5e'; ctx.fillRect(-dR, -8 * scaleFactor, dR * 2, 6 * scaleFactor);
                        ctx.restore();
                    }
                    
                    // Draw baby sea turtles crossing when hat is saved
                    if (hat.state === 'saved' && player.turtles) {
                        player.turtles.forEach(turtle => {
                            ctx.save();
                            ctx.translate(turtle.x, turtle.y);
                            ctx.scale(scaleFactor * turtle.size, scaleFactor * turtle.size);
                            
                            // Turtle body (oval shell)
                            ctx.fillStyle = '#16a34a'; // Green
                            ctx.beginPath();
                            ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Shell pattern
                            ctx.fillStyle = '#15803d';
                            ctx.beginPath();
                            ctx.ellipse(0, 0, 14, 10, 0, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Head (small circle at front)
                            ctx.fillStyle = '#22c55e';
                            ctx.beginPath();
                            ctx.arc(18, 0, 6, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Little eyes
                            ctx.fillStyle = '#000';
                            ctx.fillRect(20, -2, 2, 2);
                            
                            // Flippers (animated)
                            const legAnim = Math.sin(turtle.legPhase);
                            ctx.fillStyle = '#22c55e';
                            
                            // Front flippers
                            ctx.beginPath();
                            ctx.ellipse(8, -12 + legAnim * 2, 6, 8, -0.3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.ellipse(8, 12 - legAnim * 2, 6, 8, 0.3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Back flippers
                            ctx.beginPath();
                            ctx.ellipse(-8, -10 - legAnim * 2, 5, 7, -0.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.ellipse(-8, 10 + legAnim * 2, 5, 7, 0.5, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.restore();
                        });
                    }
                }
            },
            genius_logic: {
                update: (context) => {
                    const { player, setGameState, isCelebrating, config } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize genius game state
                    if (!player.genius) {
                        player.genius = {
                            currentCard: null,
                            targetNumber: 10, // Looking for 10s
                            correctOpens: 0,
                            requiredOpens: 5,
                            cardFlipped: false,
                            showResult: false,
                            resultText: '',
                            resultTimer: 0,
                            collectedCards: [],
                            animatingCard: null,
                            animationProgress: 0,
                            waitingForGameOver: false,
                            musicStarted: false // Track if music has started
                        };
                        // Generate first card (35% chance of 10)
                        const rand = Math.random();
                        player.genius.currentCard = {
                            value: rand < 0.35 ? 10 : Math.floor(Math.random() * 9) + 1, // 35% chance of 10, otherwise 1-9
                            isTen: false
                        };
                        player.genius.currentCard.isTen = player.genius.currentCard.value === 10;
                    }
                    
                    const g = player.genius;
                    
                    // Handle wrong card waiting - show flipped card then game over
                    if (g.waitingForGameOver) {
                        g.resultTimer++;
                        if (g.resultTimer > 90) { // Show for 1.5 seconds
                            setGameState(prev => ({ 
                                ...prev, 
                                status: GameStatus.GAMEOVER, 
                                deathReason: `OPENED A ${g.currentCard.value}! YOU NEEDED A ${g.targetNumber}!` 
                            }));
                        }
                        player.frame++;
                        return;
                    }
                    
                    // Handle card animation to bottom
                    if (g.animatingCard) {
                        g.animationProgress += 0.05;
                        if (g.animationProgress >= 1) {
                            g.collectedCards.push(g.animatingCard);
                            g.animatingCard = null;
                            g.animationProgress = 0;
                            g.cardFlipped = false;
                            g.showResult = false;
                            
                            // Check if we just completed the game
                            if (g.correctOpens >= g.requiredOpens) {
                                isCelebrating.current = true;
                                setTimeout(() => {
                                    setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                                }, 3000);
                                return;
                            }
                            
                            // Generate next card (35% chance of 10)
                            const rand = Math.random();
                            g.currentCard = {
                                value: rand < 0.35 ? 10 : Math.floor(Math.random() * 9) + 1, // 35% chance of 10, otherwise 1-9
                                isTen: false
                            };
                            g.currentCard.isTen = g.currentCard.value === 10;
                        }
                    }
                    
                    // Handle result display timer (for wrong cards or pass)
                    if (g.showResult && !g.animatingCard) {
                        g.resultTimer++;
                        if (g.resultTimer > 90) { // Show for 1.5 seconds
                            if (g.waitingForGameOver) {
                                // Trigger game over
                                setGameState(prev => ({ 
                                    ...prev, 
                                    status: GameStatus.GAMEOVER, 
                                    deathReason: `OPENED A ${g.currentCard.value}! YOU NEEDED A ${g.targetNumber}!` 
                                }));
                            } else {
                                // Just passed - generate next card
                                g.showResult = false;
                                g.resultTimer = 0;
                                g.cardFlipped = false;
                                
                                // Generate next card (35% chance of 10)
                                const rand = Math.random();
                                g.currentCard = {
                                    value: rand < 0.35 ? 10 : Math.floor(Math.random() * 9) + 1, // 35% chance of 10, otherwise 1-9
                                    isTen: false
                                };
                                g.currentCard.isTen = g.currentCard.value === 10;
                            }
                        }
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player, config, isCelebrating } = context;
                    const { width, height } = dimensions;
                    
                    const g = player.genius || { currentCard: null, targetNumber: 10, correctOpens: 0, requiredOpens: 5, collectedCards: [], cardFlipped: false, showResult: false, resultText: '' };
                    
                    // Dark game show background
                    const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                    bgGrad.addColorStop(0, '#0f0a1f');
                    bgGrad.addColorStop(1, '#1a0f2e');
                    ctx.fillStyle = bgGrad;
                    ctx.fillRect(0, 0, width, height);
                    
                    // Neon accents
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 4 * scaleFactor;
                    ctx.strokeRect(20 * scaleFactor, 20 * scaleFactor, width - 40 * scaleFactor, height - 40 * scaleFactor);
                    
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2 * scaleFactor;
                    ctx.strokeRect(30 * scaleFactor, 30 * scaleFactor, width - 60 * scaleFactor, height - 60 * scaleFactor);
                    
                    // Giant hexagonal 'G' logo in background (styled like The Genius logo)
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    
                    const centerX = width * 0.5;
                    const centerY = height * 0.5;
                    const hexSize = 180 * scaleFactor;
                    
                    // Draw hexagon background
                    ctx.fillStyle = '#d4af37'; // Gold color
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 6;
                        const x = centerX + hexSize * Math.cos(angle);
                        const y = centerY + hexSize * Math.sin(angle);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw 3D shaded edges (darker gold)
                    ctx.fillStyle = '#b8941f';
                    ctx.beginPath();
                    // Right edges for depth
                    for (let i = 2; i < 5; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 6;
                        const x = centerX + hexSize * Math.cos(angle);
                        const y = centerY + hexSize * Math.sin(angle);
                        if (i === 2) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.lineTo(centerX + hexSize * Math.cos((Math.PI / 3) * 4 - Math.PI / 6) + 15 * scaleFactor, 
                              centerY + hexSize * Math.sin((Math.PI / 3) * 4 - Math.PI / 6) + 15 * scaleFactor);
                    ctx.lineTo(centerX + hexSize * Math.cos((Math.PI / 3) * 3 - Math.PI / 6) + 15 * scaleFactor,
                              centerY + hexSize * Math.sin((Math.PI / 3) * 3 - Math.PI / 6) + 15 * scaleFactor);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw red/coral G shape inside
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = `${140 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('G', centerX, centerY);
                    
                    ctx.restore();
                    
                    // Target text
                    ctx.fillStyle = '#00ffff';
                    ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`FIND THE ${g.targetNumber}s`, width * 0.5, height * 0.15);
                    
                    // Draw card (center of screen) - BIGGER
                    if (g.currentCard && !g.animatingCard) {
                        const cardW = 140 * scaleFactor; // Bigger (was 120)
                        const cardH = 180 * scaleFactor; // Bigger (was 160)
                        const cardX = width * 0.5 - cardW / 2;
                        const cardY = height * 0.4 - cardH / 2;
                        
                        if (!g.cardFlipped) {
                            // Card back - with subtle difference for 10s (Hong Jinho move!)
                            if (g.currentCard.isTen) {
                                // Subtle difference: slightly different pattern
                                ctx.fillStyle = '#1a1a2e'; // Very slightly different shade
                            } else {
                                ctx.fillStyle = '#16161d';
                            }
                            ctx.fillRect(cardX, cardY, cardW, cardH);
                            
                            // Card back pattern
                            ctx.strokeStyle = g.currentCard.isTen ? '#2d2d44' : '#222230'; // Subtle difference
                            ctx.lineWidth = 2;
                            for (let i = 0; i < 8; i++) {
                                ctx.strokeRect(cardX + 10 * scaleFactor + i * 12 * scaleFactor, cardY + 10 * scaleFactor, 10 * scaleFactor, cardH - 20 * scaleFactor);
                            }
                            
                            // Border
                            ctx.strokeStyle = '#4a4a6a';
                            ctx.lineWidth = 4;
                            ctx.strokeRect(cardX, cardY, cardW, cardH);
                        } else {
                            // Card front - flipped
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(cardX, cardY, cardW, cardH);
                            
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 4;
                            ctx.strokeRect(cardX, cardY, cardW, cardH);
                            
                            // Number
                            ctx.fillStyle = g.currentCard.value === 10 ? '#ff0000' : '#000';
                            ctx.font = `${60 * scaleFactor}px "Press Start 2P"`;
                            ctx.textAlign = 'center';
                            ctx.fillText(g.currentCard.value.toString(), width * 0.5, height * 0.45);
                        }
                    }
                    
                    // Animating card to bottom
                    if (g.animatingCard) {
                        const startY = height * 0.4;
                        const endY = height - 100 * scaleFactor;
                        const currentY = startY + (endY - startY) * g.animationProgress;
                        
                        const cardW = 80 * scaleFactor * (1 - g.animationProgress * 0.5); // Shrink as it moves
                        const cardH = 100 * scaleFactor * (1 - g.animationProgress * 0.5);
                        const cardX = (width * 0.2 + g.collectedCards.length * 90 * scaleFactor) - cardW / 2;
                        
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(cardX, currentY - cardH / 2, cardW, cardH);
                        
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(cardX, currentY - cardH / 2, cardW, cardH);
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.font = `${30 * scaleFactor * (1 - g.animationProgress * 0.5)}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText(g.animatingCard.value.toString(), cardX + cardW / 2, currentY);
                    }
                    
                    // Collected cards at bottom
                    g.collectedCards.forEach((card, idx) => {
                        const cardW = 80 * scaleFactor;
                        const cardH = 100 * scaleFactor;
                        const cardX = width * 0.2 + idx * 90 * scaleFactor - cardW / 2;
                        const cardY = height - 100 * scaleFactor;
                        
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(cardX, cardY - cardH / 2, cardW, cardH);
                        
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(cardX, cardY - cardH / 2, cardW, cardH);
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.font = `${30 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText(card.value.toString(), cardX + cardW / 2, cardY);
                    });
                    
                    // Result text
                    if (g.showResult) {
                        ctx.save();
                        const alpha = Math.sin(g.resultTimer * 0.1) * 0.3 + 0.7;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = g.resultText === 'ZING!' ? '#00ff00' : '#ff0000';
                        ctx.font = `${40 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText(g.resultText, width * 0.5, height * 0.6);
                        ctx.restore();
                    }
                    
                    // OPEN and PASS buttons
                    if (!g.animatingCard && !g.showResult && g.currentCard) {
                        const buttonW = 140 * scaleFactor;
                        const buttonH = 50 * scaleFactor;
                        const buttonY = height * 0.7;
                        
                        // Store button bounds for click detection
                        if (!g.openButton) g.openButton = {};
                        if (!g.passButton) g.passButton = {};
                        
                        // OPEN button
                        const openX = width * 0.3 - buttonW / 2;
                        g.openButton.x = openX;
                        g.openButton.y = buttonY;
                        g.openButton.w = buttonW;
                        g.openButton.h = buttonH;
                        
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(openX, buttonY, buttonW, buttonH);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(openX, buttonY, buttonW, buttonH);
                        ctx.fillStyle = '#000';
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('OPEN', openX + buttonW / 2, buttonY + 32 * scaleFactor);
                        
                        // PASS button
                        const passX = width * 0.7 - buttonW / 2;
                        g.passButton.x = passX;
                        g.passButton.y = buttonY;
                        g.passButton.w = buttonW;
                        g.passButton.h = buttonH;
                        
                        ctx.fillStyle = '#ff00ff';
                        ctx.fillRect(passX, buttonY, buttonW, buttonH);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(passX, buttonY, buttonW, buttonH);
                        ctx.fillStyle = '#000';
                        ctx.fillText('PASS', passX + buttonW / 2, buttonY + 32 * scaleFactor);
                    }
                    
                    // Characters in fancy outfits at the sides
                    if (!isCelebrating.current) {
                        // Romy in fancy dress (left side) - 2x BIGGER
                        ctx.save();
                        ctx.translate(width * 0.1, height * 0.55); // Higher (was 0.75)
                        ctx.scale(scaleFactor * 2.4, scaleFactor * 2.4); // Was 1.2, now 2.4
                        ctx.translate(-50, 0);
                        
                        // Render Romy with sparkly dress
                        const hairColor = '#222';
                        drawPixelRect(ctx, 24, 16, 52, 6, hairColor, '#000');
                        drawPixelRect(ctx, 18, 22, 64, 38, hairColor, '#000');
                        const skin = '#ffd6cc';
                        ctx.fillStyle = skin;
                        ctx.fillRect(30, 28, 40, 38);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(38, 44, 6, 6);
                        ctx.fillRect(56, 44, 6, 6);
                        // Sparkly purple dress
                        drawPixelRect(ctx, 30, 66, 40, 34, '#9333ea', '#6b21a8');
                        // Sparkles
                        ctx.fillStyle = '#ffffff';
                        const sparkles = [[35, 70], [52, 75], [42, 82], [60, 88]];
                        sparkles.forEach(([x, y]) => ctx.fillRect(x, y, 2, 2));
                        
                        ctx.restore();
                        
                        // James in suit (right side) - 2x BIGGER
                        ctx.save();
                        ctx.translate(width * 0.9, height * 0.55); // Higher (was 0.75)
                        ctx.scale(scaleFactor * 2.4, scaleFactor * 2.4); // Was 1.2, now 2.4
                        ctx.translate(-50, 0);
                        
                        // Black suit
                        drawPixelRect(ctx, 30, 60, 40, 40, '#1a1a1a', '#000000');
                        drawPixelRect(ctx, 30, 20, 40, 40, skin, '#e0b3a8');
                        // Glasses
                        ctx.fillStyle = '#000';
                        ctx.fillRect(31, 31, 14, 12);
                        ctx.fillRect(55, 31, 14, 12);
                        ctx.fillRect(45, 34, 10, 3);
                        ctx.fillStyle = skin;
                        ctx.fillRect(34, 34, 8, 6);
                        ctx.fillRect(58, 34, 8, 6);
                        
                        ctx.restore();
                    }
                }
            },
            stealth_engine: {
                update: (context) => {
                    const { player, setGameState, isCelebrating, config } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize stealth state
                    if (!player.stealth) {
                        player.stealth = {
                            bearState: 'SNIFFING', // SNIFFING, ALERT, LOOKING
                            stateTimer: 0,
                            stateDuration: 120, // frames in current state
                            fearMeter: 0,
                            isHolding: false,
                            survivedGazes: 0,
                            requiredGazes: 4,
                            eyeGlow: 0,
                            walkOffset: 0, // How far everyone has walked
                            isWalking: true
                        };
                    }
                    
                    const s = player.stealth;
                    
                    // Everyone walks when bear is SNIFFING
                    if (s.isWalking && s.bearState === 'SNIFFING') {
                        s.walkOffset += 0.8;
                    }
                    
                    // Update state timer
                    s.stateTimer++;
                    
                    // State machine
                    if (s.stateTimer >= s.stateDuration) {
                        s.stateTimer = 0;
                        
                        if (s.bearState === 'SNIFFING') {
                            // Randomly go to ALERT or stay SNIFFING
                            if (Math.random() < 0.6) {
                                s.bearState = 'ALERT';
                                s.stateDuration = 60 + Math.random() * 60; // 1-2 seconds
                                s.isWalking = false; // Everyone stops
                            } else {
                                s.stateDuration = 90 + Math.random() * 90; // 1.5-3 seconds
                            }
                        } else if (s.bearState === 'ALERT') {
                            // Bear looks!
                            s.bearState = 'LOOKING';
                            s.stateDuration = 120 + Math.random() * 60; // 2-3 seconds
                            s.eyeGlow = 0;
                            // Play bear growl
                            if (context.playBearGrowlSound) context.playBearGrowlSound();
                        } else if (s.bearState === 'LOOKING') {
                            // Survived this gaze!
                            s.survivedGazes++;
                            s.bearState = 'SNIFFING';
                            s.stateDuration = 90 + Math.random() * 90; // 1.5-3 seconds
                            s.fearMeter = Math.max(0, s.fearMeter - 20); // Reduce fear
                            s.isWalking = true; // Everyone resumes walking
                        }
                    }
                    
                    // Eye glow animation when LOOKING
                    if (s.bearState === 'LOOKING') {
                        s.eyeGlow = Math.sin(player.frame * 0.2) * 0.5 + 0.5;
                    }
                    
                    // Fear meter logic
                    if (s.bearState === 'LOOKING') {
                        if (!s.isHolding) {
                            // Not holding - fear increases!
                            s.fearMeter += 2;
                            
                            // Play heartbeat every 60 frames when fear is rising
                            if (player.frame % 60 === 0 && context.playHeartbeatSound) {
                                context.playHeartbeatSound();
                            }
                            
                            if (s.fearMeter >= 100) {
                                // Restart level
                                setGameState(prev => ({ 
                                    ...prev, 
                                    status: GameStatus.GAMEOVER, 
                                    deathReason: 'THE BEAR NOTICED YOU MOVING!' 
                                }));
                            }
                        }
                    }
                    
                    // Check win condition
                    if (s.survivedGazes >= s.requiredGazes) {
                        isCelebrating.current = true;
                        setTimeout(() => {
                            setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                        }, 3000);
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player, config, isCelebrating } = context;
                    const { width, height } = dimensions;
                    
                    const s = player.stealth || { bearState: 'SNIFFING', fearMeter: 0, survivedGazes: 0, requiredGazes: 4, eyeGlow: 0, walkOffset: 0, isWalking: true };
                    
                    // Scrolling background offset
                    const bgScroll = s.walkOffset || 0;
                    
                    // Sky - light blue
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, height * 0.6);
                    skyGrad.addColorStop(0, '#87CEEB');
                    skyGrad.addColorStop(1, '#B0E0E6');
                    ctx.fillStyle = skyGrad;
                    ctx.fillRect(0, 0, width, height);
                    
                    // Gray mountains in background (parallax - slower)
                    ctx.save();
                    ctx.translate(-bgScroll * 0.2, 0);
                    
                    ctx.fillStyle = '#808080';
                    ctx.beginPath();
                    ctx.moveTo(-width, height * 0.4);
                    ctx.lineTo(width * 0.3, height * 0.15);
                    ctx.lineTo(width * 0.6, height * 0.3);
                    ctx.lineTo(width, height * 0.2);
                    ctx.lineTo(width * 1.5, height * 0.25);
                    ctx.lineTo(width * 2, height * 0.6);
                    ctx.lineTo(-width, height * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Snow caps
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(width * 0.25, height * 0.2);
                    ctx.lineTo(width * 0.3, height * 0.15);
                    ctx.lineTo(width * 0.35, height * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // Pine trees (scrolling with parallax - medium speed)
                    const drawTree = (x, y, size) => {
                        ctx.fillStyle = '#2d5016';
                        // Trunk
                        ctx.fillRect(x - 5 * size * scaleFactor, y, 10 * size * scaleFactor, 30 * size * scaleFactor);
                        // Tree layers
                        ctx.fillStyle = '#1a3409';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(x - 25 * size * scaleFactor, y - i * 15 * size * scaleFactor);
                            ctx.lineTo(x, y - (i * 15 + 25) * size * scaleFactor);
                            ctx.lineTo(x + 25 * size * scaleFactor, y - i * 15 * size * scaleFactor);
                            ctx.closePath();
                            ctx.fill();
                        }
                    };
                    
                    ctx.save();
                    ctx.translate(-bgScroll * 0.5, 0);
                    
                    // Multiple trees that loop
                    for (let i = -1; i < 5; i++) {
                        drawTree(width * (0.15 + i * 0.3), height * 0.6, 1.2);
                        drawTree(width * (0.08 + i * 0.3), height * 0.7, 1);
                    }
                    
                    ctx.restore();
                    
                    // Forest ground (scrolling)
                    ctx.fillStyle = '#228b22';
                    ctx.fillRect(0, height * 0.6, width, height * 0.4);
                    
                    // Trail (dirt path) - scrolling with lines to show movement
                    ctx.save();
                    ctx.translate(-bgScroll, 0);
                    
                    ctx.fillStyle = '#8b7355';
                    ctx.fillRect(-width, height * 0.75, width * 4, height * 0.05);
                    
                    // Trail lines to show movement
                    ctx.strokeStyle = '#6b5a45';
                    ctx.lineWidth = 2;
                    for (let i = -10; i < 20; i++) {
                        const x = i * 100 * scaleFactor;
                        ctx.beginPath();
                        ctx.moveTo(x, height * 0.75);
                        ctx.lineTo(x + 30 * scaleFactor, height * 0.8);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                    
                    // Romy, James, and Bear all STAY CENTERED with hopping animation
                    const walkBob = s.isWalking ? Math.abs(Math.sin(player.frame * 0.3)) * 8 * scaleFactor : 0; // Hopping motion
                    
                    // Romy - FIXED CENTER POSITION
                    const romyX = width * 0.35;
                    ctx.save();
                    ctx.translate(romyX, height * 0.72 - walkBob);
                    ctx.scale(scaleFactor * 1.8, scaleFactor * 1.8);
                    ctx.translate(-50, 0);
                    renderCharacterBase(ctx, 'female', player.frame);
                    ctx.restore();
                    
                    // James - FIXED CENTER POSITION (slightly behind and to the right)
                    const jamesX = width * 0.45;
                    ctx.save();
                    ctx.translate(jamesX, height * 0.72 - walkBob);
                    ctx.scale(scaleFactor * 1.8, scaleFactor * 1.8);
                    ctx.translate(-50, 0);
                    renderCharacterBase(ctx, 'male', player.frame);
                    ctx.restore();
                    
                    // Black Bear - FIXED CENTER POSITION (ahead of Romy and James with 90 unit gap)
                    const bearX = width * 0.6 + 90; // 90 units of spacing
                    const bearY = height * 0.65;
                    const bearScale = scaleFactor * 2.5;
                    
                    ctx.save();
                    ctx.translate(bearX, bearY - walkBob);
                    ctx.scale(bearScale, bearScale);
                    
                    // Bear body - chunky black bear
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-40, -20, 80, 60); // Main body
                    
                    // Bear head
                    ctx.fillRect(-30, -50, 60, 35); // Head
                    
                    // Ears
                    ctx.fillRect(-35, -55, 15, 15); // Left ear
                    ctx.fillRect(20, -55, 15, 15); // Right ear
                    
                    // Snout
                    ctx.fillStyle = '#2d2d2d';
                    ctx.fillRect(-15, -30, 30, 20);
                    
                    // Nose
                    ctx.fillStyle = '#000';
                    ctx.fillRect(-5, -15, 10, 8);
                    
                    // Eyes - GLOW when LOOKING
                    if (s.bearState === 'LOOKING') {
                        const glowAlpha = s.eyeGlow;
                        ctx.fillStyle = `rgba(255, 0, 0, ${glowAlpha})`;
                        // Red glow
                        ctx.fillRect(-20, -40, 12, 12);
                        ctx.fillRect(8, -40, 12, 12);
                        // White center
                        ctx.fillStyle = `rgba(255, 255, 255, ${glowAlpha})`;
                        ctx.fillRect(-17, -37, 6, 6);
                        ctx.fillRect(11, -37, 6, 6);
                    } else {
                        // Normal eyes
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-18, -38, 8, 8);
                        ctx.fillRect(10, -38, 8, 8);
                    }
                    
                    // Legs
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-35, 40, 20, 25); // Front left
                    ctx.fillRect(-10, 40, 20, 25); // Front right
                    ctx.fillRect(15, 40, 20, 25); // Back right
                    
                    ctx.restore();
                    
                    // Bear state indicator
                    const stateColors = {
                        'SNIFFING': '#00ff00',
                        'ALERT': '#ffff00',
                        'LOOKING': '#ff0000'
                    };
                    
                    ctx.fillStyle = stateColors[s.bearState];
                    ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.fillText(s.bearState, width * 0.5, height * 0.12);
                    
                    // Instructions
                    if (s.bearState === 'LOOKING') {
                        ctx.fillStyle = '#ff0000';
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`; // Increased from 12 to 16
                        ctx.fillText('HOLD STILL!', width * 0.5, height * 0.25); // Moved from 0.18 to 0.25
                    }
                    
                    // Fear meter
                    const meterX = width * 0.1;
                    const meterY = height * 0.15; // Moved down from 0.1 to 0.15 to avoid level title
                    const meterW = width * 0.3;
                    const meterH = 20 * scaleFactor;
                    
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(meterX, meterY, meterW, meterH);
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(meterX, meterY, meterW * (s.fearMeter / 100), meterH);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(meterX, meterY, meterW, meterH);
                    
                    ctx.fillStyle = '#000';
                    ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'left';
                    ctx.fillText('FEAR', meterX, meterY - 5 * scaleFactor);
                    
                    // Progress counter (gazes survived)
                    ctx.fillStyle = '#fff';
                    ctx.font = `${12 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'right';
                    ctx.fillText(`${s.survivedGazes} / ${s.requiredGazes} GAZES`, width * 0.9, height * 0.12);
                }
            },
            noraebang_logic: {
                update: (context) => {
                    const { player, setGameState, isCelebrating } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize noraebang state
                    if (!player.noraebang) {
                        player.noraebang = {
                            singerChosen: null, // 'james' or 'romy'
                            performanceTimer: 0,
                            shakeIntensity: 0,
                            noteParticles: [],
                            bounceOffset: 0,
                            discoHue: 0
                        };
                    }
                    
                    const n = player.noraebang;
                    
                    // If singer chosen, run performance
                    if (n.singerChosen) {
                        n.performanceTimer++;
                        
                        // Disco light color cycling
                        n.discoHue = (n.performanceTimer * 3) % 360;
                        
                        if (n.singerChosen === 'james') {
                            // James - terrible singing, screen shake, broken notes
                            n.shakeIntensity = Math.sin(n.performanceTimer * 0.5) * 15;
                            
                            // Play bad singing sounds every 20 frames
                            if (n.performanceTimer % 20 === 0 && context.playBadSingingSound) {
                                context.playBadSingingSound();
                            }
                            
                            // Spawn broken notes
                            if (n.performanceTimer % 15 === 0) {
                                n.noteParticles.push({
                                    char: ['', '', ''][Math.floor(Math.random() * 3)],
                                    x: Math.random() * context.dimensions.width,
                                    y: context.dimensions.height * 0.3,
                                    vy: -3 - Math.random() * 2,
                                    vx: (Math.random() - 0.5) * 4,
                                    rotation: Math.random() * 360,
                                    rotationSpeed: (Math.random() - 0.5) * 10
                                });
                            }
                            
                            // Game over after 10 seconds (doubled from 5)
                            if (n.performanceTimer >= 600) {
                                setGameState(prev => ({ 
                                    ...prev, 
                                    status: GameStatus.GAMEOVER, 
                                    deathReason: "OH NO! JAMES'S SINGING SHATTERED THE GLASS! EVERYONE RAN AWAY!" 
                                }));
                            }
                        } else {
                            // Romy - amazing singing, bouncing, sparkly notes
                            n.bounceOffset = Math.sin(n.performanceTimer * 0.2) * 20;
                            
                            // Play K-pop beat every 30 frames (every half second)
                            if (n.performanceTimer % 30 === 0 && context.playKpopBeat) {
                                context.playKpopBeat();
                            }
                            
                            // Spawn sparkly notes
                            if (n.performanceTimer % 10 === 0) {
                                n.noteParticles.push({
                                    char: ['', '', '', ''][Math.floor(Math.random() * 4)],
                                    x: Math.random() * context.dimensions.width,
                                    y: context.dimensions.height * 0.3,
                                    vy: -2 - Math.random() * 2,
                                    vx: (Math.random() - 0.5) * 3,
                                    rotation: 0,
                                    rotationSpeed: 0,
                                    color: ['#ff6b9d', '#ffd93d', '#6bcf7f', '#4ecdc4'][Math.floor(Math.random() * 4)]
                                });
                            }
                            
                            // Win after 10 seconds (doubled from 5)
                            if (n.performanceTimer >= 600) {
                                isCelebrating.current = true;
                                setTimeout(() => {
                                    setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                                }, 2000);
                            }
                        }
                        
                        // Update particles
                        n.noteParticles = n.noteParticles.filter(p => {
                            p.y += p.vy;
                            p.x += p.vx;
                            p.vy += 0.1; // Gravity
                            p.rotation += p.rotationSpeed;
                            return p.y < context.dimensions.height && p.y > -100;
                        });
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    const { width, height } = dimensions;
                    
                    const n = player.noraebang || { singerChosen: null, shakeIntensity: 0, noteParticles: [], bounceOffset: 0, discoHue: 0 };
                    
                    // Apply shake if James is singing
                    if (n.singerChosen === 'james' && n.shakeIntensity > 0) {
                        ctx.save();
                        const shakeX = (Math.random() - 0.5) * n.shakeIntensity;
                        const shakeY = (Math.random() - 0.5) * n.shakeIntensity;
                        ctx.translate(shakeX, shakeY);
                    }
                    
                    // Background - changes color with disco lights during performance
                    if (n.singerChosen) {
                        // Disco light effect
                        const hue1 = n.discoHue;
                        const hue2 = (n.discoHue + 120) % 360;
                        const color1 = `hsl(${hue1}, 60%, 25%)`;
                        const color2 = `hsl(${hue2}, 60%, 15%)`;
                        
                        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                        bgGrad.addColorStop(0, color1);
                        bgGrad.addColorStop(1, color2);
                        ctx.fillStyle = bgGrad;
                        ctx.fillRect(0, 0, width, height);
                        
                        // Disco ball spotlight effect
                        const time = player.frame * 0.1;
                        for (let i = 0; i < 8; i++) {
                            const x = width * 0.5 + Math.cos(time + i * Math.PI / 4) * 100 * scaleFactor;
                            const y = height * 0.15 + Math.sin(time + i * Math.PI / 4) * 50 * scaleFactor;
                            const spotHue = (n.discoHue + i * 45) % 360;
                            ctx.fillStyle = `hsla(${spotHue}, 100%, 70%, 0.3)`;
                            ctx.beginPath();
                            ctx.arc(x, y, 25 * scaleFactor, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else {
                        // Normal dark purple background for selection
                        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                        bgGrad.addColorStop(0, '#4c1d95');
                        bgGrad.addColorStop(1, '#2e1065');
                        ctx.fillStyle = bgGrad;
                        ctx.fillRect(0, 0, width, height);
                    }
                    
                    // If no singer chosen yet, show selection screen
                    if (!n.singerChosen) {
                        // Title
                        ctx.fillStyle = '#ff6b9d';
                        ctx.font = `${18 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('CHOOSE YOUR', width * 0.5, height * 0.15);
                        ctx.fillText('SINGER!', width * 0.5, height * 0.23);
                        
                        // James box (left)
                        const boxW = width * 0.35;
                        const boxH = height * 0.5;
                        const jamesX = width * 0.1;
                        const jamesY = height * 0.35;
                        
                        // Store button bounds for click detection
                        if (!n.buttonBounds) n.buttonBounds = {};
                        n.buttonBounds.james = { x: jamesX, y: jamesY, w: boxW, h: boxH };
                        
                        // James box background
                        ctx.fillStyle = '#3b82f6';
                        ctx.fillRect(jamesX, jamesY, boxW, boxH);
                        
                        // James box border
                        ctx.strokeStyle = '#1e40af';
                        ctx.lineWidth = 5;
                        ctx.strokeRect(jamesX, jamesY, boxW, boxH);
                        
                        // James label
                        ctx.fillStyle = '#fff';
                        ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('JAMES', jamesX + boxW * 0.5, jamesY + boxH * 0.9);
                        
                        // Romy box (right)
                        const romyX = width * 0.55;
                        const romyY = height * 0.35;
                        
                        n.buttonBounds.romy = { x: romyX, y: romyY, w: boxW, h: boxH };
                        
                        // Romy box background
                        ctx.fillStyle = '#ec4899';
                        ctx.fillRect(romyX, romyY, boxW, boxH);
                        
                        // Romy box border
                        ctx.strokeStyle = '#be185d';
                        ctx.lineWidth = 5;
                        ctx.strokeRect(romyX, romyY, boxW, boxH);
                        
                        // Romy label
                        ctx.fillStyle = '#fff';
                        ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('ROMY', romyX + boxW * 0.5, romyY + boxH * 0.9);
                        
                        // Draw characters in boxes - shifted to align with box center
                        ctx.save();
                        ctx.translate(jamesX + boxW * 0.5 - 75, jamesY + boxH * 0.5 - 60); // Moved 5 right (was -80, now -75)
                        ctx.scale(scaleFactor * 2.5, scaleFactor * 2.5);
                        renderCharacterBase(ctx, 'male', player.frame);
                        ctx.restore();
                        
                        ctx.save();
                        ctx.translate(romyX + boxW * 0.5 - 75, romyY + boxH * 0.5 - 60); // Moved 5 right (was -80, now -75)
                        ctx.scale(scaleFactor * 2.5, scaleFactor * 2.5);
                        renderCharacterBase(ctx, 'female', player.frame);
                        ctx.restore();
                    } else {
                        // Performance mode - show TV in background
                        const tvW = width * 0.6;
                        const tvH = height * 0.4;
                        const tvX = width * 0.2;
                        const tvY = height * 0.1;
                        
                        // TV frame (dark gray)
                        ctx.fillStyle = '#1f2937';
                        ctx.fillRect(tvX - 10 * scaleFactor, tvY - 10 * scaleFactor, 
                                     tvW + 20 * scaleFactor, tvH + 20 * scaleFactor);
                        
                        // TV screen (lighter with glow)
                        ctx.fillStyle = '#374151';
                        ctx.fillRect(tvX, tvY, tvW, tvH);
                        
                        // TV screen glow
                        const glowGrad = ctx.createRadialGradient(
                            tvX + tvW/2, tvY + tvH/2, 0,
                            tvX + tvW/2, tvY + tvH/2, tvW/2
                        );
                        glowGrad.addColorStop(0, 'rgba(96, 165, 250, 0.3)');
                        glowGrad.addColorStop(1, 'rgba(96, 165, 250, 0)');
                        ctx.fillStyle = glowGrad;
                        ctx.fillRect(tvX, tvY, tvW, tvH);
                        
                        // TV Score - fade in over 3 seconds
                        const scoreOpacity = Math.min(1, n.performanceTimer / 180); // 3 seconds = 180 frames
                        const scoreText = n.singerChosen === 'james' ? '0%' : '100%';
                        const scoreColor = n.singerChosen === 'james' ? '#ef4444' : '#22c55e';
                        
                        ctx.save();
                        ctx.globalAlpha = scoreOpacity;
                        ctx.fillStyle = scoreColor;
                        ctx.font = `bold ${80 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(scoreText, tvX + tvW/2, tvY + tvH/2);
                        ctx.restore();
                        
                        // TV stand
                        ctx.fillStyle = '#1f2937';
                        ctx.fillRect(width * 0.45, tvY + tvH + 10 * scaleFactor, 
                                     width * 0.1, 30 * scaleFactor);
                        
                        // Show chosen singer - CENTERED at width * 0.5
                        const singerType = n.singerChosen === 'james' ? 'male' : 'female';
                        const yOffset = n.singerChosen === 'romy' ? -n.bounceOffset : 0;
                        
                        ctx.save();
                        ctx.translate(width * 0.5, height * 0.65 + yOffset);
                        ctx.scale(scaleFactor * 3.5, scaleFactor * 3.5);
                        renderCharacterBase(ctx, singerType, player.frame);
                        ctx.restore();
                        
                        // Draw particles (notes)
                        n.noteParticles.forEach(p => {
                            ctx.save();
                            ctx.translate(p.x, p.y);
                            ctx.rotate(p.rotation * Math.PI / 180);
                            ctx.fillStyle = p.color || '#000';
                            ctx.font = `${30 * scaleFactor}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(p.char, 0, 0);
                            ctx.restore();
                        });
                        
                        // Text
                        if (n.singerChosen === 'james') {
                            ctx.fillStyle = '#ef4444';
                            ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                            ctx.textAlign = 'center';
                            ctx.fillText('OH NO...', width * 0.5, height * 0.93);
                        } else {
                            ctx.fillStyle = '#ffd93d';
                            ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                            ctx.textAlign = 'center';
                            ctx.fillText('AMAZING!', width * 0.5, height * 0.93);
                        }
                    }
                    
                    if (n.singerChosen === 'james' && n.shakeIntensity > 0) {
                        ctx.restore();
                    }
                }
            },
            stuffie_stack: {
                update: (context) => {
                    const { player, setGameState, isCelebrating, dimensions, scaleFactor } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize stuffie stack state
                    if (!player.stuffieStack) {
                        player.stuffieStack = {
                            currentStuffie: 0, // 0=Dr.Spot, 1=TrueHeart, 2=Christmas, 3=James, 4=Romy
                            stuffieOrder: ['drspot', 'trueheart', 'christmas', 'james', 'romy'],
                            fallingStuffie: null, // Current stuffie being dropped
                            stackedStuffies: [], // Stuffies that have been placed
                            sliderX: dimensions.width * 0.5,
                            sliderDirection: 1,
                            sliderSpeed: 3 * scaleFactor,
                            isDropping: false,
                            isCelebrating: false,
                            celebrationTimer: 0
                        };
                    }
                    
                    const s = player.stuffieStack;
                    
                    // Move slider back and forth
                    if (!s.isDropping && !s.fallingStuffie) {
                        s.sliderX += s.sliderDirection * s.sliderSpeed;
                        
                        // Bounce at edges
                        if (s.sliderX <= 100 * scaleFactor || s.sliderX >= dimensions.width - 100 * scaleFactor) {
                            s.sliderDirection *= -1;
                        }
                    }
                    
                    // Update falling stuffie
                    if (s.fallingStuffie) {
                        s.fallingStuffie.vy += 0.5; // Gravity
                        s.fallingStuffie.y += s.fallingStuffie.vy;
                        
                        const stuffieBottom = s.fallingStuffie.y + 60 * scaleFactor;
                        
                        // Check collision with couch or stacked stuffies
                        const couchY = dimensions.height * 0.75;
                        let landed = false;
                        let landedY = 0;
                        
                        // Check if landed on couch
                        if (stuffieBottom >= couchY) {
                            const couchLeft = dimensions.width * 0.2;
                            const couchRight = dimensions.width * 0.8;
                            
                            if (s.fallingStuffie.x >= couchLeft && s.fallingStuffie.x <= couchRight) {
                                landed = true;
                                landedY = couchY - 60 * scaleFactor;
                            } else {
                                // Missed the couch!
                                setGameState(prev => ({ 
                                    ...prev, 
                                    status: GameStatus.GAMEOVER, 
                                    deathReason: 'MISSED THE COUCH! THE STUFFIE FELL!' 
                                }));
                                return;
                            }
                        }
                        
                        // Check if landed on another stuffie
                        for (const stacked of s.stackedStuffies) {
                            const stackedTop = stacked.y;
                            const stackedLeft = stacked.x - 50 * scaleFactor;
                            const stackedRight = stacked.x + 50 * scaleFactor;
                            
                            if (stuffieBottom >= stackedTop && stuffieBottom <= stackedTop + 20 * scaleFactor) {
                                if (s.fallingStuffie.x >= stackedLeft && s.fallingStuffie.x <= stackedRight) {
                                    landed = true;
                                    landedY = stackedTop - 60 * scaleFactor;
                                    break;
                                }
                            }
                        }
                        
                        if (landed) {
                            // Successfully landed!
                            s.stackedStuffies.push({
                                type: s.fallingStuffie.type,
                                x: s.fallingStuffie.x,
                                y: landedY
                            });
                            
                            s.fallingStuffie = null;
                            s.isDropping = false;
                            s.currentStuffie++;
                            
                            // Check if all stuffies stacked
                            if (s.currentStuffie >= s.stuffieOrder.length) {
                                s.isCelebrating = true;
                                s.celebrationTimer = 0;
                                isCelebrating.current = true;
                                setTimeout(() => {
                                    setGameState(st => ({ ...st, status: `LEVEL_${st.levelNumber}_COMPLETE_STORY` }));
                                }, 3000);
                            }
                        }
                    }
                    
                    // Celebration animation - everyone jumps!
                    if (s.isCelebrating) {
                        s.celebrationTimer++;
                        
                        // Make all stacked characters jump in sync
                        const jumpHeight = Math.abs(Math.sin(s.celebrationTimer * 0.15)) * 30 * scaleFactor;
                        s.stackedStuffies.forEach(stuffie => {
                            if (!stuffie.originalY) stuffie.originalY = stuffie.y;
                            stuffie.y = stuffie.originalY - jumpHeight;
                        });
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    const { width, height } = dimensions;
                    
                    const s = player.stuffieStack || { 
                        currentStuffie: 0, 
                        stuffieOrder: ['drspot', 'trueheart', 'christmas', 'james', 'romy'],
                        stackedStuffies: [], 
                        sliderX: width * 0.5, 
                        fallingStuffie: null 
                    };
                    
                    // Background - cozy room
                    const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                    bgGrad.addColorStop(0, '#f0e6d2');
                    bgGrad.addColorStop(1, '#d4c5a9');
                    ctx.fillStyle = bgGrad;
                    ctx.fillRect(0, 0, width, height);
                    
                    // Floor
                    ctx.fillStyle = '#8b7355';
                    ctx.fillRect(0, height * 0.8, width, height * 0.2);
                    
                    // Draw couch (16-bit style)
                    const couchX = width * 0.2;
                    const couchY = height * 0.75;
                    const couchW = width * 0.6;
                    const couchH = height * 0.05;
                    
                    // Couch base (gray)
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(couchX, couchY, couchW, couchH);
                    
                    // Couch cushions (lighter gray)
                    ctx.fillStyle = '#9ca3af';
                    const cushionW = couchW / 3;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(couchX + i * cushionW + 5 * scaleFactor, couchY - 10 * scaleFactor, 
                                     cushionW - 10 * scaleFactor, couchH + 5 * scaleFactor);
                    }
                    
                    // Couch back
                    ctx.fillStyle = '#4b5563';
                    ctx.fillRect(couchX - 10 * scaleFactor, couchY - 80 * scaleFactor, 
                                 10 * scaleFactor, 80 * scaleFactor);
                    ctx.fillRect(couchX + couchW, couchY - 80 * scaleFactor, 
                                 10 * scaleFactor, 80 * scaleFactor);
                    
                    // Helper functions to draw stuffies
                    const drawDrSpot = (x, y, scale) => {
                        const s = scale * scaleFactor;
                        ctx.save();
                        ctx.translate(x, y);
                        
                        // Light brown/tan body
                        ctx.fillStyle = '#d2b48c';
                        ctx.fillRect(-25*s, -20*s, 50*s, 50*s); // Body
                        
                        // Head
                        ctx.fillRect(-20*s, -40*s, 40*s, 25*s);
                        
                        // Floppy ears
                        ctx.fillStyle = '#c19a6b';
                        ctx.fillRect(-30*s, -38*s, 15*s, 30*s); // Left ear
                        ctx.fillRect(15*s, -38*s, 15*s, 30*s);  // Right ear
                        
                        // White t-shirt
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-20*s, -15*s, 40*s, 25*s);
                        
                        // Green camo pants
                        ctx.fillStyle = '#4a5d23';
                        ctx.fillRect(-20*s, 10*s, 40*s, 20*s);
                        
                        // Camo pattern
                        ctx.fillStyle = '#3d4a1c';
                        ctx.fillRect(-15*s, 12*s, 8*s, 6*s);
                        ctx.fillRect(8*s, 15*s, 7*s, 5*s);
                        
                        // Tiny black nose
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-3*s, -22*s, 6*s, 5*s);
                        
                        // Eyes
                        ctx.fillRect(-10*s, -32*s, 5*s, 5*s);
                        ctx.fillRect(5*s, -32*s, 5*s, 5*s);
                        
                        ctx.restore();
                    };
                    
                    const drawTrueHeartBear = (x, y, scale) => {
                        const s = scale * scaleFactor;
                        ctx.save();
                        ctx.translate(x, y);
                        
                        // Pale pink fur
                        ctx.fillStyle = '#ffc0cb';
                        ctx.fillRect(-25*s, -20*s, 50*s, 50*s); // Body
                        
                        // Head
                        ctx.fillRect(-20*s, -40*s, 40*s, 25*s);
                        
                        // Ears
                        ctx.fillStyle = '#ffb6c1';
                        ctx.beginPath();
                        ctx.arc(-15*s, -42*s, 8*s, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(15*s, -42*s, 8*s, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Belly badge - white circle
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(0, 5*s, 15*s, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Rainbow star on belly badge
                        const drawStar = (cx, cy, spikes, outerRadius, innerRadius) => {
                            let rot = Math.PI / 2 * 3;
                            let x = cx;
                            let y = cy;
                            const step = Math.PI / spikes;
                            
                            ctx.beginPath();
                            ctx.moveTo(cx, cy - outerRadius);
                            for (let i = 0; i < spikes; i++) {
                                x = cx + Math.cos(rot) * outerRadius;
                                y = cy + Math.sin(rot) * outerRadius;
                                ctx.lineTo(x, y);
                                rot += step;
                                
                                x = cx + Math.cos(rot) * innerRadius;
                                y = cy + Math.sin(rot) * innerRadius;
                                ctx.lineTo(x, y);
                                rot += step;
                            }
                            ctx.lineTo(cx, cy - outerRadius);
                            ctx.closePath();
                        };
                        
                        // Multi-colored star
                        const gradient = ctx.createLinearGradient(-10*s, -5*s, 10*s, 15*s);
                        gradient.addColorStop(0, '#ff0000');
                        gradient.addColorStop(0.2, '#ff7f00');
                        gradient.addColorStop(0.4, '#ffff00');
                        gradient.addColorStop(0.6, '#00ff00');
                        gradient.addColorStop(0.8, '#0000ff');
                        gradient.addColorStop(1, '#8b00ff');
                        ctx.fillStyle = gradient;
                        drawStar(0, 5*s, 5, 10*s, 5*s);
                        ctx.fill();
                        
                        // Tiny red heart in center
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(-2*s, 4*s, 2*s, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(2*s, 4*s, 2*s, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(-2*s, 4*s, 4*s, 3*s);
                        
                        // Eyes
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-10*s, -32*s, 5*s, 5*s);
                        ctx.fillRect(5*s, -32*s, 5*s, 5*s);
                        
                        // Nose
                        ctx.fillRect(-3*s, -22*s, 6*s, 5*s);
                        
                        ctx.restore();
                    };
                    
                    const drawChristmasBear = (x, y, scale) => {
                        const s = scale * scaleFactor;
                        ctx.save();
                        ctx.translate(x, y);
                        
                        // White fur
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-25*s, -20*s, 50*s, 50*s); // Body
                        
                        // Head
                        ctx.fillRect(-20*s, -40*s, 40*s, 25*s);
                        
                        // Ears
                        ctx.fillStyle = '#f0f0f0';
                        ctx.beginPath();
                        ctx.arc(-15*s, -42*s, 8*s, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(15*s, -42*s, 8*s, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Santa hat
                        ctx.fillStyle = '#dc2626';
                        ctx.beginPath();
                        ctx.moveTo(-18*s, -40*s);
                        ctx.lineTo(0, -55*s);
                        ctx.lineTo(18*s, -40*s);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Hat white trim
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-18*s, -42*s, 36*s, 4*s);
                        
                        // Hat pompom
                        ctx.beginPath();
                        ctx.arc(0, -55*s, 4*s, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Belly badge - green tree
                        ctx.fillStyle = '#22c55e';
                        ctx.beginPath();
                        ctx.moveTo(-10*s, 15*s);
                        ctx.lineTo(0, -5*s);
                        ctx.lineTo(10*s, 15*s);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Red heart on tree
                        ctx.fillStyle = '#ef4444';
                        ctx.beginPath();
                        ctx.arc(-2*s, 8*s, 3*s, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(2*s, 8*s, 3*s, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(-2*s, 8*s, 4*s, 4*s);
                        
                        // Eyes
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-10*s, -32*s, 5*s, 5*s);
                        ctx.fillRect(5*s, -32*s, 5*s, 5*s);
                        
                        // Nose
                        ctx.fillRect(-3*s, -22*s, 6*s, 5*s);
                        
                        ctx.restore();
                    };
                    
                    // Draw stacked stuffies
                    s.stackedStuffies.forEach(stuffie => {
                        if (stuffie.type === 'drspot') drawDrSpot(stuffie.x, stuffie.y, 1.5);
                        else if (stuffie.type === 'trueheart') drawTrueHeartBear(stuffie.x, stuffie.y, 1.5);
                        else if (stuffie.type === 'christmas') drawChristmasBear(stuffie.x, stuffie.y, 1.5);
                        else if (stuffie.type === 'james') {
                            ctx.save();
                            ctx.translate(stuffie.x, stuffie.y);
                            ctx.scale(scaleFactor * 1.5, scaleFactor * 1.5);
                            renderCharacterBase(ctx, 'male', player.frame);
                            ctx.restore();
                        }
                        else if (stuffie.type === 'romy') {
                            ctx.save();
                            ctx.translate(stuffie.x, stuffie.y);
                            ctx.scale(scaleFactor * 1.5, scaleFactor * 1.5);
                            renderCharacterBase(ctx, 'female', player.frame);
                            ctx.restore();
                        }
                    });
                    
                    // Draw falling stuffie
                    if (s.fallingStuffie) {
                        const type = s.fallingStuffie.type;
                        if (type === 'drspot') drawDrSpot(s.fallingStuffie.x, s.fallingStuffie.y, 1.5);
                        else if (type === 'trueheart') drawTrueHeartBear(s.fallingStuffie.x, s.fallingStuffie.y, 1.5);
                        else if (type === 'christmas') drawChristmasBear(s.fallingStuffie.x, s.fallingStuffie.y, 1.5);
                        else if (type === 'james') {
                            ctx.save();
                            ctx.translate(s.fallingStuffie.x, s.fallingStuffie.y);
                            ctx.scale(scaleFactor * 1.5, scaleFactor * 1.5);
                            renderCharacterBase(ctx, 'male', player.frame);
                            ctx.restore();
                        }
                        else if (type === 'romy') {
                            ctx.save();
                            ctx.translate(s.fallingStuffie.x, s.fallingStuffie.y);
                            ctx.scale(scaleFactor * 1.5, scaleFactor * 1.5);
                            renderCharacterBase(ctx, 'female', player.frame);
                            ctx.restore();
                        }
                    }
                    
                    // Draw current sliding stuffie (if not dropped yet)
                    if (!s.fallingStuffie && s.currentStuffie < s.stuffieOrder.length) {
                        const type = s.stuffieOrder[s.currentStuffie];
                        const slideY = height * 0.2;
                        
                        if (type === 'drspot') drawDrSpot(s.sliderX, slideY, 1.5);
                        else if (type === 'trueheart') drawTrueHeartBear(s.sliderX, slideY, 1.5);
                        else if (type === 'christmas') drawChristmasBear(s.sliderX, slideY, 1.5);
                        else if (type === 'james') {
                            ctx.save();
                            ctx.translate(s.sliderX, slideY);
                            ctx.scale(scaleFactor * 1.5, scaleFactor * 1.5);
                            renderCharacterBase(ctx, 'male', player.frame);
                            ctx.restore();
                        }
                        else if (type === 'romy') {
                            ctx.save();
                            ctx.translate(s.sliderX, slideY);
                            ctx.scale(scaleFactor * 1.5, scaleFactor * 1.5);
                            renderCharacterBase(ctx, 'female', player.frame);
                            ctx.restore();
                        }
                    }
                    
                    // Instructions / Celebration
                    ctx.fillStyle = '#1f2937';
                    ctx.font = `${12 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    
                    if (s.isCelebrating) {
                        // Celebration text with color pulse
                        const pulse = Math.sin(s.celebrationTimer * 0.2) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(139, 92, 246, ${0.7 + pulse * 0.3})`;
                        ctx.fillText(context.t('EVERYONE_IS_COZY'), width * 0.5, height * 0.15);
                    } else {
                        ctx.fillText(context.t('TAP_TO_DROP'), width * 0.5, height * 0.15);
                    }
                    
                    // Progress
                    ctx.fillStyle = '#1f2937';
                    ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                    ctx.fillText(`STACKED: ${s.stackedStuffies.length} / 5`, width * 0.5, height * 0.92);
                }
            },
            drone_show: {
                update: (context) => {
                    const { player, setGameState, isCelebrating, dimensions } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize drone show state
                    if (!player.droneShow) {
                        // Start Level 19 music
                        if (!player.level19MusicStarted && context.level19MusicRef?.current && !context.isMuted) {
                            context.level19MusicRef.current.play().catch(err => console.log('Audio play prevented:', err));
                            player.level19MusicStarted = true;
                        }
                        
                        const numDrones = 100; // Increased for better detail
                        const drones = [];
                        const centerX = dimensions.width * 0.5;
                        const centerY = dimensions.height * 0.35;
                        
                        // Create drones in center circle
                        for (let i = 0; i < numDrones; i++) {
                            const angle = (i / numDrones) * Math.PI * 2;
                            const radiusLayer = Math.floor(i / 20);
                            const radius = 30 + radiusLayer * 15;
                            drones.push({
                                id: i,
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius,
                                targetX: centerX + Math.cos(angle) * radius,
                                targetY: centerY + Math.sin(angle) * radius,
                                centerX: centerX + Math.cos(angle) * radius,
                                centerY: centerY + Math.sin(angle) * radius,
                                twinkle: Math.random(),
                                color: { r: 255, g: 255, b: 255 } // Start white
                            });
                        }
                        
                        player.droneShow = {
                            drones,
                            currentShape: 0, // Start at index 0 which is 'circle'
                            shapes: ['circle', 'heart', 'circle', 'jr', 'circle', 'maple', 'circle', 'korean', 'circle', 'finalheart'],
                            shapeNames: ['CIRCLE', 'HEART', 'CIRCLE', 'J + R', 'CIRCLE', 'MAPLE LEAF', 'CIRCLE', 'KOREAN FLAG', 'CIRCLE', 'FINAL HEART'],
                            state: 'circle', // 'circle', 'forming', 'displaying', 'returning'
                            displayTimer: 0,
                            canClick: true
                        };
                        
                        // Set initial formation (starts with 'circle' at index 0)
                        this.setDroneFormation(player.droneShow, dimensions);
                    }
                    
                    const d = player.droneShow;
                    
                    // Update drone twinkle and hovering wobble
                    d.drones.forEach((drone, i) => {
                        drone.twinkle += 0.05;
                        
                        // Hovering wobble effect
                        const wobbleX = Math.sin(player.frame * 0.02 + i * 0.5) * 2;
                        const wobbleY = Math.cos(player.frame * 0.03 + i * 0.3) * 2;
                        
                        // Smooth ease-out motion
                        drone.x += (drone.targetX - drone.x + wobbleX) * 0.08;
                        drone.y += (drone.targetY - drone.y + wobbleY) * 0.08;
                    });
                    
                    // State machine
                    if (d.state === 'forming') {
                        // Check if drones reached formation
                        let allReached = true;
                        d.drones.forEach(drone => {
                            const dist = Math.sqrt((drone.x - drone.targetX)**2 + (drone.y - drone.targetY)**2);
                            if (dist > 5) allReached = false;
                        });
                        
                        if (allReached) {
                            d.state = 'displaying';
                            d.canClick = true; // Allow tap to proceed to next
                            
                            // Check if this is the final heart
                            if (d.shapes[d.currentShape] === 'finalheart') {
                                d.canClick = false; // Don't allow clicks on final heart
                                // Wait 3 seconds then complete level
                                setTimeout(() => {
                                    isCelebrating.current = true;
                                    setTimeout(() => {
                                        setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                                    }, 3000);
                                }, 3000);
                            }
                        }
                    } else if (d.state === 'returning') {
                        // Check if drones reached target
                        let allReached = true;
                        d.drones.forEach(drone => {
                            const dist = Math.sqrt((drone.x - drone.targetX)**2 + (drone.y - drone.targetY)**2);
                            if (dist > 5) allReached = false;
                        });
                        
                        if (allReached) {
                            // Ready for next tap
                            d.state = 'circle';
                            d.canClick = true;
                        }
                    }
                    
                    player.frame++;
                },
                
                setDroneFormation: (droneShow, dimensions) => {
                    const shape = droneShow.shapes[droneShow.currentShape];
                    const centerX = dimensions.width * 0.5;
                    const centerY = dimensions.height * 0.35;
                    const s = 12; // Scale factor

                    let points = [];

                    if (shape === 'circle') {
                        // RESTING CIRCLE: All 100 drones in uniform white ring
                        for (let i = 0; i < 100; i++) {
                            const t = (i / 100) * Math.PI * 2;
                            points.push({ 
                                x: Math.cos(t) * 6, 
                                y: Math.sin(t) * 6, 
                                color: { r: 255, g: 255, b: 255 } 
                            });
                        }
                    } else if (shape === 'heart' || shape === 'finalheart') {
                        // HEART (RED): Parametric heart equation with 100 drones
                        for (let i = 0; i < 100; i++) {
                            const t = (i / 100) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                            points.push({ 
                                x: x * 0.7, 
                                y: y * 0.7, 
                                color: { r: 255, g: 0, b: 0 } 
                            });
                        }
                    } else if (shape === 'jr') {
                        // J + R: Simpler, clearer pixel art - 100 drones total
                        
                        // J - 33 drones - Simple J shape with hook at bottom only
                        for (let i = 0; i < 33; i++) {
                            if (i < 4) {
                                // Top horizontal bar
                                points.push({ x: -7 + i, y: -4, color: { r: 255, g: 255, b: 255 } });
                            } else if (i < 16) {
                                // Vertical bar going down (before hook)
                                points.push({ x: -6, y: -3 + (i - 4), color: { r: 255, g: 255, b: 255 } });
                            } else if (i < 20) {
                                // Bottom horizontal part (hook going left at y=4)
                                points.push({ x: -6 - (i - 16), y: 4, color: { r: 255, g: 255, b: 255 } });
                            } else if (i < 23) {
                                // Left vertical part of hook going up
                                points.push({ x: -9, y: 4 - (i - 20), color: { r: 255, g: 255, b: 255 } });
                            } else {
                                // Fill to make it thicker - parallel to main bar
                                const fillIdx = i - 23;
                                if (fillIdx < 10) {
                                    points.push({ x: -5, y: -3 + fillIdx, color: { r: 255, g: 255, b: 255 } });
                                }
                            }
                        }
                        
                        // + sign - 17 drones - Clear plus
                        for (let i = 0; i < 17; i++) {
                            if (i < 9) {
                                // Vertical line
                                points.push({ x: 0, y: -4 + i, color: { r: 255, g: 0, b: 0 } });
                            } else {
                                // Horizontal line
                                points.push({ x: -4 + (i - 9), y: 0, color: { r: 255, g: 0, b: 0 } });
                            }
                        }
                        
                        // R - 50 drones - Simple R shape
                        for (let i = 0; i < 50; i++) {
                            if (i < 12) {
                                // Vertical bar
                                points.push({ x: 5, y: -4 + i, color: { r: 255, g: 150, b: 200 } });
                            } else if (i < 17) {
                                // Top horizontal bar
                                points.push({ x: 5 + (i - 12), y: -4, color: { r: 255, g: 150, b: 200 } });
                            } else if (i < 20) {
                                // Right side of top curve
                                points.push({ x: 9, y: -4 + (i - 17), color: { r: 255, g: 150, b: 200 } });
                            } else if (i < 24) {
                                // Middle horizontal bar
                                points.push({ x: 5 + (i - 20), y: 0, color: { r: 255, g: 150, b: 200 } });
                            } else if (i < 32) {
                                // Diagonal leg
                                const legIdx = i - 24;
                                points.push({ x: 5 + legIdx, y: 0 + legIdx, color: { r: 255, g: 150, b: 200 } });
                            } else {
                                // Fill to make it thicker
                                const fillIdx = i - 32;
                                if (fillIdx < 9) {
                                    points.push({ x: 6, y: -3 + fillIdx, color: { r: 255, g: 150, b: 200 } });
                                } else {
                                    points.push({ x: 6 + (fillIdx - 9), y: 1 + (fillIdx - 9), color: { r: 255, g: 150, b: 200 } });
                                }
                            }
                        }
                    } else if (shape === 'maple') {
                        // MAPLE LEAF (RED): Classic 11-pointed Canadian maple leaf - 100 drones
                        const leafPoints = [];
                        
                        // Top stem
                        leafPoints.push([0, -7], [0, -6]);
                        
                        // Top center point (peak)
                        for (let x = -2; x <= 2; x++) {
                            leafPoints.push([x, -5]);
                        }
                        leafPoints.push([-1, -6], [1, -6], [0, -4]);
                        
                        // Upper left point
                        leafPoints.push([-4, -4], [-5, -3], [-4, -3], [-3, -3]);
                        
                        // Upper right point
                        leafPoints.push([4, -4], [5, -3], [4, -3], [3, -3]);
                        
                        // Left side
                        for (let y = -2; y <= 0; y++) {
                            leafPoints.push([-5, y], [-4, y], [-3, y]);
                        }
                        
                        // Right side
                        for (let y = -2; y <= 0; y++) {
                            leafPoints.push([5, y], [4, y], [3, y]);
                        }
                        
                        // Center wide section
                        for (let x = -2; x <= 2; x++) {
                            leafPoints.push([x, -2], [x, -1], [x, 0]);
                        }
                        
                        // Lower left point
                        leafPoints.push([-4, 1], [-3, 1], [-2, 1], [-3, 2]);
                        
                        // Lower right point
                        leafPoints.push([4, 1], [3, 1], [2, 1], [3, 2]);
                        
                        // Center bottom
                        for (let x = -2; x <= 2; x++) {
                            leafPoints.push([x, 1], [x, 2]);
                        }
                        
                        // Bottom stem
                        leafPoints.push([0, 3], [0, 4], [0, 5], [0, 6]);
                        
                        // Fill to reach 100 drones
                        while (leafPoints.length < 100) {
                            leafPoints.push(
                                [0, -3], [-1, -3], [1, -3],
                                [-1, -4], [1, -4],
                                [0, 1], [-1, 1], [1, 1],
                                [-1, 2], [1, 2],
                                [-2, -3], [2, -3],
                                [-6, -1], [6, -1],
                                [-6, 0], [6, 0],
                                [0, 7]
                            );
                        }
                        
                        leafPoints.slice(0, 100).forEach(p => {
                            points.push({ x: p[0], y: p[1], color: { r: 255, g: 0, b: 0 } });
                        });
                    } else if (shape === 'korean') {
                        // KOREAN FLAG (TAEGEUKGI): 100 drones with S-curve
                        for (let i = 0; i < 100; i++) {
                            const t = (i / 100) * Math.PI * 2;
                            const radius = 4;
                            const x = Math.cos(t) * radius;
                            const y = Math.sin(t) * radius;
                            
                            // S-curve division
                            const curveOffset = Math.sin(t * 2) * 1.5;
                            const isRed = y < curveOffset;
                            
                            points.push({ 
                                x, 
                                y, 
                                color: isRed ? { r: 255, g: 0, b: 0 } : { r: 0, g: 0, b: 255 } 
                            });
                        }
                    }

                    // Update drone targets and ensure color is applied
                    droneShow.drones.forEach((drone, i) => {
                        const p = points[i % points.length];
                        drone.targetX = centerX + (p.x * s);
                        drone.targetY = centerY + (p.y * s);
                        drone.color = p.color || { r: 255, g: 255, b: 255 };
                    });
                },
                
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    const { width, height } = dimensions;
                    
                    const d = player.droneShow || { drones: [], currentShape: 0, state: 'circle', shapeNames: [], canClick: true };
                    
                    // Night sky gradient (dark navy to black)
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                    skyGrad.addColorStop(0, '#0a1929');
                    skyGrad.addColorStop(1, '#000000');
                    ctx.fillStyle = skyGrad;
                    ctx.fillRect(0, 0, width, height);
                    
                    // Stars in background
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 50; i++) {
                        const x = (i * 137.5) % width;
                        const y = (i * 241.3) % (height * 0.6);
                        const size = (i % 3) * 0.5 + 0.5;
                        ctx.fillRect(x, y, size, size);
                    }
                    
                    // Lotte World Tower silhouette in distance
                    ctx.fillStyle = '#1a2332';
                    const towerX = width * 0.75;
                    const towerY = height * 0.4;
                    const towerW = 30 * scaleFactor;
                    const towerH = 250 * scaleFactor;
                    
                    // Tower body (tapered)
                    ctx.beginPath();
                    ctx.moveTo(towerX - towerW/2, towerY + towerH);
                    ctx.lineTo(towerX - towerW/3, towerY);
                    ctx.lineTo(towerX + towerW/3, towerY);
                    ctx.lineTo(towerX + towerW/2, towerY + towerH);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Tower split top
                    ctx.fillRect(towerX - towerW/4, towerY - 20*scaleFactor, towerW/8, 20*scaleFactor);
                    ctx.fillRect(towerX + towerW/8, towerY - 20*scaleFactor, towerW/8, 20*scaleFactor);
                    
                    // Han River
                    ctx.fillStyle = '#0f1c2e';
                    ctx.fillRect(0, height * 0.7, width, height * 0.3);
                    
                    // River reflections (subtle)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, height * 0.7, width, 2);
                    
                    // Ground/riverbank
                    ctx.fillStyle = '#0a1420';
                    ctx.fillRect(0, height * 0.85, width, height * 0.15);
                    
                    // James and Romy watching the show (no blanket)
                    const viewerY = height * 0.85;
                    const centerX = width * 0.5;
                    
                    // James on the left
                    ctx.save();
                    ctx.translate(centerX - 40*scaleFactor, viewerY);
                    ctx.scale(scaleFactor * 1.2, scaleFactor * 1.2);
                    renderCharacterBase(ctx, 'male', player.frame);
                    ctx.restore();
                    
                    // Romy on the right
                    ctx.save();
                    ctx.translate(centerX + 20*scaleFactor, viewerY);
                    ctx.scale(scaleFactor * 1.2, scaleFactor * 1.2);
                    renderCharacterBase(ctx, 'female', player.frame);
                    ctx.restore();
                    
                    // Draw drones (50% smaller)
                    d.drones.forEach((drone, i) => {
                        const twinkleAlpha = 0.7 + Math.sin(drone.twinkle) * 0.3;
                        const droneColor = drone.color || { r: 100, g: 200, b: 255 };
                        
                        // Drone glow (reduced from 15 to 7.5)
                        const glowGrad = ctx.createRadialGradient(drone.x, drone.y, 0, drone.x, drone.y, 7.5*scaleFactor);
                        glowGrad.addColorStop(0, `rgba(${droneColor.r}, ${droneColor.g}, ${droneColor.b}, ${twinkleAlpha})`);
                        glowGrad.addColorStop(1, `rgba(${droneColor.r}, ${droneColor.g}, ${droneColor.b}, 0)`);
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(drone.x, drone.y, 7.5*scaleFactor, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Drone core (reduced from 4 to 2)
                        ctx.fillStyle = `rgba(255, 255, 255, ${twinkleAlpha})`;
                        ctx.beginPath();
                        ctx.arc(drone.x, drone.y, 2*scaleFactor, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // No instructions or progress text - clean night sky
                }
            },
            forever_loop: {
                init: (context) => {
                    const { player, dimensions } = context;
                    player.carpetY = dimensions.height * 0.5;
                    player.backgroundIndex = 0;
                    player.backgroundTimer = 0;
                    player.showButtons = false;
                    player.flyingAway = false;
                    player.flyY = 0;
                    player.showFinal = false;
                    player.noButtonPos = { x: dimensions.width * 0.55, y: dimensions.height * 0.7 };
                    // The sequence of backgrounds to show
                    player.scenes = ['apartment', 'ice_rink', 'church', 'lakeshore', 'stanley_park',
                                     'yonge', 'grouse', 'snowboarding', 'ikea', 'costco',
                                     'toronto_skyline', 'skating', 'christmas', 'home', 'aquarium',
                                     'sushi', 'karaoke', 'vr', 'cozy', 'han_river'];
                },
                update: (context) => {
                    const { player, dimensions, mousePos } = context;
                    
                    // Initialize on first frame
                    if (!player.scenes) {
                        player.carpetY = dimensions.height * 0.5;
                        player.backgroundIndex = 0;
                        player.backgroundTimer = 0;
                        player.showButtons = false;
                        player.flyingAway = false;
                        player.flyY = 0;
                        player.showFinal = false;
                        player.noButtonPos = { x: dimensions.width * 0.55, y: dimensions.height * 0.7 };
                        // 20 scenes now including hospital
                        player.scenes = [
                            'han_river_park',      // 1
                            'yongmasan',           // 2
                            'cheesewick',          // 3
                            'the_genius',          // 4
                            'saipan_airport',      // 5
                            'bali_ride',           // 6
                            'kbbq',                // 7
                            'lets_move_1',         // 8
                            'thanksgiving',        // 9
                            'wanna_get_married',   // 10
                            'mexico',              // 11
                            'long_distance_call',  // 12
                            // Skip 13 (road trip)
                            'smoky_highway',       // 14
                            'banff_encounter',     // 15
                            'hospital',            // NEW - between 15 and 16
                            'lets_move_2',         // 16
                            'noraebang_showdown',  // 17
                            'stuffie_stack',       // 18
                            'han_river_drone_show' // 19
                        ];
                        
                        // Play Level 20 MP3 music when level starts
                        if (!player.level20MusicStarted && context.level20MusicRef?.current && !context.isMuted) {
                            context.level20MusicRef.current.play().catch(err => console.log('Audio play prevented:', err));
                            player.level20MusicStarted = true;
                        }
                    }
                    
                    player.frame = (player.frame || 0) + 1;
                    
                    // Music now loops automatically via MP3, no need for periodic playback
                    
                    // Cycle backgrounds every 2 seconds (120 frames)
                    if (!player.showButtons) {
                        player.backgroundTimer++;
                        if (player.backgroundTimer > 120) {
                            player.backgroundTimer = 0;
                            player.backgroundIndex++;
                            if (player.backgroundIndex >= player.scenes.length) {
                                player.backgroundIndex = player.scenes.length - 1;
                                player.showButtons = true; // Show buttons after last scene
                            }
                        }
                    }

                    // NO Button Prank: Move if mouse gets close
                    if (player.showButtons && !player.flyingAway && mousePos) {
                        const dx = mousePos.x - (player.noButtonPos.x + 50);
                        const dy = mousePos.y - (player.noButtonPos.y + 20);
                        if (Math.sqrt(dx*dx + dy*dy) < 60) {
                            player.noButtonPos.x = Math.random() * (dimensions.width - 150);
                            player.noButtonPos.y = Math.random() * (dimensions.height - 100);
                        }
                    }

                    if (player.flyingAway) {
                        player.flyY -= 8;
                        if (player.flyY < -300) {
                            player.showFinal = true;
                        }
                    }
                },
                draw: (ctx, context) => {
                    const { dimensions, player, scaleFactor, config } = context;
                    const { width, height } = dimensions;
                    
                    // Safety check - ensure scenes exists
                    if (!player.scenes) {
                        player.scenes = [
                            'han_river_park',      // 1
                            'yongmasan',           // 2
                            'cheesewick',          // 3
                            'the_genius',          // 4
                            'saipan_airport',      // 5
                            'bali_ride',           // 6
                            'kbbq',                // 7
                            'lets_move_1',         // 8
                            'thanksgiving',        // 9
                            'wanna_get_married',   // 10
                            'mexico',              // 11
                            'long_distance_call',  // 12
                            'smoky_highway',       // 13 (was 14)
                            'banff_encounter',     // 14 (was 15)
                            'hospital',            // 15 NEW
                            'lets_move_2',         // 16
                            'noraebang_showdown',  // 17
                            'stuffie_stack',       // 18
                            'han_river_drone_show' // 19
                        ];
                        player.backgroundIndex = player.backgroundIndex || 0;
                    }
                    
                    const sceneIndex = player.backgroundIndex || 0;
                    const levelNumber = sceneIndex + 1; // Scene index 0 = Level 1, etc.

                    // Draw actual level background by getting level config
                    const LEVEL_CONFIGS = [
                        { type: 'platformer' }, // 1 - HAN RIVER PARK
                        { type: 'platformer' }, // 2 - YONGMASAN
                        { type: 'catching' }, // 3 - CHEESEWICK
                        { type: 'genius_logic' }, // 4 - THE GENIUS
                        { type: 'wakeup' }, // 5 - SAIPAN AIRPORT
                        { type: 'bike_chase' }, // 6 - BALI RIDE
                        { type: 'soju_ceremony' }, // 7 - KBBQ
                        { type: 'letter_catch' }, // 8 - LET'S MOVE! PART 1
                        { type: 'basting_game' }, // 9 - THANKSGIVING
                        { type: 'city_hall_wedding' }, // 10 - WANNA GET MARRIED?
                        { type: 'mexican_rescue' }, // 11 - MEXICO
                        { type: 'phone_call' }, // 12 - THE LONG DISTANCE CALL
                        // SKIP 13 - road_trip
                        { type: 'bike_chase', isCarLevel: true }, // 14 - THE SMOKY HIGHWAY (distinct from Bali)
                        { type: 'stealth_engine' }, // 15 - THE BANFF ENCOUNTER
                        { type: 'hospital' }, // NEW - hospital scene
                        { type: 'letter_catch', cityscape: 'seoul', targetWord: 'KOREA' }, // 16 - LET'S MOVE! PART 2 with Seoul
                        { type: 'noraebang_logic' }, // 17 - THE NORAEBANG SHOWDOWN
                        { type: 'stuffie_stack' }, // 18 - THE STUFFIE STACK
                        { type: 'drone_show' } // 19 - HAN RIVER DRONE SHOW
                    ];
                    
                    const levelConfig = LEVEL_CONFIGS[levelNumber - 1];
                    
                    // Draw manual backgrounds for levels that need them
                    if (sceneIndex === 0) {
                        // Level 1 - HAN RIVER PARK - Day sky
                        const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                        skyGrad.addColorStop(0, '#87ceeb');
                        skyGrad.addColorStop(1, '#e0f7ff');
                        ctx.fillStyle = skyGrad;
                        ctx.fillRect(0, 0, width, height);
                    } else if (sceneIndex === 1) {
                        // Level 2 - YONGMASAN - Mountain day
                        const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                        skyGrad.addColorStop(0, '#bae6fd');
                        skyGrad.addColorStop(1, '#fef9c3');
                        ctx.fillStyle = skyGrad;
                        ctx.fillRect(0, 0, width, height);
                    } else if (sceneIndex === 14) {
                        // Hospital scene - draw manually (no level engine needed)
                        // White hospital walls
                        ctx.fillStyle = '#f8f9fa';
                        ctx.fillRect(0, 0, width, height);
                        
                        // Floor tiles
                        ctx.fillStyle = '#e9ecef';
                        for (let i = 0; i < width; i += 50 * scaleFactor) {
                            for (let j = height * 0.7; j < height; j += 50 * scaleFactor) {
                                if ((Math.floor(i / (50 * scaleFactor)) + Math.floor(j / (50 * scaleFactor))) % 2 === 0) {
                                    ctx.fillRect(i, j, 50 * scaleFactor, 50 * scaleFactor);
                                }
                            }
                        }
                        
                        // Romy in hospital (center, moved down 40 units)
                        const romyX = width * 0.5;
                        const romyY = height * 0.5 + 40 * scaleFactor;
                        
                        // Draw Romy
                        ctx.save();
                        ctx.translate(romyX, romyY);
                        ctx.scale(scaleFactor * 2, scaleFactor * 2);
                        renderCharacterBase(ctx, 'female', player.frame || 0);
                        ctx.restore();
                        
                        // IV stand (beside Romy at HER actual height, not way below)
                        const ivX = romyX - 100 * scaleFactor; 
                        const ivBaseY = romyY + 180 * scaleFactor; // Much closer to her (was +300)
                        
                        // IV pole
                        ctx.fillStyle = '#6c757d';
                        ctx.fillRect(ivX - 3 * scaleFactor, ivBaseY - 120 * scaleFactor, 6 * scaleFactor, 120 * scaleFactor);
                        
                        // IV bag at top
                        ctx.fillStyle = 'rgba(200, 230, 255, 0.7)';
                        ctx.fillRect(ivX - 15 * scaleFactor, ivBaseY - 120 * scaleFactor, 30 * scaleFactor, 40 * scaleFactor);
                        
                        // IV tube to Romy's left arm
                        // Her body is at romyX, torso area around romyY + 160*scaleFactor
                        const romyArmX = romyX - 40 * scaleFactor;
                        const romyArmY = romyY + 160 * scaleFactor;
                        
                        ctx.strokeStyle = 'rgba(200, 230, 255, 0.6)';
                        ctx.lineWidth = 3 * scaleFactor;
                        ctx.beginPath();
                        ctx.moveTo(ivX, ivBaseY - 80 * scaleFactor); // From IV bag
                        ctx.lineTo((ivX + romyArmX) / 2, romyArmY - 10 * scaleFactor); // Mid-point
                        ctx.lineTo(romyArmX, romyArmY); // To her left arm
                        ctx.stroke();
                        
                        // Wheels at floor
                        ctx.fillStyle = '#495057';
                        for (let i = 0; i < 4; i++) {
                            const angle = (i / 4) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.arc(ivX + Math.cos(angle) * 12 * scaleFactor, 
                                   ivBaseY, 
                                   4 * scaleFactor, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                    } else if (levelConfig && LevelLibrary[levelConfig.type]) {
                        // For other levels with engines, call their draw
                        const levelEngine = LevelLibrary[levelConfig.type];
                        const mockContext = {
                            ...context,
                            config: levelConfig,
                            player: { frame: player.frame || 0, worldX: 0, droneShow: null, x: width * 0.5 },
                            gameState: { levelNumber, character: 'male' },
                            isCelebrating: { current: false },
                            skipCharacter: (sceneIndex === 2 || sceneIndex === 7) // Level 3 and 8 - don't draw Romy
                        };
                        
                        try {
                            ctx.save();
                            levelEngine.draw(ctx, mockContext);
                            ctx.restore();
                        } catch (e) {
                            ctx.fillStyle = '#1e1b4b';
                            ctx.fillRect(0, 0, width, height);
                        }
                    } else {
                        // Fallback for unknown types
                        ctx.fillStyle = '#1e1b4b';
                        ctx.fillRect(0, 0, width, height);
                    }
                    
                    // Add specific gameplay elements for certain levels (runs for ALL scenes)
                    if (sceneIndex === 0) {
                                // Level 1 - HAN RIVER PARK - Draw clear ground and pillow monster
                                // Ground
                                ctx.fillStyle = '#15803d';
                                ctx.fillRect(0, height * 0.75, width, height * 0.25);
                                
                                // Pillow monster - WHITE/GREY (like actual game)
                                const monsterSize = 80 * scaleFactor;
                                const monsterX = width * 0.5;
                                const monsterY = height * 0.75 - monsterSize;
                                
                                // White pillow body
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(monsterX - monsterSize/2, monsterY, monsterSize, monsterSize);
                                
                                // Grey border/shadow
                                ctx.fillStyle = '#6b7280';
                                ctx.fillRect(monsterX - monsterSize/2, monsterY, monsterSize, 5 * scaleFactor); // Top
                                ctx.fillRect(monsterX - monsterSize/2, monsterY + monsterSize - 5 * scaleFactor, monsterSize, 5 * scaleFactor); // Bottom
                                ctx.fillRect(monsterX - monsterSize/2, monsterY, 5 * scaleFactor, monsterSize); // Left
                                ctx.fillRect(monsterX + monsterSize/2 - 5 * scaleFactor, monsterY, 5 * scaleFactor, monsterSize); // Right
                                
                                // Black eyes
                                ctx.fillStyle = '#000000';
                                ctx.fillRect(monsterX - monsterSize/2 + 20 * scaleFactor, monsterY + 25 * scaleFactor, 15 * scaleFactor, 15 * scaleFactor);
                                ctx.fillRect(monsterX - monsterSize/2 + 45 * scaleFactor, monsterY + 25 * scaleFactor, 15 * scaleFactor, 15 * scaleFactor);
                                
                            } else if (sceneIndex === 1) {
                                // Level 2 - YONGMASAN - Draw hill, trees, and febreze
                                // Green mountain/hill
                                ctx.fillStyle = '#15803d';
                                ctx.beginPath();
                                ctx.moveTo(0, height * 0.8);
                                ctx.lineTo(width * 0.3, height * 0.5);
                                ctx.lineTo(width * 0.7, height * 0.6);
                                ctx.lineTo(width, height * 0.75);
                                ctx.lineTo(width, height);
                                ctx.lineTo(0, height);
                                ctx.closePath();
                                ctx.fill();
                                
                                // Trees on the hill
                                const drawTree = (x, y, size) => {
                                    // Trunk
                                    ctx.fillStyle = '#6b4423';
                                    ctx.fillRect(x - 5 * scaleFactor, y, 10 * scaleFactor, 30 * scaleFactor * size);
                                    // Leaves
                                    ctx.fillStyle = '#166534';
                                    ctx.beginPath();
                                    ctx.arc(x, y - 10 * scaleFactor * size, 25 * scaleFactor * size, 0, Math.PI * 2);
                                    ctx.fill();
                                };
                                
                                drawTree(width * 0.25, height * 0.55, 1.2);
                                drawTree(width * 0.35, height * 0.52, 1.0);
                                drawTree(width * 0.5, height * 0.62, 1.1);
                                
                                // Febreze bottle - much bigger at the end
                                const febrezeX = width * 0.8;
                                const febrezeY = height * 0.7;
                                
                                // Bottle body
                                ctx.fillStyle = '#22d3ee';
                                ctx.fillRect(febrezeX - 20 * scaleFactor, febrezeY, 40 * scaleFactor, 70 * scaleFactor);
                                
                                // Cap
                                ctx.fillStyle = '#0891b2';
                                ctx.fillRect(febrezeX - 20 * scaleFactor, febrezeY - 15 * scaleFactor, 40 * scaleFactor, 15 * scaleFactor);
                                
                                // Spray nozzle
                                ctx.fillStyle = '#0e7490';
                                ctx.fillRect(febrezeX - 10 * scaleFactor, febrezeY - 25 * scaleFactor, 20 * scaleFactor, 10 * scaleFactor);
                                
                                // Label "F"
                                ctx.fillStyle = '#ffffff';
                                ctx.font = `${20 * scaleFactor}px "Press Start 2P"`;
                                ctx.textAlign = 'center';
                                ctx.fillText('F', febrezeX, febrezeY + 45 * scaleFactor);
                                
                            } else if (sceneIndex === 2) {
                                // Level 3 - Draw pizza (middle-upper area)
                                ctx.fillStyle = '#fbbf24';
                                ctx.beginPath();
                                ctx.arc(width * 0.5, height * 0.35, 40 * scaleFactor, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.fillStyle = '#dc2626';
                                for (let i = 0; i < 5; i++) {
                                    const angle = (i / 5) * Math.PI * 2;
                                    ctx.beginPath();
                                    ctx.arc(width * 0.5 + Math.cos(angle) * 20 * scaleFactor, 
                                           height * 0.35 + Math.sin(angle) * 20 * scaleFactor, 
                                           8 * scaleFactor, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            } else if (sceneIndex === 18) {
                                // Level 19 - HAN RIVER DRONE SHOW - Draw drones in heart shape
                                const heartCenterX = width * 0.5;
                                const heartCenterY = height * 0.3;
                                const heartSize = 80 * scaleFactor;
                                
                                // Draw 20 drones in heart formation
                                for (let i = 0; i < 20; i++) {
                                    const t = (i / 20) * Math.PI * 2;
                                    // Parametric heart equation
                                    const x = heartCenterX + heartSize * (16 * Math.pow(Math.sin(t), 3));
                                    const y = heartCenterY - heartSize * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
                                    
                                    // Draw drone as pink dot
                                    ctx.fillStyle = '#ff1493';
                                    ctx.beginPath();
                                    ctx.arc(x, y, 4 * scaleFactor, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                    if (player.showFinal) {
                        // Final message
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, width, height);
                        
                        // Heart firework explosion
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2;
                            const dist = 50 + Math.sin(player.frame * 0.1 + i) * 30;
                            const x = width * 0.5 + Math.cos(angle) * dist;
                            const y = height * 0.3 + Math.sin(angle) * dist;
                            ctx.fillStyle = '#ff69b4';
                            ctx.beginPath();
                            ctx.arc(x, y, 5 * scaleFactor, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('THEN PUT THE PHONE DOWN', width * 0.5, height * 0.5);
                        ctx.fillText('AND KEEP PLAYING.', width * 0.5, height * 0.5 + 30 * scaleFactor);
                        
                        ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillStyle = '#ff69b4';
                        ctx.fillText(' THE END ', width * 0.5, height * 0.7);
                        
                        // Main Menu button
                        const buttonWidth = 200 * scaleFactor;
                        const buttonHeight = 50 * scaleFactor;
                        const buttonX = width * 0.5 - buttonWidth / 2;
                        const buttonY = height * 0.85 - buttonHeight / 2;
                        
                        // Store button bounds for click detection
                        if (!player.mainMenuButton) {
                            player.mainMenuButton = { x: buttonX, y: buttonY, w: buttonWidth, h: buttonHeight };
                        }
                        
                        // Button background
                        ctx.fillStyle = '#4a90e2';
                        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
                        
                        // Button border
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3 * scaleFactor;
                        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
                        
                        // Button text
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `${12 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillText('MAIN MENU', width * 0.5, height * 0.85);
                        
                        return;
                    }

                    // 2. Draw Magic Carpet
                    ctx.save();
                    const hover = Math.sin((player.frame || 0) * 0.05) * 15;
                    const carpetX = width * 0.5; // Center horizontally
                    const carpetY = (player.carpetY || height * 0.5) + hover + (player.flyY || 0);
                    
                    // Carpet Body
                    ctx.fillStyle = '#b91c1c';
                    ctx.fillRect(carpetX - 80 * scaleFactor, carpetY - 10 * scaleFactor, 160 * scaleFactor, 20 * scaleFactor);
                    ctx.fillStyle = '#7f1d1d';
                    ctx.fillRect(carpetX - 75 * scaleFactor, carpetY - 8 * scaleFactor, 150 * scaleFactor, 16 * scaleFactor);
                    
                    // Gold tassels
                    ctx.fillStyle = '#fde047';
                    ctx.fillRect(carpetX - 85 * scaleFactor, carpetY + 10 * scaleFactor, 10 * scaleFactor, 10 * scaleFactor);
                    ctx.fillRect(carpetX + 75 * scaleFactor, carpetY + 10 * scaleFactor, 10 * scaleFactor, 10 * scaleFactor);

                    // Draw James and Romy sitting on top of the carpet
                    // Left/right position good, moved up 30 more units (total -130)
                    ctx.translate(carpetX - 75 * scaleFactor, carpetY - 130 * scaleFactor);
                    ctx.scale(scaleFactor * 1.2, scaleFactor * 1.2);
                    renderCharacterBase(ctx, 'male', player.frame || 0);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(carpetX - 25 * scaleFactor, carpetY - 130 * scaleFactor);
                    ctx.scale(scaleFactor * 1.2, scaleFactor * 1.2);
                    renderCharacterBase(ctx, 'female', player.frame || 0);
                    ctx.restore();

                    // 3. UI Buttons
                    if (player.showButtons && !player.flyingAway) {
                        // Dark overlay
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(width/2 - 180, height * 0.55, 360, 150);
                        
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'center';
                        ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillText('DO YOU WANT TO KEEP PLAYING?', width/2, height * 0.6);

                        // Yes Button
                        ctx.fillStyle = '#22c55e';
                        ctx.fillRect(width*0.35, height*0.65, 100, 40);
                        ctx.fillStyle = '#166534';
                        ctx.fillRect(width*0.35 + 2, height*0.65 + 2, 96, 36);
                        ctx.fillStyle = 'white';
                        ctx.font = `${12 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillText('YES', width*0.35 + 50, height*0.65 + 28);

                        // No Button (Teleporting)
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(player.noButtonPos.x, player.noButtonPos.y, 100, 40);
                        ctx.fillStyle = '#991b1b';
                        ctx.fillRect(player.noButtonPos.x + 2, player.noButtonPos.y + 2, 96, 36);
                        ctx.fillStyle = 'white';
                        ctx.fillText('NO', player.noButtonPos.x + 50, player.noButtonPos.y + 28);
                    }

                    // Scene indicator
                    if (!player.showFinal) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(10, height - 40, 200*scaleFactor, 30);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `${8 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'left';
                        ctx.fillText(`SCENE ${player.backgroundIndex + 1}/19`, 20, height - 20);
                    }
                }
            },
            soju_ceremony: {
                update: (context) => {
                    const { player, setGameState, dimensions, scaleFactor } = context;
                    
                    // Logic Loop
                    player.ritualTimer++;
                    
                    // Animation timing: Dad's glass takes 60 frames to reach Romy's head
                    const DAD_GLASS_ANIMATION_DURATION = 60;
                    const CHEERS_WINDOW_START = 300;
                    const DAD_GLASS_REACHES_ROMY = CHEERS_WINDOW_START + DAD_GLASS_ANIMATION_DURATION; // 360
                    const CHEERS_TIMEOUT = DAD_GLASS_REACHES_ROMY + 300; // 5 seconds (300 frames) after glass reaches Romy
                    
                    if (player.ritualState === 'WAITING') {
                        if (player.ritualTimer > CHEERS_WINDOW_START) {
                            player.ritualState = 'CHEERS_WINDOW';
                        }
                    } else if (player.ritualState === 'CHEERS_WINDOW') {
                        // Check timeout: 5 seconds after Dad's glass reaches Romy's head
                        if (player.ritualTimer > CHEERS_TIMEOUT) {
                            setGameState(prev => ({ ...prev, status: GameStatus.GAMEOVER, deathReason: 'YOU NEED TO CHEERS!' }));
                        }
                    } else if (player.ritualState === 'EATING') {
                        const MEAT_ANIMATION_DURATION = 150;
                        const eatingStartTime = player.jamesGlassClickTime || 0;
                        const meatClickTime = player.meatClickTime;
                        
                        // Check if James ate his lettuce
                        if (meatClickTime !== null && meatClickTime !== undefined) {
                            // James ate his lettuce, level complete immediately
                            player.ritualState = 'COMPLETE';
                            const level = context.config;
                            setGameState(s => ({ ...s, ritualMessage: level.completionText || 'YOU MASTERED KBBQ' }));
                            setTimeout(() => {
                                if (level.nextLevelStory) {
                                    setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                                } else {
                                    setGameState(s => ({ ...s, status: GameStatus.LEVEL_COMPLETE }));
                                }
                            }, 2000);
                        } else {
                            // No lettuce clicked yet - check timeout
                            // Timeout: 5 seconds after EATING starts
                            const eatingTimeout = eatingStartTime + 300; // 5 seconds
                            if (player.ritualTimer > eatingTimeout) {
                                setGameState(prev => ({ ...prev, status: GameStatus.GAMEOVER, deathReason: 'YOU NEED TO EAT AFTER DRINKING' }));
                            }
                        }
                    }
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    context.hitZones = drawLevel6(ctx, dimensions.width, dimensions.height, scaleFactor, player.frame, player.ritualState, player.ritualTimer, player);
                }
            },
            letter_catch: {
                update: (context) => {
                    const { player, targetX, entities, dimensions, scaleFactor, setGameState, isCelebrating, config } = context;
                    if (isCelebrating.current) return;

                    const targetWord = config.targetWord || "CANADA";
                    
                    // Play Canada MP3 music for CANADA level (start once, loops automatically)
                    if (targetWord === "CANADA" && !player.canadaMusicStarted && context.canadaMusicRef?.current && !context.isMuted) {
                        context.canadaMusicRef.current.play().catch(err => console.log('Audio play prevented:', err));
                        player.canadaMusicStarted = true;
                    }
                    
                    // Play Korea MP3 music for KOREA level (start once, loops automatically)
                    if (targetWord === "KOREA" && !player.koreaMusicStarted && context.koreaMusicRef?.current && !context.isMuted) {
                        context.koreaMusicRef.current.play().catch(err => console.log('Audio play prevented:', err));
                        player.koreaMusicStarted = true;
                    }

                    // Move player horizontally
                    player.x += (targetX.current - player.x) * 0.15;
                    player.x = Math.max(50 * scaleFactor, Math.min(dimensions.width - 50 * scaleFactor, player.x));
                    
                    // Spawn falling letters
                    if (player.frame % 60 === 0) {
                        const randomLetter = targetWord[Math.floor(Math.random() * targetWord.length)];
                        entities.current.push({
                            id: Date.now() + Math.random(),
                            letter: randomLetter,
                            x: Math.random() * (dimensions.width - 100) + 50,
                            y: -60,
                            speed: (3 + Math.random() * 2) * scaleFactor
                        });
                    }

                    // Update falling letters and check collisions
                    entities.current = entities.current.filter(letter => {
                        letter.y += letter.speed;

                        // Check collision with player (raised higher for mobile thumb clearance)
                        const playerX = player.x;
                        const playerY = dimensions.height - 280 * scaleFactor; // Raised from 200 to 280
                        const letterSize = 40 * scaleFactor;
                        const playerWidth = 80 * config.charScale * scaleFactor;

                        if (letter.y + letterSize > playerY && 
                            letter.y < playerY + 100 * scaleFactor &&
                            letter.x + letterSize > playerX - playerWidth/2 &&
                            letter.x < playerX + playerWidth/2) {
                            
                            // Check if this is the next letter we need
                            const currentProgress = player.collectedWord || "";
                            const nextNeededLetter = targetWord[currentProgress.length];
                            
                            if (letter.letter === nextNeededLetter) {
                                player.collectedWord = currentProgress + letter.letter;
                                
                                // Check if word is complete
                                if (player.collectedWord === targetWord) {
                                    isCelebrating.current = true;
                                    setTimeout(() => {
                                        const level = config;
                                        if (level.nextLevelStory) {
                                            setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                                        } else {
                                            setGameState(s => ({ ...s, status: GameStatus.LEVEL_COMPLETE }));
                                        }
                                    }, 3000);
                                }
                            }
                            return false; // Remove the letter
                        }

                        // Remove if off screen
                        return letter.y < dimensions.height + 100;
                    });
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player, entities, gameState, config, PLAYER_SIZE, isCelebrating } = context;
                    const { width, height } = dimensions;

                    // Canada-themed background with detailed Toronto or Seoul skyline
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    if (config.cityscape === 'seoul') {
                        // Seoul sky - similar but slightly different
                        gradient.addColorStop(0, '#5B9BD5'); // Korean sky blue
                        gradient.addColorStop(0.5, '#87CEEB');
                        gradient.addColorStop(0.8, '#B0E0E6');
                        gradient.addColorStop(1, '#E6F3FF');
                    } else {
                        // Toronto sky
                        gradient.addColorStop(0, '#4A90E2'); // Deeper sky blue
                        gradient.addColorStop(0.5, '#87CEEB'); // Sky blue
                        gradient.addColorStop(0.8, '#B0E0E6'); // Powder blue
                        gradient.addColorStop(1, '#E6F3FF'); // Very light blue
                    }
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);

                    // Draw animated clouds
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    const cloudOffset = (player.frame * 0.2) % (width + 200);
                    for (let i = 0; i < 4; i++) {
                        const cloudX = (width / 4) * i - cloudOffset + 100;
                        const cloudY = 60 * scaleFactor + i * 30 * scaleFactor;
                        // Cloud shape with multiple circles
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, 20 * scaleFactor, 0, Math.PI * 2);
                        ctx.arc(cloudX + 25 * scaleFactor, cloudY, 25 * scaleFactor, 0, Math.PI * 2);
                        ctx.arc(cloudX + 50 * scaleFactor, cloudY, 20 * scaleFactor, 0, Math.PI * 2);
                        ctx.arc(cloudX + 35 * scaleFactor, cloudY - 15 * scaleFactor, 22 * scaleFactor, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Draw Seoul or Toronto skyline
                    if (config.cityscape === 'seoul') {
                        const drawSeoulSkyline = () => {
                            const s = scaleFactor;
                            const skylineY = height * 0.5;
                            
                            // N Seoul Tower (iconic) - on mountain
                            const towerX = width * 0.3;
                            // Mountain base
                            ctx.fillStyle = '#4a7c59';
                            ctx.beginPath();
                            ctx.moveTo(width * 0.15, skylineY);
                            ctx.lineTo(towerX, skylineY - 80*s);
                            ctx.lineTo(width * 0.45, skylineY);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Tower structure
                            ctx.fillStyle = '#95a5a6';
                            ctx.fillRect(towerX - 2*s, skylineY - 180*s, 4*s, 100*s);
                            // Tower top (observation deck)
                            ctx.fillStyle = '#e74c3c';
                            ctx.beginPath();
                            ctx.arc(towerX, skylineY - 180*s, 12*s, 0, Math.PI * 2);
                            ctx.fill();
                            // Antenna
                            ctx.fillStyle = '#7f8c8d';
                            ctx.fillRect(towerX - 1*s, skylineY - 200*s, 2*s, 20*s);
                            
                            // Lotte World Tower (tall modern)
                            ctx.fillStyle = '#34495e';
                            ctx.fillRect(width * 0.5, skylineY - 150*s, 45*s, 150*s);
                            // Glass effect
                            ctx.fillStyle = 'rgba(135, 206, 250, 0.3)';
                            ctx.fillRect(width * 0.5 + 5*s, skylineY - 145*s, 35*s, 140*s);
                            // Windows
                            ctx.fillStyle = '#FDB813';
                            for(let row = 0; row < 14; row++) {
                                for(let col = 0; col < 3; col++) {
                                    ctx.fillRect(width * 0.5 + (8 + col*12)*s, skylineY - (140 - row*10)*s, 6*s, 6*s);
                                }
                            }
                            
                            // Modern buildings
                            ctx.fillStyle = '#2c3e50';
                            ctx.fillRect(width * 0.65, skylineY - 100*s, 50*s, 100*s);
                            ctx.fillRect(width * 0.75, skylineY - 85*s, 40*s, 85*s);
                            
                            // Windows for modern buildings
                            ctx.fillStyle = '#3498db';
                            for(let row = 0; row < 8; row++) {
                                for(let col = 0; col < 3; col++) {
                                    ctx.fillRect(width * 0.65 + (10 + col*14)*s, skylineY - (90 - row*11)*s, 8*s, 7*s);
                                }
                            }
                            
                            // Traditional Korean building (hanok style)
                            ctx.fillStyle = '#8b4513';
                            ctx.fillRect(width * 0.1, skylineY - 60*s, 45*s, 50*s);
                            // Curved roof
                            ctx.fillStyle = '#cd853f';
                            ctx.beginPath();
                            ctx.moveTo(width * 0.1 - 5*s, skylineY - 60*s);
                            ctx.quadraticCurveTo(width * 0.1 + 22.5*s, skylineY - 75*s, width * 0.1 + 50*s, skylineY - 60*s);
                            ctx.fill();
                            
                            // Ground/grass
                            ctx.fillStyle = '#27ae60';
                            ctx.fillRect(0, skylineY, width, height - skylineY);
                        };
                        
                        drawSeoulSkyline();
                    } else {
                        // Draw Toronto skyline with more detail
                        const drawTorontoSkyline = () => {
                        const s = scaleFactor;
                        const skylineY = height * 0.5;
                        
                        // Background buildings (far)
                        ctx.fillStyle = '#526D82';
                        ctx.fillRect(width * 0.05, skylineY - 60*s, 35*s, 60*s);
                        ctx.fillRect(width * 0.85, skylineY - 55*s, 40*s, 55*s);
                        
                        // Building 1 (left) - with more windows
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(width * 0.1, skylineY - 90*s, 50*s, 90*s);
                        ctx.fillStyle = '#FDB813'; // Yellow windows
                        for(let row = 0; row < 8; row++) {
                            for(let col = 0; col < 3; col++) {
                                ctx.fillRect(width * 0.1 + (8 + col*15)*s, skylineY - (80 - row*10)*s, 8*s, 6*s);
                            }
                        }
                        
                        // Building 2 (tall) - with antenna
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(width * 0.2, skylineY - 140*s, 55*s, 140*s);
                        // Antenna
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillRect(width * 0.2 + 25*s, skylineY - 150*s, 3*s, 10*s);
                        ctx.fillRect(width * 0.2 + 23*s, skylineY - 150*s, 7*s, 3*s);
                        // Windows
                        ctx.fillStyle = '#FDB813';
                        for(let row = 0; row < 12; row++) {
                            for(let col = 0; col < 3; col++) {
                                ctx.fillRect(width * 0.2 + (10 + col*15)*s, skylineY - (130 - row*11)*s, 8*s, 7*s);
                            }
                        }
                        
                        // CN Tower (iconic) - with more detail
                        const cnTowerX = width * 0.35;
                        ctx.fillStyle = '#7f8c8d';
                        // Needle
                        ctx.fillRect(cnTowerX - 3*s, skylineY - 220*s, 6*s, 220*s);
                        // Top sphere
                        ctx.fillStyle = '#c0392b';
                        ctx.beginPath();
                        ctx.arc(cnTowerX, skylineY - 218*s, 8*s, 0, Math.PI * 2);
                        ctx.fill();
                        // Observation pod
                        ctx.fillStyle = '#95a5a6';
                        ctx.fillRect(cnTowerX - 18*s, skylineY - 125*s, 36*s, 25*s);
                        ctx.fillStyle = '#34495e';
                        for(let i = 0; i < 6; i++) {
                            ctx.fillRect(cnTowerX - 15*s + i*5*s, skylineY - 120*s, 3*s, 15*s);
                        }
                        // Base shaft
                        ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(cnTowerX - 12*s, skylineY - 100*s, 24*s, 100*s);
                        
                        // Building 3 (medium right of CN Tower)
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(width * 0.5, skylineY - 105*s, 48*s, 105*s);
                        ctx.fillStyle = '#FDB813';
                        for(let row = 0; row < 9; row++) {
                            for(let col = 0; col < 3; col++) {
                                ctx.fillRect(width * 0.5 + (8 + col*14)*s, skylineY - (95 - row*11)*s, 8*s, 7*s);
                            }
                        }
                        
                        // Building 4 (right side) - modern glass building
                        ctx.fillStyle = '#34495e';
                        ctx.fillRect(width * 0.65, skylineY - 120*s, 60*s, 120*s);
                        ctx.fillStyle = '#5DADE2'; // Blue tinted windows
                        for(let row = 0; row < 10; row++) {
                            for(let col = 0; col < 4; col++) {
                                ctx.fillRect(width * 0.65 + (5 + col*13)*s, skylineY - (110 - row*11)*s, 10*s, 8*s);
                            }
                        }
                        
                        // Building 5 (shorter right)
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(width * 0.78, skylineY - 75*s, 45*s, 75*s);
                        ctx.fillStyle = '#FDB813';
                        for(let row = 0; row < 6; row++) {
                            ctx.fillRect(width * 0.78 + 10*s, skylineY - (65 - row*11)*s, 10*s, 7*s);
                            ctx.fillRect(width * 0.78 + 25*s, skylineY - (65 - row*11)*s, 10*s, 7*s);
                        }
                        
                        // Building 6 (far right)
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(width * 0.88, skylineY - 95*s, 50*s, 95*s);
                        ctx.fillStyle = '#FDB813';
                        for(let row = 0; row < 8; row++) {
                            ctx.fillRect(width * 0.88 + 12*s, skylineY - (85 - row*11)*s, 8*s, 7*s);
                            ctx.fillRect(width * 0.88 + 28*s, skylineY - (85 - row*11)*s, 8*s, 7*s);
                        }
                    };
                        
                        drawTorontoSkyline();
                    }

                    // Draw flag (Canadian for Toronto, Korean for Seoul)
                    if (config.cityscape === 'seoul') {
                        // Korean flag (Taegukgi)
                        const flagX = width * 0.08;
                        const flagY = height * 0.15;
                        const flagW = 60 * scaleFactor;
                        const flagH = 40 * scaleFactor;
                        const wave = Math.sin(player.frame * 0.1) * 3 * scaleFactor;
                        
                        // White background
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(flagX, flagY, flagW, flagH);
                        
                        // Taeguk (red and blue circle)
                        const centerX = flagX + flagW / 2;
                        const centerY = flagY + flagH / 2;
                        const radius = 12 * scaleFactor;
                        
                        // Red (top)
                        ctx.fillStyle = '#CD2E3A';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, Math.PI, 0, false);
                        ctx.fill();
                        
                        // Blue (bottom)
                        ctx.fillStyle = '#0047A0';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, Math.PI, false);
                        ctx.fill();
                        
                        // Small circles
                        ctx.fillStyle = '#CD2E3A';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY - radius/2, radius/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#0047A0';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY + radius/2, radius/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Trigrams (simplified black bars in corners)
                        ctx.fillStyle = '#000000';
                        const barW = 2 * scaleFactor;
                        const barH = 8 * scaleFactor;
                        const barSpacing = 3 * scaleFactor;
                        
                        // Top-left trigram
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(flagX + 5*scaleFactor, flagY + 5*scaleFactor + i*barSpacing, barW, barH);
                        }
                        
                        // Flag border
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(flagX, flagY, flagW, flagH);
                    } else {
                    // Draw Canadian flag waving
                    const flagX = width * 0.08;
                    const flagY = height * 0.15;
                    const flagW = 60 * scaleFactor;
                    const flagH = 40 * scaleFactor;
                    
                    // Flag pole
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(flagX - 3*scaleFactor, flagY, 3*scaleFactor, 100*scaleFactor);
                    
                    // Flag (red-white-red with simple wave effect)
                    const wave = Math.sin(player.frame * 0.1) * 3 * scaleFactor;
                    
                    // Left red stripe
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(flagX, flagY + wave, flagW * 0.25, flagH);
                    
                    // White center with maple leaf
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(flagX + flagW * 0.25, flagY, flagW * 0.5, flagH);
                    
                    // Simple maple leaf on flag
                    ctx.fillStyle = '#FF0000';
                    const leafX = flagX + flagW * 0.5;
                    const leafY = flagY + flagH * 0.5;
                    const leafSize = 2 * scaleFactor;
                    // Simplified maple leaf shape
                    ctx.fillRect(leafX - leafSize, leafY - 4*leafSize, leafSize*2, leafSize*2);
                    ctx.fillRect(leafX - 3*leafSize, leafY - leafSize, leafSize*6, leafSize*2);
                    ctx.fillRect(leafX - leafSize, leafY + leafSize, leafSize*2, leafSize*3);
                    
                    // Right red stripe
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(flagX + flagW * 0.75, flagY - wave, flagW * 0.25, flagH);
                    } // End of flag rendering (Canadian or Korean)

                    // Draw boxes for target word - MUCH LOWER for mobile visibility
                    const targetWord = config.targetWord || "CANADA";
                    const boxSize = 50 * scaleFactor;
                    const boxSpacing = 10 * scaleFactor;
                    const totalWidth = (boxSize * targetWord.length) + (boxSpacing * (targetWord.length - 1));
                    const startX = (width - totalWidth) / 2;
                    const boxY = 120 * scaleFactor; // Moved down from 80 to 120 for better mobile visibility

                    const collectedWord = player.collectedWord || "";
                    
                    for (let i = 0; i < targetWord.length; i++) {
                        const x = startX + i * (boxSize + boxSpacing);
                        
                        // Draw box background
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.fillRect(x, boxY, boxSize, boxSize);
                        
                        // Draw box border
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, boxY, boxSize, boxSize);
                        
                        // Draw collected letters
                        if (i < collectedWord.length) {
                            ctx.fillStyle = '#000';
                            ctx.font = `bold ${30 * scaleFactor}px "Press Start 2P"`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(collectedWord[i], x + boxSize/2, boxY + boxSize/2);
                        }
                    }

                    // Draw falling letters
                    entities.current.forEach(letter => {
                        const letterSize = 40 * scaleFactor;
                        ctx.fillStyle = '#dc2626';
                        ctx.fillRect(letter.x, letter.y, letterSize, letterSize);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(letter.x, letter.y, letterSize, letterSize);
                        
                        ctx.fillStyle = '#fff';
                        ctx.font = `bold ${24 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(letter.letter, letter.x + letterSize/2, letter.y + letterSize/2);
                    });

                    // Draw ground
                    ctx.fillStyle = '#8B9A8E';
                    ctx.fillRect(0, height - 120 * scaleFactor, width, 120 * scaleFactor);

                    // Draw Romy character higher up (similar to level 3 catching position)
                    if (!context.skipCharacter) {
                        const playerY = height - 280 * scaleFactor; // Raised from 200 to 280 for mobile thumb clearance
                        drawAvatar(ctx, player.x, playerY, gameState.character, player.frame, false, config.charScale, false, PLAYER_SIZE, isCelebrating.current);
                    }
                }
            },
            basting_game: {
                update: (context) => {
                    const { player, setGameState, isCelebrating, config } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize basting state
                    if (!player.bastingState) {
                        player.bastingState = {
                            sliderPosition: 0.5, // 0 to 1
                            sliderDirection: 1, // 1 = moving up, -1 = moving down
                            sliderSpeed: 0.01,
                            successfulBastes: 0,
                            showFeedback: false,
                            feedbackTimer: 0,
                            feedbackText: '',
                            greenZoneSize: 0.2, // Starts at 20%
                            isRestarting: false,
                            canClick: true, // Prevents multiple clicks
                            clickCooldown: 0
                        };
                    }
                    
                    const state = player.bastingState;
                    
                    // Don't move slider during restart delay
                    if (state.isRestarting) {
                        state.feedbackTimer++;
                        if (state.feedbackTimer > 90) { // 1.5 second delay
                            // Reset everything
                            state.successfulBastes = 0;
                            state.greenZoneSize = 0.2;
                            state.sliderPosition = 0.5;
                            state.sliderDirection = 1;
                            state.showFeedback = false;
                            state.isRestarting = false;
                            state.feedbackTimer = 0;
                            state.canClick = true;
                            state.clickCooldown = 0;
                        }
                        return;
                    }
                    
                    // Move slider up and down continuously
                    state.sliderPosition += state.sliderSpeed * state.sliderDirection;
                    
                    // Bounce at top and bottom
                    if (state.sliderPosition >= 1) {
                        state.sliderPosition = 1;
                        state.sliderDirection = -1;
                    } else if (state.sliderPosition <= 0) {
                        state.sliderPosition = 0;
                        state.sliderDirection = 1;
                    }
                    
                    // Handle click cooldown
                    if (!state.canClick) {
                        state.clickCooldown++;
                        if (state.clickCooldown > 30) { // 0.5 second cooldown
                            state.canClick = true;
                            state.clickCooldown = 0;
                        }
                    }
                    
                    // Update feedback timer
                    if (state.showFeedback && !state.isRestarting) {
                        state.feedbackTimer++;
                        if (state.feedbackTimer > 60) { // Show for 1 second
                            state.showFeedback = false;
                            state.feedbackTimer = 0;
                        }
                    }
                    
                    // Check for completion
                    const bastesRequired = config.bastesRequired || 5;
                    if (state.successfulBastes >= bastesRequired) {
                        isCelebrating.current = true;
                        setTimeout(() => {
                            const level = config;
                            if (level.nextLevelStory) {
                                setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                            } else {
                                setGameState(s => ({ ...s, status: GameStatus.LEVEL_COMPLETE }));
                            }
                        }, 2000);
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player, gameState, config, PLAYER_SIZE, isCelebrating } = context;
                    const { width, height } = dimensions;
                    
                    // Thanksgiving kitchen background
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, '#fef3c7');
                    gradient.addColorStop(1, '#fcd34d');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                    
                    // Blonde girl child running around in background/foreground
                    // Initialize child position if not exists
                    if (!player.childState) {
                        player.childState = {
                            x: width * 0.2,
                            direction: 1,
                            depth: 0, // 0 = background, 1 = foreground
                            switchingDepth: false
                        };
                    }
                    
                    const child = player.childState;
                    
                    // Move child left to right
                    child.x += 3 * scaleFactor * child.direction;
                    
                    // Check if reached edge
                    if (child.direction === 1 && child.x > width + 100) {
                        // Reached right edge, switch depth and reverse
                        child.direction = -1;
                        child.depth = child.depth === 0 ? 1 : 0; // Toggle depth
                        child.x = width + 80;
                    } else if (child.direction === -1 && child.x < -100) {
                        // Reached left edge, switch depth and reverse
                        child.direction = 1;
                        child.depth = child.depth === 0 ? 1 : 0; // Toggle depth
                        child.x = -80;
                    }
                    
                    // Calculate Y position and scale based on depth
                    let childY, childScale;
                    if (child.depth === 0) {
                        // Background - higher up, smaller
                        childY = height * 0.4;
                        childScale = scaleFactor * 0.6;
                    } else {
                        // Foreground - lower, bigger
                        childY = height * 0.55;
                        childScale = scaleFactor * 1.0;
                    }
                    
                    const drawChild = () => {
                        ctx.save();
                        ctx.translate(child.x, childY);
                        if (child.direction === -1) {
                            ctx.scale(-1 * childScale, childScale); // Flip when going left
                        } else {
                            ctx.scale(childScale, childScale);
                        }
                        
                        // Blonde hair (long)
                        ctx.fillStyle = '#ffd700'; // Golden blonde
                        ctx.fillRect(24, 16, 52, 8);
                        ctx.fillRect(18, 24, 64, 38);
                        
                        // Face
                        ctx.fillStyle = '#ffd6cc';
                        ctx.fillRect(30, 28, 40, 38);
                        
                        // Eyes
                        ctx.fillStyle = '#000';
                        ctx.fillRect(38, 44, 6, 6);
                        ctx.fillRect(56, 44, 6, 6);
                        
                        // Smile
                        ctx.fillRect(44, 54, 12, 4);
                        
                        // Pink dress
                        ctx.fillStyle = '#ff69b4';
                        ctx.fillRect(24, 66, 52, 30);
                        
                        // Arms (running motion)
                        const armSwing = Math.sin(player.frame * 0.3) * 8;
                        ctx.fillRect(18, 72 + armSwing, 12, 24);
                        ctx.fillRect(70, 72 - armSwing, 12, 24);
                        
                        // Legs (running motion)
                        const legSwing = Math.sin(player.frame * 0.3) * 10;
                        ctx.fillRect(32, 96, 12, 28 + legSwing);
                        ctx.fillRect(56, 96, 12, 28 - legSwing);
                        
                        // Shoes
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(28, 124 + legSwing, 18, 8);
                        ctx.fillRect(54, 124 - legSwing, 18, 8);
                        
                        ctx.restore();
                    };
                    
                    // Draw child in background (before counter)
                    if (child.depth === 0) {
                        drawChild();
                    }
                    
                    // Draw kitchen counter
                    ctx.fillStyle = '#92400e';
                    ctx.fillRect(0, height * 0.6, width, height * 0.4);
                    
                    // Draw detailed turkey on counter (center)
                    const turkeyX = width * 0.5;
                    const turkeyY = height * 0.48;
                    
                    // Use the drawTurkey function
                    ctx.save();
                    const turkeyScale = 3 * scaleFactor;
                    drawTurkey(ctx, turkeyX, turkeyY, turkeyScale);
                    ctx.restore();
                    
                    const state = player.bastingState || { sliderPosition: 0.5, successfulBastes: 0, showFeedback: false, feedbackText: '', greenZoneSize: 0.2, isRestarting: false };
                    
                    // Draw Juiciness Meter on the right side
                    const meterX = width - 80 * scaleFactor;
                    const meterY = height * 0.2;
                    const meterWidth = 40 * scaleFactor;
                    const meterHeight = height * 0.5;
                    
                    // Meter background
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
                    
                    // Dynamic green zone (gets smaller with each success)
                    const greenZoneHeight = meterHeight * state.greenZoneSize;
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(meterX, meterY, meterWidth, greenZoneHeight);
                    
                    // Yellow zone (middle)
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(meterX, meterY + greenZoneHeight, meterWidth, meterHeight - greenZoneHeight - meterHeight * 0.2);
                    
                    // Red zone (bottom 20%)
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(meterX, meterY + meterHeight * 0.8, meterWidth, meterHeight * 0.2);
                    
                    // Slider (moves from bottom to top, 0 = bottom, 1 = top)
                    const sliderY = meterY + meterHeight - (state.sliderPosition * meterHeight);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(meterX - 5 * scaleFactor, sliderY - 3 * scaleFactor, meterWidth + 10 * scaleFactor, 6 * scaleFactor);
                    
                    // Meter label
                    ctx.fillStyle = '#000000';
                    ctx.font = `${8 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.fillText('JUICY', meterX + meterWidth / 2, meterY - 10 * scaleFactor);
                    
                    // Draw turkey baster HORIZONTAL on Romy's (left) side
                    const basterX = turkeyX - 160 * scaleFactor; // Moved further left (was -120)
                    const basterY = turkeyY - 20 * scaleFactor; // Level with turkey
                    
                    // Check if we should squeeze (only during successful baste feedback)
                    const isSqueezed = state.showFeedback && state.feedbackText === 'PERFECT!' && state.feedbackTimer < 20;
                    const squeezeAmount = isSqueezed ? 0.6 : 1.0;
                    
                    // Baster bulb (red, squeezes when clicking correctly) - HORIZONTAL
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.ellipse(basterX, basterY, 35 * scaleFactor, 25 * scaleFactor * squeezeAmount, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Baster tube (grey) - HORIZONTAL pointing right toward turkey
                    ctx.fillStyle = '#95a5a6';
                    ctx.fillRect(basterX + 30 * scaleFactor, basterY - 7 * scaleFactor, 90 * scaleFactor, 14 * scaleFactor);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(basterX + 30 * scaleFactor, basterY - 7 * scaleFactor, 90 * scaleFactor, 14 * scaleFactor);
                    
                    // Baster tip (dark grey) - points right at turkey
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(basterX + 120 * scaleFactor, basterY - 5 * scaleFactor, 15 * scaleFactor, 10 * scaleFactor);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(basterX + 120 * scaleFactor, basterY - 5 * scaleFactor, 15 * scaleFactor, 10 * scaleFactor);
                    
                    // Liquid drops coming out (only when squeezed) - shoots toward turkey
                    if (isSqueezed && state.feedbackTimer < 15) {
                        ctx.fillStyle = '#cd7f32'; // Brown gravy color
                        for (let i = 0; i < 5; i++) {
                            const dropX = basterX + 135 * scaleFactor + i * 12 * scaleFactor + state.feedbackTimer * 4 * scaleFactor;
                            ctx.beginPath();
                            ctx.arc(dropX, basterY, 4 * scaleFactor, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // Draw feedback text
                    if (state.showFeedback) {
                        ctx.fillStyle = state.feedbackText === 'PERFECT!' ? '#22c55e' : '#ef4444';
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText(state.feedbackText, width / 2, height * 0.25);
                    }
                    
                    // Check if level is complete for cheering animation
                    const isLevelComplete = state.successfulBastes >= (config.bastesRequired || 5);
                    
                    // Draw Romy character closer to turkey (left side) - 200px tall (doubled)
                    const romyX = width * 0.32;
                    const romyY = height * 0.60; // Moved up from 0.72 to 0.60
                    const charScale = 2.0; // Doubled from 1.0 to 2.0 for 200px tall characters
                    ctx.save();
                    ctx.translate(romyX, romyY);
                    ctx.scale(charScale * scaleFactor, charScale * scaleFactor);
                    // Draw Romy using renderCharacterBase directly
                    ctx.save();
                    ctx.translate(0, 0);
                    // Cheering animation - raise arms
                    if (isLevelComplete) {
                        const cheerBounce = Math.sin(player.frame * 0.2) * 5;
                        ctx.translate(0, cheerBounce);
                    }
                    ctx.scale(1.0, 1.0); // 100px base - no scaling needed
                    ctx.translate(-50, 0); // Center the character
                    renderCharacterBase(ctx, 'female', player.frame, false);
                    // Draw raised arms for cheering
                    if (isLevelComplete) {
                        ctx.fillStyle = '#334155';
                        // Left arm up
                        ctx.fillRect(20, 50, 8, 20);
                        ctx.fillRect(18, 45, 10, 8);
                        // Right arm up
                        ctx.fillRect(72, 50, 8, 20);
                        ctx.fillRect(72, 45, 10, 8);
                    }
                    ctx.restore();
                    ctx.restore();
                    
                    // Draw Mom character closer to turkey (right side, before meter) - 100px tall
                    const momX = width * 0.62;
                    const momY = height * 0.60; // Moved up from 0.72 to 0.60
                    ctx.save();
                    ctx.translate(momX, momY);
                    ctx.scale(charScale * scaleFactor, charScale * scaleFactor);
                    // Draw Mom using same method as Romy (she's now 100px base too)
                    ctx.save();
                    ctx.translate(0, 0);
                    // Cheering animation - raise arms
                    if (isLevelComplete) {
                        const cheerBounce = Math.sin(player.frame * 0.2 + Math.PI) * 5;
                        ctx.translate(0, cheerBounce);
                    }
                    ctx.scale(1.0, 1.0); // 100px base - same as Romy
                    ctx.translate(-50, 0); // Center the character
                    drawMom(ctx, 0, 0, 1);
                    // Draw raised arms for cheering
                    if (isLevelComplete) {
                        ctx.fillStyle = '#fb7185';
                        // Left arm up
                        ctx.fillRect(20, 50, 8, 20);
                        ctx.fillRect(18, 45, 10, 8);
                        // Right arm up
                        ctx.fillRect(72, 50, 8, 20);
                        ctx.fillRect(72, 45, 10, 8);
                    }
                    ctx.restore();
                    ctx.restore();
                    
                    // Draw instruction text
                    if (state.successfulBastes < (config.bastesRequired || 5)) {
                        ctx.fillStyle = '#000000';
                        ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('TAP WHEN IN GREEN!', width / 2, height - 30 * scaleFactor);
                    }
                    
                    // Draw child in foreground (after everything else)
                    if (child.depth === 1) {
                        drawChild();
                    }
                }
            },
            city_hall_wedding: {
                update: (context) => {
                    const { player, setGameState, isCelebrating, config } = context;
                    
                    if (isCelebrating.current) {
                        // Update kiss animation
                        if (player.weddingState && player.weddingState.kissing) {
                            player.weddingState.kissTimer++;
                            // Add fireworks
                            if (!player.weddingState.fireworks) {
                                player.weddingState.fireworks = [];
                            }
                            if (player.weddingState.kissTimer % 30 === 0) {
                                player.weddingState.fireworks.push({
                                    x: Math.random(),
                                    y: Math.random() * 0.5,
                                    life: 60,
                                    color: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'][Math.floor(Math.random() * 5)]
                                });
                            }
                            // Update existing fireworks
                            player.weddingState.fireworks = player.weddingState.fireworks.filter(f => {
                                f.life--;
                                return f.life > 0;
                            });
                        }
                        return;
                    }
                    
                    // Initialize wedding state
                    if (!player.weddingState) {
                        player.weddingState = {
                            step: 0, // 0=YES/NO, 1=James name, 2=Romy name, 3=complete
                            textPosition: 0.5,
                            textDirection: 1,
                            textSpeed: 0.010,
                            showFeedback: false,
                            feedbackTimer: 0,
                            feedbackText: '',
                            canClick: true,
                            clickCooldown: 0,
                            kissing: false,
                            kissTimer: 0,
                            charMoveProgress: 0,
                            fireworks: [],
                            transitionDelay: false,
                            transitionTimer: 0
                        };
                    }
                    
                    const state = player.weddingState;
                    
                    // Handle 4-second delay after Korean name is placed
                    if (state.transitionDelay) {
                        state.transitionTimer++;
                        if (state.transitionTimer >= 240) { // 4 seconds at 60fps
                            state.transitionDelay = false;
                            state.transitionTimer = 0;
                            state.step = 3; // Move to final step with outdoor background
                            state.charMoveProgress = 0;
                        }
                        return;
                    }
                    
                    if (state.showFeedback) {
                        state.feedbackTimer++;
                        if (state.feedbackTimer > 60) {
                            state.showFeedback = false;
                            state.feedbackTimer = 0;
                        }
                        return;
                    }
                    
                    // Move characters together when complete
                    if (state.step === 3 && !state.kissing) {
                        state.charMoveProgress += 0.01;
                        if (state.charMoveProgress >= 1) {
                            state.kissing = true;
                            state.kissTimer = 0;
                            isCelebrating.current = true;
                            setTimeout(() => {
                                setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                            }, 3000);
                        }
                        return;
                    }
                    
                    // Move text for steps 1 and 2
                    if (state.step > 0 && state.step < 3) {
                        state.textPosition += state.textSpeed * state.textDirection;
                        if (state.textPosition >= 1) {
                            state.textPosition = 1;
                            state.textDirection = -1;
                        } else if (state.textPosition <= 0) {
                            state.textPosition = 0;
                            state.textDirection = 1;
                        }
                    }
                    
                    if (!state.canClick) {
                        state.clickCooldown++;
                        if (state.clickCooldown > 30) {
                            state.canClick = true;
                            state.clickCooldown = 0;
                        }
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    const { width, height } = dimensions;
                    
                    const state = player.weddingState || { step: 0, textPosition: 0.5, showFeedback: false, feedbackText: '', kissing: false, charMoveProgress: 0, fireworks: [], transitionDelay: false };
                    
                    // Background - changes to outdoor forest with inukshuk at step 3 (after 4 second delay)
                    if (state.step === 3) {
                        // Outdoor Banff forest background with inukshuk
                        // Sky
                        const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
                        skyGrad.addColorStop(0, '#87CEEB');
                        skyGrad.addColorStop(1, '#B0E0E6');
                        ctx.fillStyle = skyGrad;
                        ctx.fillRect(0, 0, width, height);
                        
                        // Mountains in background
                        ctx.fillStyle = '#808080';
                        ctx.beginPath();
                        ctx.moveTo(0, height * 0.4);
                        ctx.lineTo(width * 0.3, height * 0.2);
                        ctx.lineTo(width * 0.6, height * 0.35);
                        ctx.lineTo(width, height * 0.25);
                        ctx.lineTo(width, height * 0.7);
                        ctx.lineTo(0, height * 0.7);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Snow caps
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.moveTo(width * 0.25, height * 0.25);
                        ctx.lineTo(width * 0.3, height * 0.2);
                        ctx.lineTo(width * 0.35, height * 0.25);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Green forest ground
                        ctx.fillStyle = '#228b22';
                        ctx.fillRect(0, height * 0.7, width, height * 0.3);
                        
                        // Some grass texture
                        ctx.fillStyle = '#1a6b1a';
                        for (let i = 0; i < 20; i++) {
                            const x = Math.random() * width;
                            const y = height * 0.7 + Math.random() * height * 0.3;
                            ctx.fillRect(x, y, 3 * scaleFactor, 8 * scaleFactor);
                        }
                        
                        // INUKSHUK - centered, twice as tall as characters, organic rounded design
                        const inukX = width * 0.5;
                        const inukY = height * 0.45;
                        const inukScale = scaleFactor * 3.5; // Twice as tall as characters (who are ~1.8)
                        
                        ctx.save();
                        ctx.translate(inukX, inukY);
                        ctx.scale(inukScale, inukScale);
                        
                        // Multiple stone colors for natural variation
                        const stone1 = '#9e9589'; // Light tan
                        const stone2 = '#7a6f65'; // Medium gray-brown
                        const stone3 = '#5d5349'; // Dark brown
                        const outline = '#3d352e'; // Dark outline
                        
                        // Helper function to draw organic stone with texture
                        const drawStone = (x, y, w, h, baseColor, textures) => {
                            // Main stone body (rounded)
                            ctx.fillStyle = baseColor;
                            ctx.fillRect(x, y, w, h);
                            // Round the corners
                            ctx.fillRect(x + 2, y - 2, w - 4, 2);
                            ctx.fillRect(x + 2, y + h, w - 4, 2);
                            ctx.fillRect(x - 2, y + 2, 2, h - 4);
                            ctx.fillRect(x + w, y + 2, 2, h - 4);
                            
                            // Outline
                            ctx.strokeStyle = outline;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x + 2, y);
                            ctx.lineTo(x + w - 2, y);
                            ctx.lineTo(x + w, y + 2);
                            ctx.lineTo(x + w, y + h - 2);
                            ctx.lineTo(x + w - 2, y + h);
                            ctx.lineTo(x + 2, y + h);
                            ctx.lineTo(x, y + h - 2);
                            ctx.lineTo(x, y + 2);
                            ctx.closePath();
                            ctx.stroke();
                            
                            // Texture patterns
                            if (textures) {
                                textures.forEach(tex => {
                                    ctx.fillStyle = tex.color;
                                    if (tex.type === 'line') {
                                        ctx.fillRect(x + tex.x, y + tex.y, tex.w, tex.h);
                                    } else if (tex.type === 'oval') {
                                        ctx.fillRect(x + tex.x, y + tex.y, tex.w, tex.h);
                                        ctx.fillRect(x + tex.x + 1, y + tex.y - 1, tex.w - 2, 1);
                                        ctx.fillRect(x + tex.x + 1, y + tex.y + tex.h, tex.w - 2, 1);
                                    }
                                });
                            }
                        };
                        
                        // Base legs (two rounded stones)
                        drawStone(-28, 38, 18, 28, stone2, [
                            { type: 'line', color: stone3, x: 3, y: 8, w: 12, h: 3 },
                            { type: 'oval', color: outline, x: 5, y: 18, w: 4, h: 3 }
                        ]);
                        drawStone(10, 40, 20, 26, stone1, [
                            { type: 'line', color: stone2, x: 4, y: 6, w: 8, h: 2 },
                            { type: 'line', color: stone3, x: 6, y: 15, w: 6, h: 2 }
                        ]);
                        
                        // Lower body stone (stacked, slightly tilted)
                        drawStone(-25, 18, 22, 22, stone3, [
                            { type: 'line', color: stone2, x: 5, y: 8, w: 10, h: 2 }
                        ]);
                        drawStone(-5, 20, 18, 20, stone2, [
                            { type: 'oval', color: stone1, x: 4, y: 5, w: 8, h: 4 },
                            { type: 'line', color: stone3, x: 3, y: 12, w: 10, h: 2 }
                        ]);
                        
                        // Center support (vertical stone)
                        drawStone(-12, -8, 24, 30, stone1, [
                            { type: 'line', color: stone2, x: 6, y: 8, w: 10, h: 3 },
                            { type: 'line', color: stone3, x: 4, y: 18, w: 12, h: 2 },
                            { type: 'oval', color: outline, x: 8, y: 14, w: 3, h: 2 }
                        ]);
                        
                        // Arms (wide horizontal stone - iconic)
                        drawStone(-50, -8, 100, 16, stone2, [
                            { type: 'line', color: stone3, x: 15, y: 5, w: 20, h: 3 },
                            { type: 'line', color: stone1, x: 45, y: 6, w: 15, h: 2 },
                            { type: 'oval', color: outline, x: 70, y: 8, w: 5, h: 3 },
                            { type: 'line', color: stone3, x: 60, y: 4, w: 12, h: 2 }
                        ]);
                        
                        // Upper body stones (stacked under head)
                        drawStone(-8, -24, 16, 18, stone3, [
                            { type: 'line', color: stone2, x: 4, y: 6, w: 6, h: 2 }
                        ]);
                        
                        // Head (rounded top stone)
                        drawStone(-10, -38, 20, 16, stone1, [
                            { type: 'oval', color: stone2, x: 5, y: 4, w: 8, h: 5 },
                            { type: 'line', color: stone3, x: 3, y: 10, w: 10, h: 2 }
                        ]);
                        
                        ctx.restore();
                    } else {
                        // Original city hall background (steps 0-1)
                        const gradient = ctx.createLinearGradient(0, 0, 0, height);
                        gradient.addColorStop(0, '#e8d5c4');
                        gradient.addColorStop(1, '#d4c5b0');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, width, height);
                        
                        // Wooden floor
                        ctx.fillStyle = '#8b6f47';
                        ctx.fillRect(0, height * 0.7, width, height * 0.3);
                        ctx.fillStyle = '#6b5736';
                        for (let i = 0; i < 10; i++) {
                            ctx.fillRect(0, height * 0.7 + i * 30 * scaleFactor, width, 2 * scaleFactor);
                        }
                    }
                    
                    // Flags (only show in city hall before final step)
                    if (state.step < 2) {
                        // Canadian flag (left)
                        const flagX = width * 0.1;
                    const flagY = height * 0.15;
                    const flagW = 120 * scaleFactor; // Increased from 80 to 120 for better detail
                    const flagH = 75 * scaleFactor; // Increased from 50 to 75 (maintaining 8:5 ratio)
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(flagX, flagY, flagW * 0.25, flagH);
                    ctx.fillRect(flagX + flagW * 0.75, flagY, flagW * 0.25, flagH);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(flagX + flagW * 0.25, flagY, flagW * 0.5, flagH);
                    
                    // Better maple leaf design
                    ctx.fillStyle = '#FF0000';
                    const leafX = flagX + flagW * 0.5;
                    const leafY = flagY + flagH * 0.5;
                    const s = scaleFactor;
                    
                    // Maple leaf made of pixels - more detailed
                    // Center stem
                    ctx.fillRect(leafX - 2*s, leafY + 8*s, 4*s, 8*s);
                    
                    // Main body (center triangle)
                    ctx.fillRect(leafX - 8*s, leafY - 4*s, 16*s, 12*s);
                    
                    // Top point
                    ctx.fillRect(leafX - 4*s, leafY - 12*s, 8*s, 8*s);
                    ctx.fillRect(leafX - 2*s, leafY - 16*s, 4*s, 4*s);
                    
                    // Left point
                    ctx.fillRect(leafX - 16*s, leafY - 8*s, 8*s, 8*s);
                    ctx.fillRect(leafX - 20*s, leafY - 6*s, 4*s, 4*s);
                    
                    // Right point
                    ctx.fillRect(leafX + 8*s, leafY - 8*s, 8*s, 8*s);
                    ctx.fillRect(leafX + 16*s, leafY - 6*s, 4*s, 4*s);
                    
                    // Bottom left point
                    ctx.fillRect(leafX - 12*s, leafY + 4*s, 6*s, 6*s);
                    ctx.fillRect(leafX - 16*s, leafY + 6*s, 4*s, 4*s);
                    
                    // Bottom right point
                    ctx.fillRect(leafX + 6*s, leafY + 4*s, 6*s, 6*s);
                    ctx.fillRect(leafX + 12*s, leafY + 6*s, 4*s, 4*s);
                    
                    // South Korean flag (right)
                    const skFlagX = width * 0.9 - flagW;
                    const skFlagY = height * 0.15;
                    // White background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(skFlagX, skFlagY, flagW, flagH);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(skFlagX, skFlagY, flagW, flagH);
                    
                    // Taegeuk (yin-yang circle)
                    const centerX = skFlagX + flagW * 0.5;
                    const centerY = skFlagY + flagH * 0.5;
                    const radius = flagH * 0.25;
                    
                    // Red half (top)
                    ctx.fillStyle = '#CD2E3A';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, Math.PI, 0, false);
                    ctx.fill();
                    
                    // Blue half (bottom)
                    ctx.fillStyle = '#0047A0';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI, false);
                    ctx.fill();
                    
                    // Small circles
                    ctx.fillStyle = '#CD2E3A';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY - radius/2, radius/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0047A0';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY + radius/2, radius/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Trigrams (simplified black bars)
                    ctx.fillStyle = '#000000';
                    const barW = 3 * scaleFactor;
                    const barH = 12 * scaleFactor;
                    const barSpacing = 4 * scaleFactor;
                    
                    // Top-left trigram (three solid bars)
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(skFlagX + 8 * scaleFactor, skFlagY + 8 * scaleFactor + i * barSpacing, barW, barH);
                    }
                    
                    // Top-right trigram (three solid bars)
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(skFlagX + flagW - 8 * scaleFactor - barW, skFlagY + 8 * scaleFactor + i * barSpacing, barW, barH);
                    }
                    
                    // Bottom-left trigram (three solid bars)
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(skFlagX + 8 * scaleFactor, skFlagY + flagH - 8 * scaleFactor - barH + i * barSpacing, barW, barH);
                    }
                    
                    // Bottom-right trigram (three solid bars)
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(skFlagX + flagW - 8 * scaleFactor - barW, skFlagY + flagH - 8 * scaleFactor - barH + i * barSpacing, barW, barH);
                    }
                    } // End of flags (only in city hall)
                    
                    // Marriage license document (show in steps 0-2 and during transition delay, hide at step 3)
                    if (state.step < 3) {
                    const docX = width * 0.5 - 150 * scaleFactor;
                    const docY = height * 0.3;
                    const docW = 300 * scaleFactor;
                    const docH = 200 * scaleFactor;
                    
                    ctx.fillStyle = '#fffff0';
                    ctx.fillRect(docX, docY, docW, docH);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(docX, docY, docW, docH);
                    
                    ctx.fillStyle = '#000000';
                    ctx.font = `${12 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.fillText('MARRIAGE LICENSE', width * 0.5, docY + 30 * scaleFactor);
                    
                    // STEP 0: YES or NO
                    if (state.step === 0) {
                        const line1Y = docY + 90 * scaleFactor;
                        ctx.fillStyle = '#000000';
                        ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('DO YOU TAKE', width * 0.5, line1Y - 30 * scaleFactor);
                        ctx.fillText('THIS PARTNER?', width * 0.5, line1Y - 12 * scaleFactor);
                        
                        // YES button (left) - moved lower
                        const yesX = docX + 75 * scaleFactor;
                        const noX = docX + 225 * scaleFactor;
                        const buttonY = line1Y + 20 * scaleFactor; // Moved down by 20
                        const buttonW = 60 * scaleFactor;
                        const buttonH = 30 * scaleFactor;
                        
                        ctx.fillStyle = '#22c55e';
                        ctx.fillRect(yesX - buttonW/2, buttonY - buttonH/2, buttonW, buttonH);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(yesX - buttonW/2, buttonY - buttonH/2, buttonW, buttonH);
                        ctx.fillStyle = '#fff';
                        ctx.font = `${12 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillText('YES', yesX, buttonY + 5 * scaleFactor);
                        
                        // NO button (right)
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(noX - buttonW/2, buttonY - buttonH/2, buttonW, buttonH);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(noX - buttonW/2, buttonY - buttonH/2, buttonW, buttonH);
                        ctx.fillStyle = '#fff';
                        ctx.fillText('NO', noX, buttonY + 5 * scaleFactor);
                        
                        // Store button positions for click detection
                        state.yesButton = [yesX - buttonW/2, buttonY - buttonH/2, buttonW, buttonH];
                        state.noButton = [noX - buttonW/2, buttonY - buttonH/2, buttonW, buttonH];
                    }
                    
                    // STEP 1: James ROMANEK alignment
                    if (state.step === 1) {
                        const line2Y = docY + 120 * scaleFactor;
                        const lineStartX = docX + 50 * scaleFactor;
                        const lineEndX = docX + docW - 50 * scaleFactor;
                        
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(lineStartX, line2Y);
                        ctx.lineTo(lineEndX, line2Y);
                        ctx.stroke();
                        
                        // Moving text "JAMES ROMANEK"
                        const textX = lineStartX + state.textPosition * (lineEndX - lineStartX);
                        ctx.fillStyle = '#1e40af';
                        ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('JAMES ROMANEK', textX, line2Y - 10 * scaleFactor);
                        
                        // Target zone (center) - matched to text width
                        const centerX = lineStartX + (lineEndX - lineStartX) * 0.5;
                        // Measure text width for green box
                        const textWidth = ctx.measureText('JAMES ROMANEK').width;
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
                        ctx.fillRect(centerX - textWidth/2, line2Y - 25 * scaleFactor, textWidth, 30 * scaleFactor);
                    }
                    
                    // Show aligned James name (step 2 and beyond)
                    if (state.step >= 2) {
                        const line2Y = docY + 120 * scaleFactor;
                        const lineStartX = docX + 50 * scaleFactor;
                        const lineEndX = docX + docW - 50 * scaleFactor;
                        
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(lineStartX, line2Y);
                        ctx.lineTo(lineEndX, line2Y);
                        ctx.stroke();
                        
                        // Static aligned text "JAMES ROMANEK" (no green box)
                        const centerX = lineStartX + (lineEndX - lineStartX) * 0.5;
                        ctx.fillStyle = '#1e40af';
                        ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('JAMES ROMANEK', centerX, line2Y - 10 * scaleFactor);
                    }
                    
                    // STEP 2:  alignment  
                    if (state.step === 2) {
                        const line3Y = docY + 160 * scaleFactor;
                        const lineStartX = docX + 50 * scaleFactor;
                        const lineEndX = docX + docW - 50 * scaleFactor;
                        
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(lineStartX, line3Y);
                        ctx.lineTo(lineEndX, line3Y);
                        ctx.stroke();
                        
                        // Moving text "" - 50% BIGGER than James name
                        const textX = lineStartX + state.textPosition * (lineEndX - lineStartX);
                        ctx.fillStyle = '#ec4899';
                        ctx.font = `${21 * scaleFactor}px "Press Start 2P"`; // 50% bigger (14 * 1.5 = 21)
                        ctx.textAlign = 'center';
                        ctx.fillText('', textX, line3Y - 10 * scaleFactor);
                        
                        // Target zone (center) - matched to text width
                        const centerX = lineStartX + (lineEndX - lineStartX) * 0.5;
                        // Measure Korean text width for green box
                        const textWidth = ctx.measureText('').width;
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
                        ctx.fillRect(centerX - textWidth/2, line3Y - 25 * scaleFactor, textWidth, 30 * scaleFactor);
                    }
                    
                    // Show aligned Korean name (step 3 and beyond)
                    if (state.step >= 3) {
                        const line3Y = docY + 160 * scaleFactor;
                        const lineStartX = docX + 50 * scaleFactor;
                        const lineEndX = docX + docW - 50 * scaleFactor;
                        
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(lineStartX, line3Y);
                        ctx.lineTo(lineEndX, line3Y);
                        ctx.stroke();
                        
                        // Static aligned text "" (no green box) - 50% BIGGER
                        const centerX = lineStartX + (lineEndX - lineStartX) * 0.5;
                        ctx.fillStyle = '#ec4899';
                        ctx.font = `${21 * scaleFactor}px "Press Start 2P"`; // 50% bigger (14 * 1.5 = 21)
                        ctx.textAlign = 'center';
                        ctx.fillText('', centerX, line3Y - 10 * scaleFactor);
                    }
                    
                    // Feedback text
                    if (state.showFeedback) {
                        ctx.fillStyle = state.feedbackText.includes('SUCCESS') || state.feedbackText === 'PERFECT!' ? '#22c55e' : '#ef4444';
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText(state.feedbackText, width * 0.5, height * 0.25);
                    }
                    } // End of marriage license (only show in steps 0-1)
                    
                    // Characters
                    const skin = '#ffd6cc';
                    const skinShadow = '#e0b3a8';
                    const charScale = 2.0;
                    
                    let jamesX, romyX, jamesY, romyY;
                    
                    if (state.step < 3) {
                        // Starting positions - centered vertically
                        jamesX = width * 0.3;
                        romyX = width * 0.7;
                        jamesY = height * 0.5; // Centered vertically instead of 0.85
                        romyY = height * 0.5; // Centered vertically instead of 0.85
                    } else {
                        // Moving together for kiss IN FRONT of marriage license (center of screen)
                        const targetX = width * 0.5;
                        const targetY = height * 0.5; // Center vertically
                        // Move closer together - leaving less space between them
                        const spacing = 30 * charScale * scaleFactor; // Reduced spacing for closer kiss
                        jamesX = width * 0.3 + (targetX - spacing - width * 0.3) * state.charMoveProgress;
                        romyX = width * 0.7 - (width * 0.7 - targetX - spacing) * state.charMoveProgress;
                        jamesY = targetY;
                        romyY = targetY;
                    }
                    
                    // Draw James
                    ctx.save();
                    ctx.translate(jamesX, jamesY);
                    ctx.scale(charScale * scaleFactor, charScale * scaleFactor);
                    ctx.translate(-50, 0);
                    // Black suit instead of blue
                    drawPixelRect(ctx, 30, 60, 40, 40, '#1a1a1a', '#000000');
                    drawPixelRect(ctx, 30, 20, 40, 40, skin, skinShadow);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(31, 31, 14, 12);
                    ctx.fillRect(55, 31, 14, 12);
                    ctx.fillRect(45, 34, 10, 3);
                    ctx.fillStyle = skin;
                    ctx.fillRect(34, 34, 8, 6);
                    ctx.fillRect(58, 34, 8, 6);
                    ctx.restore();
                    
                    // Draw Romy
                    ctx.save();
                    ctx.translate(romyX, romyY);
                    ctx.scale(charScale * scaleFactor, charScale * scaleFactor);
                    ctx.translate(-50, 0);
                    const hairColor = '#1a1a1a';
                    const hairShadow = '#000';
                    const hairHighlight = '#333333';
                    drawPixelRect(ctx, 22, 14, 56, 8, hairColor, hairShadow);
                    drawPixelRect(ctx, 16, 22, 68, 40, hairColor, hairShadow);
                    ctx.fillStyle = hairHighlight;
                    ctx.fillRect(20, 26, 8, 12);
                    ctx.fillRect(32, 24, 12, 16);
                    ctx.fillRect(50, 26, 10, 14);
                    ctx.fillRect(68, 28, 8, 12);
                    drawPixelRect(ctx, 16, 62, 16, 12, hairColor, hairShadow);
                    drawPixelRect(ctx, 68, 62, 16, 12, hairColor, hairShadow);
                    ctx.fillStyle = hairColor;
                    ctx.fillRect(18, 72, 8, 6);
                    ctx.fillRect(74, 72, 8, 6);
                    const faceX = 30; const faceY = 28; const faceW = 40; const faceH = 38;
                    ctx.fillStyle = '#000';
                    ctx.fillRect(faceX - 2, faceY + 2, faceW + 4, faceH - 4);
                    ctx.fillRect(faceX + 2, faceY - 2, faceW - 4, faceH + 4);
                    ctx.fillStyle = skin;
                    ctx.fillRect(faceX, faceY, faceW, faceH);
                    ctx.fillStyle = hairColor;
                    ctx.fillRect(faceX, faceY, 4, 4);
                    ctx.fillRect(faceX + faceW - 4, faceY, 4, 4);
                    ctx.fillStyle = skinShadow;
                    ctx.fillRect(faceX + faceW - 12, faceY + 20, 12, 18);
                    ctx.fillStyle = '#000';
                    const eyeY = 44;
                    ctx.fillRect(38, eyeY, 6, 6);
                    ctx.fillRect(56, eyeY, 6, 6);
                    drawPixelRect(ctx, 30, 66, 40, 34, '#f8b4d9', '#ec4899');
                    const sparkleFrame = Math.floor(player.frame / 10) % 3;
                    ctx.fillStyle = '#ffffff';
                    if (sparkleFrame === 0) {
                        ctx.fillRect(35, 70, 2, 2);
                        ctx.fillRect(52, 75, 2, 2);
                        ctx.fillRect(42, 82, 2, 2);
                        ctx.fillRect(60, 88, 2, 2);
                    }
                    if (sparkleFrame === 1) {
                        ctx.fillRect(38, 73, 2, 2);
                        ctx.fillRect(55, 78, 2, 2);
                        ctx.fillRect(45, 85, 2, 2);
                        ctx.fillRect(58, 91, 2, 2);
                    }
                    if (sparkleFrame === 2) {
                        ctx.fillRect(40, 68, 2, 2);
                        ctx.fillRect(50, 76, 2, 2);
                        ctx.fillRect(48, 84, 2, 2);
                        ctx.fillRect(62, 90, 2, 2);
                    }
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(32, 68, 6, 2);
                    ctx.fillRect(54, 72, 8, 2);
                    ctx.fillRect(36, 80, 6, 2);
                    ctx.restore();
                    
                    // Kissing animation with heart
                    if (state.kissing) {
                        ctx.fillStyle = '#ff0000';
                        ctx.font = `${30 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        const heartY = height * 0.5 - Math.sin(state.kissTimer * 0.1) * 10 * scaleFactor;
                        ctx.fillText('', width * 0.5, heartY);
                    }
                    
                    // Fireworks
                    if (state.fireworks && state.fireworks.length > 0) {
                        state.fireworks.forEach(fw => {
                            const fwX = fw.x * width;
                            const fwY = fw.y * height;
                            const alpha = fw.life / 60;
                            ctx.globalAlpha = alpha;
                            ctx.fillStyle = fw.color;
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const dist = (60 - fw.life) * 2 * scaleFactor;
                                const x = fwX + Math.cos(angle) * dist;
                                const y = fwY + Math.sin(angle) * dist;
                                ctx.fillRect(x, y, 4 * scaleFactor, 4 * scaleFactor);
                            }
                            ctx.globalAlpha = 1;
                        });
                    }
                    
                    // Instructions
                    if (!state.showFeedback && state.step < 3) {
                        ctx.fillStyle = '#000000';
                        ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        if (state.step === 0) {
                            ctx.fillText('CLICK YES TO CONTINUE!', width / 2, height - 30 * scaleFactor);
                        } else {
                            ctx.fillText('TAP WHEN CENTERED!', width / 2, height - 30 * scaleFactor);
                        }
                    }
                }
            },
            mexican_rescue: {
                update: (context) => {
                    const { player, setGameState, isCelebrating } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Simple state machine
                    if (!player.mx) {
                        player.mx = {
                            phase: 'bob', // bob -> drown -> slide -> done
                            timer: 0,
                            drownTime: 300 + Math.floor(Math.random() * 300), // 5-10 sec
                            santaX: 9999
                        };
                    }
                    
                    player.mx.timer++;
                    
                    if (player.mx.phase === 'bob' && player.mx.timer >= player.mx.drownTime) {
                        player.mx.phase = 'drown';
                        player.mx.timer = 0;
                    }
                    
                    if (player.mx.phase === 'drown' && player.mx.timer > 300) {
                        setGameState(s => ({ ...s, status: 'GAMEOVER', deathReason: 'drowned' }));
                    }
                    
                    if (player.mx.phase === 'slide') {
                        if (player.mx.timer < 60) {
                            // Slide animation
                        } else {
                            player.mx.phase = 'done';
                            isCelebrating.current = true;
                            setTimeout(() => {
                                setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                            }, 3000);
                        }
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    const { width, height } = dimensions;
                    
                    const mx = player.mx || { phase: 'bob', timer: 0, santaX: 9999 };
                    
                    // === BACKGROUND (always draw) ===
                    // Sky with clouds
                    const sky = ctx.createLinearGradient(0, 0, 0, height * 0.5);
                    sky.addColorStop(0, '#87CEEB');
                    sky.addColorStop(1, '#E0F6FF');
                    ctx.fillStyle = sky;
                    ctx.fillRect(0, 0, width, height * 0.5);
                    
                    // Fluffy clouds
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    const drawCloud = (cx, cy, size) => {
                        ctx.beginPath();
                        ctx.arc(cx, cy, size, 0, Math.PI * 2);
                        ctx.arc(cx + size * 0.8, cy, size * 0.8, 0, Math.PI * 2);
                        ctx.arc(cx - size * 0.8, cy, size * 0.8, 0, Math.PI * 2);
                        ctx.arc(cx, cy - size * 0.6, size * 0.9, 0, Math.PI * 2);
                        ctx.fill();
                    };
                    drawCloud(width * 0.15, height * 0.12, 25 * scaleFactor);
                    drawCloud(width * 0.65, height * 0.18, 30 * scaleFactor);
                    drawCloud(width * 0.35, height * 0.08, 20 * scaleFactor);
                    
                    // Sun with rays
                    const sunX = width * 0.8;
                    const sunY = height * 0.15;
                    const sunR = 40 * scaleFactor;
                    // Sun rays
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 3 * scaleFactor;
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(sunX + Math.cos(angle) * sunR, sunY + Math.sin(angle) * sunR);
                        ctx.lineTo(sunX + Math.cos(angle) * (sunR + 20 * scaleFactor), sunY + Math.sin(angle) * (sunR + 20 * scaleFactor));
                        ctx.stroke();
                    }
                    // Sun body
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
                    ctx.fill();
                    // Sun highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(sunX - 10 * scaleFactor, sunY - 10 * scaleFactor, sunR * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Water top layer (lighter)
                    const surf = ctx.createLinearGradient(0, height * 0.5, 0, height * 0.62);
                    surf.addColorStop(0, '#4DA6FF');
                    surf.addColorStop(1, '#1E90FF');
                    ctx.fillStyle = surf;
                    ctx.fillRect(0, height * 0.5, width, height * 0.12);
                    
                    // Water deep layer (darker)
                    const deep = ctx.createLinearGradient(0, height * 0.62, 0, height * 0.85);
                    deep.addColorStop(0, '#1E90FF');
                    deep.addColorStop(1, '#0047AB');
                    ctx.fillStyle = deep;
                    ctx.fillRect(0, height * 0.62, width, height * 0.23);
                    
                    // Water line with wave pattern
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let x = 0; x < width; x += 10) {
                        const y = height * 0.62 + Math.sin(x * 0.05 + player.frame * 0.05) * 3 * scaleFactor;
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // Sandy beach with texture
                    ctx.fillStyle = '#F4A460';
                    ctx.fillRect(0, height * 0.85, width, height * 0.15);
                    // Beach texture (little dots)
                    ctx.fillStyle = '#DEB887';
                    for (let i = 0; i < 30; i++) {
                        const bx = (i * 37) % width;
                        const by = height * 0.85 + ((i * 23) % (height * 0.15));
                        ctx.fillRect(bx, by, 2, 2);
                    }
                    
                    // Palm trees on beach
                    const drawPalm = (px, py) => {
                        const s = scaleFactor;
                        // Trunk
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(px - 4 * s, py, 8 * s, 60 * s);
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(px - 2 * s, py + 10 * s, 4 * s, 3 * s);
                        ctx.fillRect(px - 2 * s, py + 25 * s, 4 * s, 3 * s);
                        ctx.fillRect(px - 2 * s, py + 40 * s, 4 * s, 3 * s);
                        
                        // Palm fronds
                        ctx.fillStyle = '#228B22';
                        // Left fronds
                        ctx.fillRect(px - 40 * s, py - 10 * s, 36 * s, 8 * s);
                        ctx.fillRect(px - 35 * s, py - 5 * s, 31 * s, 8 * s);
                        // Right fronds
                        ctx.fillRect(px + 4 * s, py - 10 * s, 36 * s, 8 * s);
                        ctx.fillRect(px + 4 * s, py - 5 * s, 31 * s, 8 * s);
                        // Center frond
                        ctx.fillRect(px - 4 * s, py - 20 * s, 8 * s, 20 * s);
                        // Highlights
                        ctx.fillStyle = '#32CD32';
                        ctx.fillRect(px - 30 * s, py - 8 * s, 10 * s, 3 * s);
                        ctx.fillRect(px + 10 * s, py - 8 * s, 10 * s, 3 * s);
                    };
                    drawPalm(width * 0.1, height * 0.85);
                    drawPalm(width * 0.9, height * 0.85);
                    
                    // Water sparkles (animated)
                    ctx.fillStyle = '#FFF';
                    for (let i = 0; i < 25; i++) {
                        const sx = ((i * 73 + player.frame * 2) % width);
                        const sy = height * 0.5 + ((i * 47) % (height * 0.35));
                        const sparkle = 2 + Math.sin(player.frame * 0.1 + i) * 1;
                        ctx.fillRect(sx, sy, sparkle * scaleFactor, sparkle * scaleFactor);
                    }
                    
                    // === CHARACTERS ===
                    // Helper to draw Romy with consistent face/hair from other levels
                    const drawR = (x, y, s) => {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(s, s);
                        ctx.translate(-50, -60);
                        
                        const hair = '#1a1a1a';
                        const hairShadow = '#000';
                        const skin = '#ffd6cc';
                        const skinShadow = '#e0b3a8';
                        
                        // Hair - same style as other levels
                        ctx.fillStyle = hair;
                        ctx.fillRect(22, 14, 56, 8);  // Top
                        ctx.fillRect(16, 22, 68, 40); // Main volume
                        
                        // Face with pixel art border (no mouth)
                        const faceX = 30; const faceY = 28; const faceW = 40; const faceH = 38;
                        ctx.fillStyle = '#000';
                        ctx.fillRect(faceX - 2, faceY + 2, faceW + 4, faceH - 4);
                        ctx.fillRect(faceX + 2, faceY - 2, faceW - 4, faceH + 4);
                        ctx.fillStyle = skin;
                        ctx.fillRect(faceX, faceY, faceW, faceH);
                        // Face corners
                        ctx.fillStyle = hair;
                        ctx.fillRect(faceX, faceY, 4, 4);
                        ctx.fillRect(faceX + faceW - 4, faceY, 4, 4);
                        // Face shadow
                        ctx.fillStyle = skinShadow;
                        ctx.fillRect(faceX + faceW - 12, faceY + 20, 12, 18);
                        
                        // Eyes - simple black squares (NO MOUTH)
                        ctx.fillStyle = '#000';
                        ctx.fillRect(38, 44, 6, 6);
                        ctx.fillRect(56, 44, 6, 6);
                        
                        // Body - torso (upper body)
                        ctx.fillStyle = skin;
                        ctx.fillRect(30, 66, 40, 20);
                        ctx.fillStyle = skinShadow;
                        ctx.fillRect(56, 72, 14, 14);
                        
                        // Bikini top (sparkly pink) - adjusted to not create harsh line
                        ctx.fillStyle = '#f8b4d9';
                        ctx.fillRect(30, 70, 40, 8); // Moved down from 66 to 70, reduced height from 10 to 8
                        ctx.fillStyle = '#ec4899';
                        ctx.fillRect(32, 72, 2, 2);
                        ctx.fillRect(44, 72, 2, 2);
                        ctx.fillRect(56, 72, 2, 2);
                        ctx.fillRect(66, 72, 2, 2);
                        
                        // Waist
                        ctx.fillStyle = skin;
                        ctx.fillRect(30, 86, 40, 14);
                        ctx.fillStyle = skinShadow;
                        ctx.fillRect(56, 88, 14, 10);
                        
                        // Legs
                        ctx.fillStyle = skin;
                        ctx.fillRect(30, 100, 16, 20);
                        ctx.fillRect(54, 100, 16, 20);
                        ctx.fillStyle = skinShadow;
                        ctx.fillRect(36, 106, 10, 12);
                        ctx.fillRect(60, 106, 10, 12);
                        
                        // Bikini bottom
                        ctx.fillStyle = '#f8b4d9';
                        ctx.fillRect(32, 100, 36, 8);
                        ctx.fillStyle = '#ec4899';
                        ctx.fillRect(34, 102, 2, 2);
                        ctx.fillRect(48, 102, 2, 2);
                        ctx.fillRect(62, 102, 2, 2);
                        
                        ctx.restore();
                    };
                    
                    // Helper to draw Handsome Santa with real sunglasses
                    const drawS = (x, y, s) => {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(s, s);
                        ctx.translate(-50, -60);
                        
                        const skin = '#d4a373';
                        const skinDark = '#b8865f';
                        
                        // Muscular torso (shirtless!)
                        ctx.fillStyle = skin;
                        ctx.fillRect(25, 60, 50, 45);
                        
                        // Muscle definition
                        ctx.fillStyle = skinDark;
                        ctx.fillRect(35, 70, 8, 15);
                        ctx.fillRect(57, 70, 8, 15);
                        ctx.fillRect(45, 85, 10, 12);
                        ctx.fillRect(38, 88, 6, 8);
                        ctx.fillRect(56, 88, 6, 8);
                        
                        // Arms
                        ctx.fillStyle = skin;
                        ctx.fillRect(15, 65, 10, 25);
                        ctx.fillRect(75, 65, 10, 25);
                        ctx.fillStyle = skinDark;
                        ctx.fillRect(17, 72, 6, 10);
                        ctx.fillRect(77, 72, 6, 10);
                        
                        // Red swim shorts
                        ctx.fillStyle = '#dc2626';
                        ctx.fillRect(30, 105, 40, 20);
                        ctx.fillStyle = '#991b1b';
                        ctx.fillRect(32, 108, 36, 3);
                        
                        // Head
                        ctx.fillStyle = skin;
                        ctx.fillRect(30, 20, 40, 40);
                        ctx.fillStyle = skinDark;
                        ctx.fillRect(56, 40, 14, 16);
                        
                        // Big white beard
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(25, 40, 50, 28);
                        ctx.fillRect(20, 45, 60, 18);
                        ctx.fillRect(25, 60, 50, 12);
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(28, 48, 4, 4);
                        ctx.fillRect(38, 52, 4, 4);
                        ctx.fillRect(48, 48, 4, 4);
                        ctx.fillRect(58, 52, 4, 4);
                        ctx.fillRect(68, 48, 4, 4);
                        
                        // REAL SUNGLASSES (black frames and dark lenses)
                        // Left lens
                        ctx.fillStyle = '#000'; // Frame
                        ctx.fillRect(34, 28, 14, 10);
                        ctx.fillStyle = '#1a1a1a'; // Dark lens
                        ctx.fillRect(36, 30, 10, 6);
                        
                        // Right lens
                        ctx.fillStyle = '#000'; // Frame
                        ctx.fillRect(52, 28, 14, 10);
                        ctx.fillStyle = '#1a1a1a'; // Dark lens
                        ctx.fillRect(54, 30, 10, 6);
                        
                        // Bridge
                        ctx.fillStyle = '#000';
                        ctx.fillRect(48, 30, 4, 3);
                        
                        // Lens reflections (white highlights)
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(38, 31, 3, 2);
                        ctx.fillRect(56, 31, 3, 2);
                        
                        // Eyebrows above sunglasses
                        ctx.fillStyle = '#8b6f47';
                        ctx.fillRect(36, 26, 8, 2);
                        ctx.fillRect(56, 26, 8, 2);
                        
                        ctx.restore();
                    };
                    
                    // === PHASE RENDERING ===
                    if (mx.phase === 'bob') {
                        const bob = Math.sin(mx.timer * 0.05) * 10 * scaleFactor;
                        drawR(width * 0.5, height * 0.5 + bob, 2 * scaleFactor);
                        
                        ctx.fillStyle = '#000';
                        ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('WATCH ROMY CAREFULLY...', width * 0.5, height - 30 * scaleFactor);
                    }
                    
                    if (mx.phase === 'drown') {
                        // Romy underwater with transparency
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        drawR(width * 0.5, height * 0.65, 2 * scaleFactor);
                        ctx.restore();
                        
                        // Animated splash
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const dist = (30 + Math.sin(mx.timer * 0.15 + i) * 8) * scaleFactor;
                            const sx = width * 0.5 + Math.cos(angle) * dist;
                            const sy = height * 0.5 + Math.sin(angle) * dist;
                            ctx.fillRect(sx, sy, 10 * scaleFactor, 10 * scaleFactor);
                        }
                        
                        // Warning text
                        ctx.fillStyle = '#FF0000';
                        ctx.font = `${20 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('DROWNING!', width * 0.5, height * 0.3);
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillText('TAP TO SAVE!', width * 0.5, height * 0.38);
                    }
                    
                    if (mx.phase === 'slide' || mx.phase === 'done') {
                        const prog = Math.min(1, mx.timer / 60);
                        const santaX = width + 100 - (prog * (width * 0.55 + 100));
                        drawS(santaX, height * 0.5, 2.5 * scaleFactor);
                        
                        // Romy pops up smoothly
                        let romyY = height * 0.65;
                        if (prog >= 1) {
                            const popTime = Math.min(1, (mx.timer - 60) / 30);
                            romyY = height * 0.65 - (popTime * height * 0.15);
                        }
                        drawR(width * 0.55, romyY, 1.8 * scaleFactor);
                        
                        if (mx.phase === 'done') {
                            // Victory text
                            ctx.fillStyle = '#FFD700';
                            ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                            ctx.textAlign = 'center';
                            ctx.fillText('RESCUED!', width * 0.5, height * 0.2);
                        }
                    }
                }
            },
            phone_call: {
                update: (context) => {
                    const { player, setGameState, isCelebrating } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize phone state
                    if (!player.phone) {
                        player.phone = {
                            phase: 'typing', // typing -> waiting -> ringing -> answered -> connected
                            typingText: "DURING COVID TIMES, SOMETIMES JAMES AND ROMY WERE ON OPPOSITE SIDES OF THE EARTH. IT WAS HARD. BUT EVERYTHING SEEMED OK, AS LONG AS YOU ANSWERED THE PHONE WHEN IT RANG...",
                            typedChars: 0,
                            typingSpeed: 0.25, // characters per frame (even slower)
                            waitAfterTyping: 120, // 2 seconds
                            waitTimer: 0,
                            waitTime: 180 + Math.floor(Math.random() * 120), // 3-5 seconds
                            ringStart: null,
                            ringWindow: 120, // 2 seconds to answer
                            buttonY: null
                        };
                    }
                    
                    const p = player.phone;
                    
                    if (p.phase === 'typing') {
                        // Type out the intro text
                        if (p.typedChars < p.typingText.length) {
                            p.typedChars += p.typingSpeed;
                            if (p.typedChars > p.typingText.length) {
                                p.typedChars = p.typingText.length;
                            }
                        } else {
                            // Done typing, wait 2 seconds
                            p.waitTimer++;
                            if (p.waitTimer >= p.waitAfterTyping) {
                                p.phase = 'waiting';
                            }
                        }
                    }
                    
                    if (p.phase === 'waiting') {
                        if (player.frame >= p.waitTime) {
                            p.phase = 'ringing';
                            p.ringStart = player.frame;
                            if (context.playPhoneRingSound) {
                                context.playPhoneRingSound(); // Play phone ring!
                            }
                        }
                    }
                    
                    if (p.phase === 'ringing') {
                        const elapsed = player.frame - p.ringStart;
                        // Play ring sound every 60 frames (every second)
                        if (elapsed % 60 === 0 && context.playPhoneRingSound) {
                            context.playPhoneRingSound();
                        }
                        if (elapsed > p.ringWindow) {
                            // Missed the call
                            setGameState(s => ({ ...s, status: 'GAMEOVER', deathReason: 'missed_call' }));
                        }
                    }
                    
                    if (p.phase === 'answered') {
                        // Wait a moment then complete
                        if (!p.answerTime) {
                            p.answerTime = player.frame;
                        }
                        if (player.frame - p.answerTime > 180) {
                            p.phase = 'connected';
                            isCelebrating.current = true;
                            setTimeout(() => {
                                setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                            }, 3000);
                        }
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    const { width, height } = dimensions;
                    
                    const p = player.phone || { phase: 'waiting' };
                    
                    // === SPLIT SCREEN BACKGROUND ===
                    // Left side - Canada (empty snowy room)
                    const leftGrad = ctx.createLinearGradient(0, 0, 0, height);
                    leftGrad.addColorStop(0, '#1e293b');
                    leftGrad.addColorStop(1, '#334155');
                    ctx.fillStyle = leftGrad;
                    ctx.fillRect(0, 0, width / 2, height);
                    
                    // Right side - Korea (empty bright room)
                    const rightGrad = ctx.createLinearGradient(width / 2, 0, width / 2, height);
                    rightGrad.addColorStop(0, '#fef3c7');
                    rightGrad.addColorStop(1, '#fde68a');
                    ctx.fillStyle = rightGrad;
                    ctx.fillRect(width / 2, 0, width / 2, height);
                    
                    // === LEFT SIDE DETAILS - CANADA ===
                    // Window with snow
                    const windowX = width * 0.15;
                    const windowY = height * 0.12;
                    const windowW = 100 * scaleFactor;
                    const windowH = 80 * scaleFactor;
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(windowX, windowY, windowW, windowH);
                    // Many snowflakes
                    ctx.fillStyle = '#FFF';
                    for (let i = 0; i < 15; i++) {
                        const sx = windowX + (i % 5) * 20 * scaleFactor + ((player.frame + i * 10) % 20) * scaleFactor;
                        const sy = windowY + Math.floor(i / 5) * 25 * scaleFactor + ((player.frame + i * 7) % 25) * scaleFactor;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 2 * scaleFactor, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Window frame
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(windowX, windowY, windowW, windowH);
                    ctx.beginPath();
                    ctx.moveTo(windowX + windowW / 2, windowY);
                    ctx.lineTo(windowX + windowW / 2, windowY + windowH);
                    ctx.moveTo(windowX, windowY + windowH / 2);
                    ctx.lineTo(windowX + windowW, windowY + windowH / 2);
                    ctx.stroke();
                    
                    // === RIGHT SIDE DETAILS - KOREA ===
                    // Window with cherry blossoms
                    const window2X = width * 0.65;
                    const window2Y = height * 0.12;
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(window2X, window2Y, windowW, windowH);
                    // Cherry blossom tree branch
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(window2X, window2Y + windowH);
                    ctx.lineTo(window2X + windowW * 0.3, window2Y + windowH * 0.4);
                    ctx.lineTo(window2X + windowW * 0.7, window2Y + windowH * 0.3);
                    ctx.stroke();
                    // Cherry blossoms
                    ctx.fillStyle = '#FFC0CB';
                    for (let i = 0; i < 12; i++) {
                        const bx = window2X + (10 + i * 8 + ((player.frame * 0.3) % 80)) * scaleFactor;
                        const by = window2Y + (10 + (i % 4) * 18) * scaleFactor;
                        ctx.beginPath();
                        ctx.arc(bx, by, 5 * scaleFactor, 0, Math.PI * 2);
                        ctx.fill();
                        // Petals
                        for (let j = 0; j < 5; j++) {
                            const angle = (j / 5) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.arc(bx + Math.cos(angle) * 4 * scaleFactor, by + Math.sin(angle) * 4 * scaleFactor, 2 * scaleFactor, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(window2X, window2Y, windowW, windowH);
                    ctx.beginPath();
                    ctx.moveTo(window2X + windowW / 2, window2Y);
                    ctx.lineTo(window2X + windowW / 2, window2Y + windowH);
                    ctx.moveTo(window2X, window2Y + windowH / 2);
                    ctx.lineTo(window2X + windowW, window2Y + windowH / 2);
                    ctx.stroke();
                    
                    // === CHARACTERS ===
                    // James (male, looking at phone) - LEFT SIDE (CANADA)
                    const jamesX = width * 0.25;
                    const jamesY = height * 0.5;
                    const skin = '#ffd6cc';
                    const skinShadow = '#e0b3a8';
                    
                    ctx.save();
                    ctx.translate(jamesX, jamesY);
                    ctx.scale(3 * scaleFactor, 3 * scaleFactor);
                    ctx.translate(-50, 0);
                    
                    // Body - BLUE SHIRT (like earlier levels)
                    ctx.fillStyle = '#2563eb'; // Blue
                    ctx.fillRect(30, 60, 40, 40);
                    ctx.fillStyle = '#1e40af'; // Dark blue shadow
                    ctx.fillRect(34, 64, 32, 32);
                    
                    // Head/Face
                    ctx.fillStyle = skin;
                    ctx.fillRect(30, 20, 40, 40);
                    ctx.fillStyle = skinShadow;
                    ctx.fillRect(60, 35, 10, 20);
                    
                    // Black hair (James style from other levels)
                    ctx.fillStyle = '#000';
                    ctx.fillRect(31, 31, 14, 12); // Left eye area/hair
                    ctx.fillRect(55, 31, 14, 12); // Right eye area/hair
                    ctx.fillRect(45, 34, 10, 3); // Center hair
                    
                    // Eyes showing through
                    ctx.fillStyle = skin;
                    if (p.phase === 'connected') {
                        // Happy eyes
                        ctx.fillRect(34, 34, 8, 6);
                        ctx.fillRect(58, 34, 8, 6);
                        // Smile
                        ctx.fillStyle = '#000';
                        ctx.fillRect(42, 52, 2, 2);
                        ctx.fillRect(44, 54, 10, 2);
                        ctx.fillRect(54, 52, 2, 2);
                    } else {
                        // Sad eyes
                        ctx.fillRect(34, 34, 8, 8);
                        ctx.fillRect(58, 34, 8, 8);
                    }
                    
                    ctx.restore();
                    
                    // Romy (female, looking at phone) - RIGHT SIDE (KOREA)
                    const romyX = width * 0.75;
                    const romyY = height * 0.5;
                    ctx.save();
                    ctx.translate(romyX, romyY);
                    ctx.scale(3 * scaleFactor, 3 * scaleFactor);
                    ctx.translate(-50, 0);
                    
                    const hairColor = '#1a1a1a';
                    const hairShadow = '#000';
                    
                    // Hair - long female hair
                    ctx.fillStyle = hairColor;
                    ctx.fillRect(22, 14, 56, 8);
                    ctx.fillRect(16, 22, 68, 40);
                    ctx.fillStyle = hairShadow;
                    ctx.fillRect(18, 24, 4, 36);
                    
                    // Face
                    const faceX = 30; const faceY = 28; const faceW = 40; const faceH = 38;
                    ctx.fillStyle = '#000';
                    ctx.fillRect(faceX - 2, faceY + 2, faceW + 4, faceH - 4);
                    ctx.fillRect(faceX + 2, faceY - 2, faceW - 4, faceH + 4);
                    ctx.fillStyle = skin;
                    ctx.fillRect(faceX, faceY, faceW, faceH);
                    ctx.fillStyle = hairColor;
                    ctx.fillRect(faceX, faceY, 4, 4);
                    ctx.fillRect(faceX + faceW - 4, faceY, 4, 4);
                    ctx.fillStyle = skinShadow;
                    ctx.fillRect(faceX + faceW - 12, faceY + 20, 12, 18);
                    
                    // Eyes
                    ctx.fillStyle = '#000';
                    if (p.phase === 'connected') {
                        // Happy eyes
                        ctx.fillRect(38, 44, 6, 6);
                        ctx.fillRect(56, 44, 6, 6);
                        // Smile
                        ctx.fillRect(42, 54, 2, 2);
                        ctx.fillRect(44, 56, 10, 2);
                        ctx.fillRect(54, 54, 2, 2);
                    } else {
                        // Sad eyes
                        ctx.fillRect(38, 44, 6, 8);
                        ctx.fillRect(56, 44, 6, 8);
                    }
                    
                    // Body - DARK SLATE OUTFIT (like earlier levels)
                    ctx.fillStyle = '#334155'; // Dark slate
                    ctx.fillRect(30, 66, 40, 34);
                    ctx.fillStyle = '#1e293b'; // Darker shadow
                    ctx.fillRect(34, 70, 32, 26);
                    
                    ctx.restore();
                    
                    // === DIVIDER LINE (changes based on connection) ===
                    if (p.phase === 'connected') {
                        // ZIG-ZAG LIGHTNING CONNECTION LINE
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 6;
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        const midX = width / 2;
                        const segments = 8;
                        const zigWidth = 30 * scaleFactor;
                        for (let i = 0; i <= segments; i++) {
                            const y = (i / segments) * height;
                            const offset = (i % 2 === 0) ? -zigWidth : zigWidth;
                            const x = midX + offset + Math.sin(player.frame * 0.1 + i) * 5 * scaleFactor;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // Sparks along the line
                        ctx.fillStyle = '#FFF';
                        for (let i = 0; i < 5; i++) {
                            const sparkY = (i / 5) * height + (player.frame % 60);
                            const sparkX = midX + ((i % 2 === 0) ? -zigWidth : zigWidth);
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, 4 * scaleFactor, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Floating hearts
                        ctx.fillStyle = '#FF0000';
                        ctx.font = `${20 * scaleFactor}px "Press Start 2P"`;
                        for (let i = 0; i < 6; i++) {
                            const hx = width * (0.1 + i * 0.15);
                            const hy = height * 0.2 + Math.sin(player.frame * 0.08 + i) * 15 * scaleFactor;
                            ctx.fillText('', hx, hy);
                        }
                        
                        // Connected text at top
                        ctx.fillStyle = '#10B981';
                        ctx.font = `${18 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('CONNECTED!', width * 0.5, height * 0.08);
                    } else {
                        // Normal divider line
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(width / 2, 0);
                        ctx.lineTo(width / 2, height);
                        ctx.stroke();
                    }
                    
                    // === PHONE STATES ===
                    if (p.phase === 'typing') {
                        // Dark overlay
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, 0, width, height);
                        
                        // Typing text - LEFT ALIGNED
                        const displayText = p.typingText.substring(0, Math.floor(p.typedChars));
                        ctx.fillStyle = '#FFF';
                        ctx.font = `${11 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'left'; // LEFT ALIGNED
                        
                        // Word wrap the text
                        const leftMargin = width * 0.05; // Start from left
                        const maxWidth = width * 0.9;
                        const words = displayText.split(' ');
                        let line = '';
                        let y = height * 0.3;
                        const lineHeight = 22 * scaleFactor;
                        
                        for (let i = 0; i < words.length; i++) {
                            const testLine = line + words[i] + ' ';
                            const metrics = ctx.measureText(testLine);
                            
                            if (metrics.width > maxWidth && i > 0) {
                                ctx.fillText(line, leftMargin, y);
                                line = words[i] + ' ';
                                y += lineHeight;
                            } else {
                                line = testLine;
                            }
                        }
                        ctx.fillText(line, leftMargin, y);
                        
                        // Blinking cursor if still typing
                        if (p.typedChars < p.typingText.length) {
                            const cursorBlink = Math.floor(player.frame / 30) % 2;
                            if (cursorBlink) {
                                const cursorX = leftMargin + ctx.measureText(line).width;
                                ctx.fillText('_', cursorX, y);
                            }
                        }
                    }
                    
                    if (p.phase === 'waiting') {
                        ctx.fillStyle = '#FFF';
                        ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('WAITING FOR THE CALL...', width * 0.5, height * 0.95);
                    }
                    
                    if (p.phase === 'ringing') {
                        // Vibrating phone icon with CALLING text
                        const shake = Math.sin(player.frame * 0.5) * 3 * scaleFactor;
                        const phoneY = height * 0.5 + shake;
                        
                        // Phone icon (larger)
                        ctx.fillStyle = '#000';
                        ctx.fillRect(width * 0.5 - 40 * scaleFactor, phoneY - 60 * scaleFactor, 80 * scaleFactor, 120 * scaleFactor);
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(width * 0.5 - 35 * scaleFactor, phoneY - 55 * scaleFactor, 70 * scaleFactor, 110 * scaleFactor);
                        
                        // Phone screen with caller
                        ctx.fillStyle = '#E0E0E0';
                        ctx.fillRect(width * 0.5 - 30 * scaleFactor, phoneY - 50 * scaleFactor, 60 * scaleFactor, 80 * scaleFactor);
                        
                        // CALLING text (blinking)
                        ctx.fillStyle = '#FF0000';
                        ctx.font = `${22 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        const blink = Math.floor(player.frame / 15) % 2;
                        if (blink) {
                            ctx.fillText('CALLING...', width * 0.5, phoneY - 90 * scaleFactor);
                        }
                        
                        // Vibration lines
                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(width * 0.5 - 50 * scaleFactor - i * 10 * scaleFactor, phoneY, 15 * scaleFactor, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(width * 0.5 + 50 * scaleFactor + i * 10 * scaleFactor, phoneY, 15 * scaleFactor, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        
                        // ACCEPT button
                        const buttonW = 140 * scaleFactor;
                        const buttonH = 50 * scaleFactor;
                        const buttonX = width * 0.5 - buttonW / 2;
                        const buttonY = phoneY + 80 * scaleFactor;
                        p.buttonY = buttonY;
                        
                        ctx.fillStyle = '#10B981';
                        ctx.fillRect(buttonX, buttonY, buttonW, buttonH);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(buttonX, buttonY, buttonW, buttonH);
                        
                        ctx.fillStyle = '#FFF';
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillText('ACCEPT', width * 0.5, buttonY + 32 * scaleFactor);
                    }
                    
                    if (p.phase === 'answered') {
                        // Transition: Show "CONNECTING..." 
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(0, height * 0.4, width, height * 0.2);
                        
                        ctx.fillStyle = '#FFF';
                        ctx.font = `${18 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        const dots = '.'.repeat((Math.floor(player.frame / 20) % 3) + 1);
                        ctx.fillText('CONNECTING' + dots, width * 0.5, height * 0.5);
                    }
                }
            },
            road_trip: {
                update: (context) => {
                    const { player, setGameState, isCelebrating } = context;
                    
                    if (isCelebrating.current) return;
                    
                    // Initialize province selection state
                    if (!player.provinceSelect) {
                        const allProvinces = [
                            "British Columbia",
                            "Alberta", 
                            "Saskatchewan",
                            "Manitoba",
                            "Ontario",
                            "Quebec",
                            "New Brunswick",
                            "Nova Scotia",
                            "Prince Edward Island",
                            "Newfoundland and Labrador"
                        ];
                        
                        const correctProvinces = ["Ontario", "Manitoba", "Saskatchewan", "Alberta"];
                        
                        player.provinceSelect = {
                            allProvinces,
                            correctProvinces,
                            clickedProvinces: [], // Track order of clicks
                            showError: false,
                            errorTimer: 0
                        };
                    }
                    
                    const ps = player.provinceSelect;
                    
                    // Update error display timer
                    if (ps.showError) {
                        ps.errorTimer++;
                        if (ps.errorTimer > 90) { // 1.5 seconds
                            // Reset
                            ps.clickedProvinces = [];
                            ps.showError = false;
                            ps.errorTimer = 0;
                        }
                        return;
                    }
                    
                    // Check if won - all 4 correct provinces clicked (in any order)
                    if (ps.clickedProvinces.length === 4) {
                        const allCorrect = ps.clickedProvinces.every(p => ps.correctProvinces.includes(p));
                        if (allCorrect) {
                            isCelebrating.current = true;
                            setTimeout(() => {
                                setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                            }, 2000);
                        }
                    }
                    
                    player.frame++;
                },
                draw: (ctx, context) => {
                    const { dimensions, scaleFactor, player } = context;
                    const { width, height } = dimensions;
                    
                    const ps = player.provinceSelect || { allProvinces: [], clickedProvinces: [], showError: false };
                    
                    // Background - Canada red
                    const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                    bgGrad.addColorStop(0, '#dc2626');
                    bgGrad.addColorStop(1, '#991b1b');
                    ctx.fillStyle = bgGrad;
                    ctx.fillRect(0, 0, width, height);
                    
                    // Error overlay
                    if (ps.showError) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(0, 0, width, height);
                        
                        ctx.fillStyle = '#ef4444';
                        ctx.font = `${16 * scaleFactor}px "Press Start 2P"`;
                        ctx.textAlign = 'center';
                        ctx.fillText('WRONG!', width * 0.5, height * 0.45);
                        
                        ctx.fillStyle = '#FFF';
                        ctx.font = `${12 * scaleFactor}px "Press Start 2P"`;
                        ctx.fillText('RESTARTING...', width * 0.5, height * 0.55);
                        return;
                    }
                    
                    // Title - moved down to avoid overlap
                    ctx.fillStyle = '#FFF';
                    ctx.font = `${14 * scaleFactor}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.fillText('WHAT PROVINCES', width * 0.5, height * 0.15);
                    ctx.fillText('DID WE VISIT?', width * 0.5, height * 0.21);
                    
                    // Progress
                    ctx.font = `${10 * scaleFactor}px "Press Start 2P"`;
                    ctx.fillText(`${ps.clickedProvinces.length} / 4 SELECTED`, width * 0.5, height * 0.28);
                    
                    // Draw province buttons
                    if (ps.allProvinces && ps.allProvinces.length > 0) {
                        if (!ps.provinceButtons) ps.provinceButtons = {};
                        
                        const buttonW = width * 0.7;
                        const buttonH = 35 * scaleFactor;
                        const startY = height * 0.34;
                        const spacing = 38 * scaleFactor;
                        
                        ctx.font = `${9 * scaleFactor}px "Press Start 2P"`;
                        
                        for (let i = 0; i < ps.allProvinces.length; i++) {
                            const province = ps.allProvinces[i];
                            const buttonX = width * 0.15;
                            const buttonY = startY + i * spacing;
                            
                            // Store button bounds for click detection
                            ps.provinceButtons[province] = { x: buttonX, y: buttonY, w: buttonW, h: buttonH };
                            
                            // Check if clicked
                            const isClicked = ps.clickedProvinces.includes(province);
                            
                            // Button background
                            ctx.fillStyle = isClicked ? '#22c55e' : '#FFF';
                            ctx.fillRect(buttonX, buttonY, buttonW, buttonH);
                            
                            // Button border
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(buttonX, buttonY, buttonW, buttonH);
                            
                            // Province name
                            ctx.fillStyle = isClicked ? '#FFF' : '#000';
                            ctx.textAlign = 'center';
                            ctx.fillText(province, width * 0.5, buttonY + 22 * scaleFactor);
                        }
                    }
                    
                }
            },
        };

        const drawTurkey = (ctx, x, y, s) => {
            // Completely new turkey - realistic roasted look
            
            // Purple serving platter
            ctx.fillStyle = '#7b68ee';
            ctx.fillRect(x - 55*s, y + 35*s, 110*s, 8*s);
            ctx.fillStyle = '#6a5acd';
            ctx.fillRect(x - 58*s, y + 32*s, 116*s, 3*s);
            
            // Green platter rim  
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(x - 60*s, y + 30*s, 120*s, 2*s);
            
            // Main turkey body - use ellipses for rounder, more realistic shape
            ctx.save();
            
            // Bottom base (darkest)
            ctx.fillStyle = '#8b4513';
            ctx.beginPath();
            ctx.ellipse(x, y + 10*s, 40*s, 18*s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Mid body
            ctx.fillStyle = '#a0522d';
            ctx.beginPath();
            ctx.ellipse(x, y, 38*s, 22*s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Upper body  
            ctx.fillStyle = '#cd853f';
            ctx.beginPath();
            ctx.ellipse(x, y - 8*s, 32*s, 18*s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Top highlight
            ctx.fillStyle = '#daa520';
            ctx.beginPath();
            ctx.ellipse(x, y - 12*s, 24*s, 12*s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Peak golden highlight
            ctx.fillStyle = '#f0e68c';
            ctx.beginPath();
            ctx.ellipse(x, y - 15*s, 16*s, 8*s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Left drumstick
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(x - 48*s, y + 15*s, 16*s, 28*s);
            ctx.fillStyle = '#a0522d';
            ctx.fillRect(x - 46*s, y + 17*s, 12*s, 24*s);
            // Bone
            ctx.fillStyle = '#fffaf0';
            ctx.fillRect(x - 44*s, y + 40*s, 8*s, 14*s);
            ctx.fillRect(x - 46*s, y + 52*s, 12*s, 5*s);
            
            // Right drumstick
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(x + 32*s, y + 15*s, 16*s, 28*s);
            ctx.fillStyle = '#a0522d';
            ctx.fillRect(x + 34*s, y + 17*s, 12*s, 24*s);
            // Bone
            ctx.fillStyle = '#fffaf0';
            ctx.fillRect(x + 36*s, y + 40*s, 8*s, 14*s);
            ctx.fillRect(x + 34*s, y + 52*s, 12*s, 5*s);
            
            // Wing hints on sides
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(x - 38*s, y + 5*s, 12*s, 18*s);
            ctx.fillRect(x + 26*s, y + 5*s, 12*s, 18*s);
            
            // Glossy roasted sheen
            ctx.save();
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.ellipse(x - 8*s, y - 12*s, 20*s, 8*s, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Steam wisps
            const t = Date.now() / 300;
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = '#ffffff';
            
            // Left wisp
            ctx.fillRect(x - 22*s, y - 35*s + Math.sin(t) * 4, 6*s, 12*s);
            ctx.fillRect(x - 21*s, y - 45*s + Math.sin(t) * 5, 5*s, 10*s);
            
            // Center wisp
            ctx.fillRect(x - 3*s, y - 40*s + Math.cos(t + 1) * 4, 7*s, 15*s);
            ctx.fillRect(x - 2*s, y - 52*s + Math.cos(t + 1) * 5, 6*s, 11*s);
            
            // Right wisp
            ctx.fillRect(x + 16*s, y - 37*s + Math.sin(t + 2) * 4, 6*s, 13*s);
            ctx.fillRect(x + 17*s, y - 47*s + Math.sin(t + 2) * 5, 5*s, 9*s);
            
            ctx.restore();
        };

        const drawFather = (ctx, x, y, s) => {
            ctx.save();
            ctx.translate(x, y);
            // Red Plaid Shirt
            ctx.fillStyle = '#b91c1c';
            ctx.fillRect(0, 60*s, 60*s, 60*s);
            ctx.fillStyle = '#7f1d1d';
            ctx.fillRect(15*s, 60*s, 6*s, 60*s);
            ctx.fillRect(0, 85*s, 60*s, 6*s);
            
            // Bigger Head
            ctx.fillStyle = '#ffd6cc'; 
            ctx.fillRect(-5*s, 0, 70*s, 65*s);
            
            // Brown hair with Greying Sides
            ctx.fillStyle = '#2d1b0d'; 
            ctx.fillRect(-5*s, -5*s, 70*s, 15*s); // Top
            ctx.fillRect(-10*s, 0, 15*s, 25*s); // Left
            ctx.fillRect(55*s, 0, 15*s, 25*s); // Right
            
            // Greying spots
            ctx.fillStyle = '#d1d5db';
            ctx.fillRect(-10*s, 5*s, 6*s, 6*s);
            ctx.fillRect(-8*s, 15*s, 4*s, 4*s);
            ctx.fillRect(64*s, 5*s, 6*s, 6*s);
            ctx.fillRect(64*s, 15*s, 4*s, 4*s);

            // Eyes
            ctx.fillStyle = '#000';
            ctx.fillRect(10*s, 30*s, 6*s, 6*s);
            ctx.fillRect(44*s, 30*s, 6*s, 6*s);
            ctx.restore();
        };

        const drawMom = (ctx, x, y, s) => {
            // Mom modeled after Romy sprite but with short black hair with white streaks and light red top
            ctx.save();
            ctx.translate(x, y);
            
            const hairColor = '#1a1a1a'; // Black hair
            const hairShadow = '#000';
            const whiteStreak = '#e5e7eb'; // White/grey streaks
            const skin = '#ffd6cc';
            const skinShadow = '#e0b3a8';
            
            // SHORT black hair - much shorter than Romy's
            // Top of head (shorter)
            drawPixelRect(ctx, 24, 16, 52, 8, hairColor, hairShadow);
            // Main hair volume (shorter sides)
            drawPixelRect(ctx, 20, 24, 60, 30, hairColor, hairShadow);
            // Short side pieces (much shorter than Romy's)
            drawPixelRect(ctx, 20, 54, 12, 8, hairColor, hairShadow);
            drawPixelRect(ctx, 68, 54, 12, 8, hairColor, hairShadow);
            
            // White/grey streaks throughout the hair
            ctx.fillStyle = whiteStreak;
            ctx.fillRect(28, 18, 8, 6);
            ctx.fillRect(40, 16, 10, 8);
            ctx.fillRect(58, 18, 8, 6);
            ctx.fillRect(22, 28, 6, 8);
            ctx.fillRect(72, 30, 6, 8);
            ctx.fillRect(35, 38, 8, 6);
            ctx.fillRect(55, 40, 8, 6);
            
            // Face (same as Romy)
            const faceX = 30; const faceY = 28; const faceW = 40; const faceH = 38;
            ctx.fillStyle = '#000'; 
            ctx.fillRect(faceX - 2, faceY + 2, faceW + 4, faceH - 4); 
            ctx.fillRect(faceX + 2, faceY - 2, faceW - 4, faceH + 4);
            ctx.fillStyle = skin; 
            ctx.fillRect(faceX, faceY, faceW, faceH);
            ctx.fillStyle = hairColor; 
            ctx.fillRect(faceX, faceY, 4, 4); 
            ctx.fillRect(faceX + faceW - 4, faceY, 4, 4);
            ctx.fillStyle = skinShadow; 
            ctx.fillRect(faceX + faceW - 12, faceY + 20, 12, 18);
            
            // Eyes (same as Romy)
            ctx.fillStyle = '#000';
            const eyeY = 44;
            ctx.fillRect(38, eyeY, 6, 6); 
            ctx.fillRect(56, eyeY, 6, 6);
            
            // Smile (friendly)
            ctx.fillRect(40, 56, 20, 3);
            
            // Light red/coral top (same structure as Romy's grey top)
            drawPixelRect(ctx, 30, 66, 40, 34, '#fb7185', '#f43f5e');
            
            ctx.restore();
        };

        const drawSojuBottle = (ctx, x, y, s) => {
            drawPixelRect(ctx, x + 8*s, y, 12*s, 18*s, '#166534', '#052e16');
            drawPixelRect(ctx, x, y + 18*s, 28*s, 50*s, '#166534', '#052e16');
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 3*s, y + 35*s, 22*s, 20*s);
            ctx.fillStyle = '#166534';
            ctx.fillRect(x + 10*s, y + 42*s, 8*s, 8*s);
        };

        const drawLevel6 = (ctx, width, height, scale, frame, ritualState, ritualTimer, player) => {
            const s = Math.min(width, height) / 500;
            ctx.fillStyle = '#334155';
            ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = '#1e293b';
            for(let i=0; i<width; i+= 100*s) ctx.fillRect(i, 0, 4*s, height);

            const tableW = width * 0.9;
            const tableH = 140 * s;
            const tableX = (width - tableW) / 2;
            const tableY = height / 2 + 30 * s;
            drawPixelRect(ctx, tableX, tableY, tableW, tableH, '#5d4037', '#3e2723');

            const grillX = width/2;
            const grillY = tableY + 60*s;
            ctx.fillStyle = '#424242';
            ctx.beginPath();
            ctx.arc(grillX, grillY, 50*s, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#ef4444';
            for(let i=0; i<4; i++) {
                ctx.fillRect(grillX - 20*s + (i*12*s), grillY - 5*s, 8*s, 8*s);
            }
            
            // Realistic meat on grill (before eating)
            if (ritualState === 'WAITING' || ritualState === 'CHEERS_WINDOW') {
                // Draw 3 pieces of meat cooking on grill
                const drawMeatPiece = (x, y, rotation) => {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    
                    // Meat body - irregular shape
                    ctx.fillStyle = '#8b4513'; // Cooked brown
                    ctx.beginPath();
                    ctx.moveTo(-15*s, -8*s);
                    ctx.lineTo(-12*s, -10*s);
                    ctx.lineTo(-5*s, -11*s);
                    ctx.lineTo(5*s, -10*s);
                    ctx.lineTo(12*s, -8*s);
                    ctx.lineTo(15*s, -5*s);
                    ctx.lineTo(14*s, 5*s);
                    ctx.lineTo(8*s, 10*s);
                    ctx.lineTo(-8*s, 10*s);
                    ctx.lineTo(-14*s, 5*s);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Darker edges (char marks)
                    ctx.strokeStyle = '#3e2723';
                    ctx.lineWidth = 2*s;
                    ctx.stroke();
                    
                    // Fat marbling (white streaks)
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 1.5*s;
                    ctx.beginPath();
                    ctx.moveTo(-8*s, -3*s);
                    ctx.lineTo(-2*s, -2*s);
                    ctx.lineTo(4*s, -4*s);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-5*s, 3*s);
                    ctx.lineTo(3*s, 4*s);
                    ctx.lineTo(8*s, 2*s);
                    ctx.stroke();
                    
                    // Grill marks
                    ctx.strokeStyle = '#1a0d00';
                    ctx.lineWidth = 1*s;
                    ctx.beginPath();
                    ctx.moveTo(-12*s, -5*s);
                    ctx.lineTo(12*s, -5*s);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-10*s, 2*s);
                    ctx.lineTo(10*s, 2*s);
                    ctx.stroke();
                    
                    ctx.restore();
                };
                
                drawMeatPiece(grillX - 20*s, grillY - 5*s, 0.2);
                drawMeatPiece(grillX + 15*s, grillY, -0.1);
                drawMeatPiece(grillX - 5*s, grillY + 10*s, 0.3);
            }

            const jamesX = width * 0.22;
            const romyX = width/2 - 30*s;
            const fatherX = width * 0.72;
            
            // Lettuce wraps (ssam) in front of each person
            const drawLettuceWrap = (x, y, isEaten) => {
                if (isEaten) return; // Don't draw if eaten
                
                ctx.save();
                ctx.translate(x, y);
                
                // Lettuce leaf - irregular organic shape
                ctx.fillStyle = '#4ade80'; // Bright green
                ctx.beginPath();
                ctx.moveTo(0, -20*s);
                ctx.quadraticCurveTo(-15*s, -18*s, -20*s, -10*s);
                ctx.quadraticCurveTo(-22*s, 0, -18*s, 10*s);
                ctx.quadraticCurveTo(-10*s, 18*s, 0, 20*s);
                ctx.quadraticCurveTo(10*s, 18*s, 18*s, 10*s);
                ctx.quadraticCurveTo(22*s, 0, 20*s, -10*s);
                ctx.quadraticCurveTo(15*s, -18*s, 0, -20*s);
                ctx.fill();
                
                // Darker green veins
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 1.5*s;
                ctx.beginPath();
                ctx.moveTo(0, -15*s);
                ctx.lineTo(0, 15*s);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-8*s, -5*s);
                ctx.lineTo(-15*s, 0);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(8*s, -5*s);
                ctx.lineTo(15*s, 0);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-8*s, 8*s);
                ctx.lineTo(-12*s, 12*s);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(8*s, 8*s);
                ctx.lineTo(12*s, 12*s);
                ctx.stroke();
                
                // Darker outline
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 2*s;
                ctx.beginPath();
                ctx.moveTo(0, -20*s);
                ctx.quadraticCurveTo(-15*s, -18*s, -20*s, -10*s);
                ctx.quadraticCurveTo(-22*s, 0, -18*s, 10*s);
                ctx.quadraticCurveTo(-10*s, 18*s, 0, 20*s);
                ctx.quadraticCurveTo(10*s, 18*s, 18*s, 10*s);
                ctx.quadraticCurveTo(22*s, 0, 20*s, -10*s);
                ctx.quadraticCurveTo(15*s, -18*s, 0, -20*s);
                ctx.stroke();
                
                // Cooked meat pieces on top of lettuce
                const drawMeatOnLettuce = (mx, my, rotation, size) => {
                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(rotation);
                    ctx.scale(size, size);
                    
                    // Meat piece - cooked brown
                    ctx.fillStyle = '#8b4513';
                    ctx.beginPath();
                    ctx.moveTo(-8*s, -4*s);
                    ctx.lineTo(-6*s, -5*s);
                    ctx.lineTo(6*s, -5*s);
                    ctx.lineTo(8*s, -3*s);
                    ctx.lineTo(7*s, 4*s);
                    ctx.lineTo(-7*s, 4*s);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Char marks
                    ctx.strokeStyle = '#3e2723';
                    ctx.lineWidth = 1*s;
                    ctx.stroke();
                    
                    // Fat streaks
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 0.8*s;
                    ctx.beginPath();
                    ctx.moveTo(-5*s, -2*s);
                    ctx.lineTo(5*s, -1*s);
                    ctx.stroke();
                    
                    ctx.restore();
                };
                
                // Draw 2-3 small meat pieces on the lettuce
                drawMeatOnLettuce(-5*s, -3*s, 0.2, 0.7);
                drawMeatOnLettuce(3*s, 0*s, -0.15, 0.65);
                drawMeatOnLettuce(-2*s, 5*s, 0.1, 0.6);
                
                ctx.restore();
            };
            
            // Check if lettuce wraps have been eaten
            const dadLettuceEaten = ritualState === 'EATING' || ritualState === 'COMPLETE';
            const jamesLettuceEaten = player?.meatClickTime !== null && player?.meatClickTime !== undefined;
            
            // Draw lettuce wraps
            drawLettuceWrap(fatherX, tableY + 30*s, dadLettuceEaten);
            drawLettuceWrap(jamesX, tableY + 30*s, jamesLettuceEaten);
            drawLettuceWrap(romyX, tableY + 30*s, false); // Romy's lettuce always there (decoration)


            // Phase based glass logic - Dad's glass moves first as indicator
            let dadGlassX = fatherX;
            let dadGlassY = tableY + 30*s;
            let jamesGlassOff = 0;
            
            // Dad's glass moves to above Romy's head when CHEERS_WINDOW starts (as indicator)
            if (ritualState === 'CHEERS_WINDOW' || ritualState === 'EATING' || ritualState === 'COMPLETE') {
                // Animate Dad's glass moving to above Romy's head
                let animationProgress = 0;
                if (ritualState === 'CHEERS_WINDOW') {
                    // Animate over the first 60 frames of CHEERS_WINDOW (ritualTimer 300-360)
                    const elapsed = ritualTimer - 300;
                    animationProgress = Math.min(1, elapsed / 60);
                } else {
                    // Already completed, stay at Romy's head
                    animationProgress = 1;
                }
                
                // Interpolate position from Dad's position to above Romy's head
                dadGlassX = fatherX + (romyX - fatherX) * animationProgress;
                dadGlassY = (tableY + 30*s) + ((tableY - 130*s) - (tableY + 30*s)) * animationProgress;
            }
            
            // James's glass animation - moves to meet Dad's glass above Romy's head (side by side)
            let jamesGlassX = jamesX + 20*s;
            let jamesGlassY = tableY + 30*s;
            
            // Check if we need to animate James's glass to meet Dad's glass
            if (ritualState === 'EATING' || ritualState === 'COMPLETE') {
                // Get the click time from the player state
                const jamesGlassClickTime = player?.jamesGlassClickTime;
                const JAMES_GLASS_ANIMATION_DURATION = 60; // 60 frames animation
                
                if (jamesGlassClickTime !== null && jamesGlassClickTime !== undefined) {
                    // Calculate animation progress
                    const elapsedSinceClick = ritualTimer - jamesGlassClickTime;
                    let animationProgress = Math.min(1, elapsedSinceClick / JAMES_GLASS_ANIMATION_DURATION);
                    
                    // Target position: next to Dad's glass (to the left)
                    const targetX = romyX - 20*s; // Position to the left of Dad's glass
                    const targetY = tableY - 130*s;
                    
                    // Starting position
                    const startX = jamesX + 20*s;
                    const startY = tableY + 30*s;
                    
                    // Interpolate to target position
                    jamesGlassX = startX + (targetX - startX) * animationProgress;
                    jamesGlassY = startY + (targetY - startY) * animationProgress;
                } else {
                    // Fallback: just move up if click time not tracked
                    jamesGlassY = tableY + 30*s - 20*s;
                }
            }

            ctx.save(); ctx.translate(jamesX, tableY - 60*s); ctx.scale(1.8 * scale, 1.8 * scale); renderCharacterBase(ctx, 'male', frame); ctx.restore();
            
            // Draw James's glass at animated position
            const jamesGlassRect = [jamesGlassX, jamesGlassY, 14*s, 16*s];
            drawPixelRect(ctx, jamesGlassRect[0], jamesGlassRect[1], jamesGlassRect[2], jamesGlassRect[3], '#cbd5e1', '#94a3b8');

            ctx.save(); ctx.translate(romyX, tableY - 110*s); ctx.scale(1.5 * scale, 1.5 * scale); renderCharacterBase(ctx, 'female', frame); ctx.restore();
            drawPixelRect(ctx, width/2 - 7*s, tableY + 15*s, 14*s, 16*s, '#cbd5e1', '#94a3b8');

            ctx.save(); ctx.translate(fatherX, tableY - 105*s); ctx.scale(1.6 * scale, 1.6 * scale); drawFather(ctx, 0, 0, 1.0); ctx.restore();
            
            // Draw Dad's glass at animated position
            const dadGlassRect = [dadGlassX, dadGlassY, 14*s, 16*s];
            drawPixelRect(ctx, dadGlassRect[0], dadGlassRect[1], dadGlassRect[2], dadGlassRect[3], '#cbd5e1', '#94a3b8');

            drawSojuBottle(ctx, fatherX + 80*s, tableY - 20*s, s);

            if (ritualState === 'EATING' || ritualState === 'COMPLETE') {
                ctx.fillStyle = '#fff';
                ctx.font = `${10 * scale}px "Press Start 2P"`;
                // Position CLINK! above Romy's head
                ctx.fillText('CLINK!', romyX - 20*s, tableY - 130*s);

                // Meat Animation
                const meatS = 10*s;
                const MEAT_ANIMATION_DURATION = 150; // Animation duration for meat movement
                
                if (ritualState === 'EATING') {
                    // Calculate when EATING phase started (when James's glass was clicked)
                    const eatingStartTime = player?.jamesGlassClickTime || 0;
                    const elapsedSinceEatingStart = ritualTimer - eatingStartTime;
                    
                    // Dad eats his lettuce wrap instantly when EATING starts
                    // (His lettuce wrap disappears, no animation needed - handled in drawLettuceWrap)
                    
                    // After Dad eats (instant), wait for player to click James's lettuce
                    // Then James's lettuce disappears
                    const meatClickTime = player?.meatClickTime;
                    if (meatClickTime !== null && meatClickTime !== undefined) {
                        // James ate his lettuce wrap (handled in drawLettuceWrap - it disappears)
                        // No animation needed
                    }
                }
                // COMPLETE state - no lettuce animations needed
            }

            return { 
                jamesGlass: jamesGlassRect, 
                jamesLettuce: [jamesX - 22*s, tableY + 10*s, 44*s, 40*s] // James's lettuce wrap clickable area
            };
        };

        /**
         * LEVEL DEFINITIONS: Add new levels here!
         * 
         * To add a new level, just add a new object to the LEVELS array below.
         * Each level can have:
         *   - number: Level number (auto-assigned if not provided)
         *   - themeName: Display name
         *   - type: Game type ("platformer", "catching", "wakeup", "bike_chase", "soju_ceremony")
         *   - introText: Story text shown before level starts
         *   - completionText: Text shown when level is completed
         *   - requiresCharSelect: If true, shows character selection before level
         *   - forcedCharacter: "male" or "female" to force a character (optional)
         *   - nextLevelStory: Story text shown after completion (before next level)
         *   - ...plus any type-specific config (gravity, segments, etc.)
         */
        
        const LEVEL_PASSWORDS = {
            1: null, 2: 'MOON', 3: 'STAR', 4: 'WAVE', 5: 'FIRE',
            6: 'LAKE', 7: 'SAND', 8: 'WIND', 9: 'ROSE', 10: 'LEAF',
            11: 'SNOW', 12: 'RAIN', 13: 'DAWN', 14: 'DUSK', 15: 'GOLD',
            16: 'RUBY', 17: 'JADE', 18: 'PEARL', 19: 'CORAL', 20: 'BLOOM'
        };
        
        const LEVELS = [
            {
                themeName: "HAN RIVER PARK",
                type: "platformer",
                introText: "Find your partner at the end of the river path. Jump over the 6 Pillow Monsters!",
                completionText: "The mission was a success!",
                nextLevelStory: "THEY DIDN'T TALK TO EACH OTHER AFTER THAT... THEN ROMY MESSAGED JAMES...",
                gravity: 0.6,
                jumpForce: -14,
                scrollSpeed: 5,
                primaryColor: "#166534",
                shadowColor: "#052e16",
                charScale: 2.0,
                segments: [
                    { id: 'start', type: 'flat', length: 1200 },
                    { id: 'o1', type: 'obstacle', length: 1000, obstacleType: 'pillow_monster' },
                    { id: 'o2', type: 'obstacle', length: 1000, obstacleType: 'pillow_monster' },
                    { id: 'o3', type: 'obstacle', length: 1000, obstacleType: 'pillow_monster' },
                    { id: 'o4', type: 'obstacle', length: 1000, obstacleType: 'pillow_monster' },
                    { id: 'o5', type: 'obstacle', length: 1000, obstacleType: 'pillow_monster' },
                    { id: 'o6', type: 'obstacle', length: 1000, obstacleType: 'pillow_monster' },
                    { id: 'end', type: 'flat', length: 1200, hasPartner: true }
                ]
            },
            {
                themeName: "YONGMASAN",
                type: "platformer",
                introText: "PIZZA SOUNDS GOOD, BUT JAMES IS AT THE TOP OF A MOUNTAIN, HURRY DOWN, BUT DON'T HIT ANY TREES!",
                completionText: "The mission was a success!",
                nextLevelStory: "JAMES MADE IT DOWN! GOOD THING HE GOT FEBREZE, BECAUSE HE STINKS!",
                forcedCharacter: "male",
                gravity: 0.6,
                jumpForce: -14,
                scrollSpeed: 4.5,
                primaryColor: "#15803d",
                shadowColor: "#064e3b",
                charScale: 1.2,
                segments: [
                    { id: 's2-start', type: 'flat', length: 1500 },
                    { id: 's2-o1', type: 'obstacle', length: 550, obstacleType: 'tree' },
                    { id: 's2-o2', type: 'obstacle', length: 550, obstacleType: 'tree' },
                    { id: 's2-o3', type: 'obstacle', length: 550, obstacleType: 'tree' },
                    { id: 's2-o4', type: 'obstacle', length: 550, obstacleType: 'tree' },
                    { id: 's2-o5', type: 'obstacle', length: 550, obstacleType: 'tree' },
                    { id: 's2-o6', type: 'obstacle', length: 550, obstacleType: 'tree' },
                    { id: 's2-o7', type: 'obstacle', length: 550, obstacleType: 'tree' },
                    { id: 's2-end', type: 'flat', length: 2500, hasFebreze: true }
                ]
            },
            {
                themeName: "CHEESEWICK",
                type: "catching",
                introText: "TIME TO EAT PIZZA, PICK YOUR CHARACTER",
                completionText: "The mission was a success!",
                nextLevelStory: "LET THE DATING BEGIN!",
                requiresCharSelect: true,
                charScale: 1.8,
                primaryColor: "#451a03",
                shadowColor: "#271104"
            },
            {
                themeName: "THE GENIUS",
                type: "genius_logic",
                introText: "WELCOME TO THE GENIUS! FIND THE 10s... BUT BE CAREFUL!",
                completionText: "OPEN! PASS! JUST LIKE HONG JINHO, WE PLAYED THE PERFECT GAME TOGETHER.",
                nextLevelStory: "PERFECT STRATEGY! TIME FOR MORE ADVENTURES!",
                charScale: 1.2,
                primaryColor: "#9333ea",
                shadowColor: "#6b21a8"
            },
            {
                themeName: "SAIPAN AIRPORT",
                type: "wakeup",
                introText: "CLICK THE Zs TO KEEP HER AWAKE",
                completionText: "The mission was a success!",
                nextLevelStory: "GOOD THING SHE STAYED AWAKE, LET'S TAKE ANOTHER VACATION",
                forcedCharacter: "female",
                charScale: 2.5,
                primaryColor: "#334155",
                shadowColor: "#0f172a"
            },
            {
                themeName: "BALI RIDE",
                type: "bike_chase",
                introText: "Bali is beautiful, let's take a motorcycle ride through the jungle, but don't lose your hat!",
                completionText: "What a wonderful ride. The hat is safe!",
                nextLevelStory: "THAT WAS FUN, AND THE HAT IS SAFE",
                charScale: 2.0,
                primaryColor: "#065f46",
                shadowColor: "#064e3b"
            },
            {
                themeName: "KBBQ",
                type: "soju_ceremony",
                introText: "MAKE SURE YOU DRINK YOUR SOJU CORRECTLY",
                completionText: "YOU MASTERED KBBQ",
                nextLevelStory: "YOU MASTERED KOREAN BBQ, TIME FOR A BIG MOVE... BUT WHERE WOULD WE MOVE TO?",
                charScale: 1.8
            },
            {
                themeName: "LET'S MOVE! PART 1",
                type: "letter_catch",
                introText: "Time to move to Canada! Catch the letters to spell CANADA!",
                completionText: "Canada, here we come!",
                nextLevelStory: "A new adventure awaits in the Great White North!",
                forcedCharacter: "female",
                charScale: 2.0,
                primaryColor: "#dc2626",
                shadowColor: "#991b1b",
                targetWord: "CANADA"
            },
            {
                themeName: "THANKSGIVING",
                type: "basting_game",
                introText: "TIME FOR CANADIAN THANKSGIVING! HELP JAMES'S MOM BASTE THE TURKEY!",
                completionText: "THE TURKEY IS PERFECTLY JUICY!",
                nextLevelStory: "THAT WAS DELICIOUS, TIME FOR MORE ADVENTURES!",
                forcedCharacter: "female",
                charScale: 1.8,
                primaryColor: "#d97706",
                shadowColor: "#92400e",
                bastesRequired: 5
            },
            {
                themeName: "WANNA GET MARRIED?",
                type: "city_hall_wedding",
                introText: "TIME TO MAKE IT OFFICIAL! SIGN THE MARRIAGE LICENSE!",
                completionText: "YOU'RE MARRIED! CONGRATULATIONS!",
                nextLevelStory: "OFFICIALLY HUSBAND AND WIFE!",
                charScale: 2.0,
                primaryColor: "#f8b4d9",
                shadowColor: "#ec4899",
                signaturesRequired: 3
            },
            {
                themeName: "MEXICO",
                type: "mexican_rescue",
                introText: "HONEYMOON IN MEXICO! WATCH OUT FOR ROMY IN THE WATER!",
                completionText: "HE SAVED HER! THE HANDSOME SANTA OF MEXICO COMES TO THE RESCUE!",
                nextLevelStory: "WHAT A HERO!",
                charScale: 2.0,
                primaryColor: "#fbbf24",
                shadowColor: "#f59e0b"
            },
            {
                themeName: "THE LONG DISTANCE CALL",
                type: "phone_call",
                introText: "COVID-19 SEPARATED THEM... TAP TO CONNECT!",
                completionText: "CONNECTED! LOVE KNOWS NO DISTANCE!",
                nextLevelStory: "EVEN ACROSS THE WORLD, THEIR CONNECTION STAYED STRONG!",
                charScale: 2.0,
                primaryColor: "#ec4899",
                shadowColor: "#be185d"
            },
            {
                themeName: "THE GREAT ROAD TRIP",
                type: "road_trip",
                introText: "TIME TO PLAN AN EPIC ROAD TRIP ACROSS CANADA!",
                completionText: "THOUSANDS OF KILOMETERS PLANNED, LET'S GO!",
                nextLevelStory: "THE ADVENTURE OF A LIFETIME AWAITS!",
                charScale: 2.0,
                primaryColor: "#dc2626",
                shadowColor: "#991b1b"
            },
            {
                themeName: "THE SMOKY HIGHWAY",
                type: "bike_chase",
                introText: "FOREST FIRE SEASON... THE SMOKE IS THICK. JUMP OVER THE HAZARDS!",
                completionText: "THE SMOKE WAS THICK, BUT WE NEVER STOPPED DRIVING. WE MADE IT THROUGH THE FIRE!",
                nextLevelStory: "THROUGH THE SMOKE AND DANGER, THEIR JOURNEY CONTINUED!",
                charScale: 2.0,
                primaryColor: "#ea580c",
                shadowColor: "#9a3412",
                isCarLevel: true, // Special flag for car rendering
                surviveTime: 45 // seconds to survive
            },
            {
                themeName: "THE BANFF ENCOUNTER",
                type: "stealth_engine",
                introText: "A BLACK BEAR ON THE TRAIL! HOLD STILL WHEN IT LOOKS AT YOU!",
                completionText: "IT WAS SCARY, BUT SO COOL! A REAL BANFF BLACK BEAR. WE KEPT OUR CALM AND MADE A MEMORY.",
                nextLevelStory: "WHAT AN INCREDIBLE ENCOUNTER!",
                charScale: 1.8,
                primaryColor: "#228b22",
                shadowColor: "#1a3409"
            },
            {
                themeName: "LET'S MOVE! PART 2",
                type: "letter_catch",
                introText: "Time to move to Korea! Catch the letters to spell KOREA!",
                completionText: "Korea, here we come!",
                nextLevelStory: "A new adventure awaits in Korea!",
                forcedCharacter: "male",
                charScale: 2.0,
                primaryColor: "#dc2626",
                shadowColor: "#991b1b",
                targetWord: "KOREA",
                cityscape: "seoul"
            },
            {
                themeName: "THE NORAEBANG SHOWDOWN",
                type: "noraebang_logic",
                introText: "CHOOSE THE BEST SINGER FOR NORAEBANG NIGHT!",
                completionText: "ROMY IS THE K-POP QUEEN! JAMES... SHOULD STICK TO HIS DAY JOB.",
                nextLevelStory: "WHAT A PERFORMANCE!",
                charScale: 2.5,
                primaryColor: "#7c3aed",
                shadowColor: "#5b21b6"
            },
            {
                themeName: "THE STUFFIE STACK",
                type: "stuffie_stack",
                introText: "TIME TO GET COZY! STACK EVERYONE ON THE COUCH...",
                completionText: "EVERYONE'S ON THE COUCH! THE PERFECT COZY SPOT!",
                nextLevelStory: "COZY VIBES COMPLETE!",
                charScale: 2.0,
                primaryColor: "#8b5cf6",
                shadowColor: "#6d28d9"
            },
            {
                themeName: "HAN RIVER DRONE SHOW",
                type: "drone_show",
                introText: "SUMMER NIGHTS BY THE RIVER...",
                completionText: "FROM KOREA TO CANADA AND BACK AGAIN... OUR STORY IS WRITTEN IN THE STARS!",
                nextLevelStory: "WHAT A MAGICAL EVENING!",
                charScale: 1.5,
                primaryColor: "#1e3a8a",
                shadowColor: "#0c1e4a"
            },
            {
                themeName: "FOREVER",
                type: "forever_loop",
                introText: "WOW, WE'VE DONE A LOT.",
                completionText: "THEN PUT THE PHONE DOWN AND KEEP PLAYING.",
                nextLevelStory: "THE END... OR IS IT?",
                charScale: 1.5,
                primaryColor: "#ff69b4",
                shadowColor: "#8b008b"
            }
            // ADD MORE LEVELS HERE! Just copy the format above and change the values.
            // Example for level 7:
            // {
            //     themeName: "NEW LOCATION",
            //     type: "platformer", // or "catching", "wakeup", etc.
            //     introText: "Your story text here",
            //     completionText: "Level complete message",
            //     nextLevelStory: "Story after completion",
            //     charScale: 2.0,
            //     primaryColor: "#166534",
            //     shadowColor: "#052e16",
            //     // ... add type-specific config
            // }
        ];

        // Auto-assign level numbers and create lookup objects
        LEVELS.forEach((level, index) => {
            if (!level.number) level.number = index + 1;
        });

        // Create LEVEL_CONFIGS for backward compatibility
        const LEVEL_CONFIGS = {};
        LEVELS.forEach(level => {
            LEVEL_CONFIGS[level.number] = level;
        });

        // Helper: Get level by number
        const getLevel = (num) => LEVEL_CONFIGS[num] || LEVELS[0];

        // Helper: Get all level numbers
        const getAllLevelNumbers = () => LEVELS.map(l => l.number);

        const App = () => {
            // Load unlocked levels from localStorage (persists across sessions)
            const getInitialUnlockedLevels = () => {
                try {
                    const saved = localStorage.getItem('unlockedLevels');
                    return saved ? JSON.parse(saved) : [1];
                } catch {
                    return [1];
                }
            };
            
            const [gameState, setGameState] = useState({ status: GameStatus.SPLASH, levelNumber: 1, character: 'male', score: 0, pizzasCaught: 0, zsTapped: 0, deathReason: null, ritualMessage: '', language: 'en', unlockedLevels: getInitialUnlockedLevels() });
            const [isMuted, setIsMuted] = useState(false);
            const [passwordModal, setPasswordModal] = useState({ show: false, levelNumber: null });
            const [passwordInput, setPasswordInput] = useState('');
            const [masterPasswordModal, setMasterPasswordModal] = useState(false);
            const [masterPasswordInput, setMasterPasswordInput] = useState('');
            const [timeUntilRelease, setTimeUntilRelease] = useState(null);
            
            // Gem Digging mini-game state (simple overlay)
            const [showGemGame, setShowGemGame] = useState(false);
            const [gemGrid, setGemGrid] = useState(null);
            const [gemClicks, setGemClicks] = useState(0);
            const [gemsRemaining, setGemsRemaining] = useState(0);
            
            // Release date: February 21, 2026 at 12:00 PM (noon) in user's timezone
            const RELEASE_DATE = new Date('2026-02-21T12:00:00');
            const geniusMusicRef = useRef(null);
            const canadaMusicRef = useRef(null);
            const koreaMusicRef = useRef(null);
            const level14MusicRef = useRef(null);
            const level19MusicRef = useRef(null);
            const level20MusicRef = useRef(null);
            const audioContextRef = useRef(null);
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const statusRef = useRef(GameStatus.MENU);
            const [dimensions, setDimensions] = useState({ width: window.innerWidth, height: window.innerHeight });
            
            // Translation system
            const translations = {
                en: {
                    // Buttons
                    START: 'START',
                    NEXT: 'NEXT',
                    YES: 'YES',
                    NO: 'NO',
                    MAIN_MENU: 'MAIN MENU',
                    
                    // Status text
                    SCORE: 'SCORE',
                    PIZZAS: 'PIZZAS',
                    WAKE_UP: 'WAKE UP',
                    TIME: 'TIME',
                    BASTES: 'BASTES',
                    
                    // Game states
                    TAP_THE_HAT_NOW: 'TAP THE HAT NOW!',
                    SAFE: 'SAFE!',
                    ENJOY_THE_RIDE: 'ENJOY THE RIDE',
                    WAIT_FOR_DAD: 'WAIT FOR DAD...',
                    CHEERS_NOW: 'CHEERS NOW!',
                    EAT: 'EAT!',
                    TAP_TO_DROP: 'TAP TO DROP!',
                    EVERYONE_IS_COZY: 'EVERYONE IS COZY!',
                    
                    // Level names
                    HAN_RIVER_PARK: 'HAN RIVER PARK',
                    YONGMASAN: 'YONGMASAN',
                    CHEESEWICK: 'CHEESEWICK',
                    THE_GENIUS: 'THE GENIUS',
                    SAIPAN_AIRPORT: 'SAIPAN AIRPORT',
                    BALI_RIDE: 'BALI RIDE',
                    KBBQ: 'KBBQ',
                    LETS_MOVE_1: "LET'S MOVE! PART 1",
                    THANKSGIVING: 'THANKSGIVING',
                    WANNA_GET_MARRIED: 'WANNA GET MARRIED?',
                    MEXICO: 'MEXICO',
                    LONG_DISTANCE_CALL: 'THE LONG DISTANCE CALL',
                    SMOKY_HIGHWAY: 'THE SMOKY HIGHWAY',
                    BANFF_ENCOUNTER: 'THE BANFF ENCOUNTER',
                    HOSPITAL: 'HOSPITAL',
                    LETS_MOVE_2: "LET'S MOVE! PART 2",
                    NORAEBANG_SHOWDOWN: 'NORAEBANG SHOWDOWN',
                    STUFFIE_STACK: 'THE STUFFIE STACK',
                    HAN_RIVER_DRONE_SHOW: 'HAN RIVER DRONE SHOW',
                    THE_FOREVER_LOOP: 'THE FOREVER LOOP',
                    
                    // Story text
                    THEY_DIDNT_TALK: "THEY DIDN'T TALK TO EACH OTHER AFTER THAT... THEN ROMY MESSAGED JAMES...",
                    MISSION_SUCCESS: "The mission was a success!",
                    JAMES_MADE_IT: "JAMES MADE IT DOWN! GOOD THING HE GOT FEBREZE, BECAUSE HE STINKS!",
                    LET_DATING_BEGIN: "LET THE DATING BEGIN!",
                    PERFECT_STRATEGY: "PERFECT STRATEGY! TIME FOR MORE ADVENTURES!",
                    GOOD_THING_AWAKE: "GOOD THING SHE STAYED AWAKE, LET'S TAKE ANOTHER VACATION",
                    HAT_IS_SAFE: "THAT WAS FUN, AND THE HAT IS SAFE",
                    YOU_SAVED_HAT: "YOU SAVED THE HAT!",
                    BACK_TO_KOREA: "LET'S HEAD BACK TO KOREA FOR SOME KBBQ! MAKE SURE YOU DO IT CORRECTLY!",
                    MASTERED_KBBQ: "YOU MASTERED KOREAN BBQ, TIME FOR A BIG MOVE... BUT WHERE WOULD WE MOVE TO?",
                    OFF_TO_CANADA: "OFF TO CANADA FOR MORE ADVENTURES!",
                    FIRST_THANKSGIVING: "ROMY'S FIRST CANADIAN THANKSGIVING. BASTE THE TURKEY CORRECTLY!",
                    PERFECT_TURKEY: "PERFECT TURKEY! WHAT NOW?",
                    DRESS_UP_NICELY: "LET'S DRESS UP NICELY AND....",
                    OFFICIALLY_MARRIED: "YOU'RE OFFICIALLY MARRIED!",
                    TRIP_TO_MEXICO: "LET'S TAKE A TRIP TO MEXICO, BE CAREFUL TO NOT DROWN!",
                    WHAT_A_HERO: "WHAT A HERO!",
                    COVID_SEPARATED: "COVID-19 SEPARATED THEM... TAP TO CONNECT!",
                    LOVE_NO_DISTANCE: "EVEN ACROSS THE WORLD, THEIR CONNECTION STAYED STRONG!",
                    SMOKY_DESCRIPTION: "FOREST FIRE SEASON... THE SMOKE IS THICK. JUMP OVER THE HAZARDS!",
                    THROUGH_SMOKE: "THROUGH THE SMOKE AND DANGER, THEIR JOURNEY CONTINUED!",
                    BLACK_BEAR: "A BLACK BEAR ON THE TRAIL! HOLD STILL WHEN IT LOOKS AT YOU!",
                    SCARY_BUT_COOL: "IT WAS SCARY, BUT SO COOL! A REAL BANFF BLACK BEAR.",
                    HOSPITAL_VISIT: "ROMY HAD TO VISIT THE HOSPITAL FOR A SURGERY... JAMES WAS THERE.",
                    BACK_TO_SEOUL: "BACK TO SEOUL! TIME FOR MORE ADVENTURES!",
                    CHOOSE_BEST_SINGER: "CHOOSE THE BEST SINGER FOR NORAEBANG NIGHT!",
                    SUMMER_NIGHTS: "SUMMER NIGHTS BY THE RIVER...",
                    NEVER_MISS_DRONE: "NEVER MISS A DRONE SHOW",
                    WOW_DONE_LOT: "WOW, WE'VE DONE A LOT...",
                    TIME_COZY: "TIME TO GET COZY! STACK THE FRIENDS ON THE COUCH...",
                    
                    // Level intros
                    FIND_PARTNER: "Find your partner at the end of the river path. Jump over the 6 Pillow Monsters!",
                    PIZZA_SOUNDS_GOOD: "PIZZA SOUNDS GOOD, BUT JAMES IS AT THE TOP OF A MOUNTAIN, HURRY DOWN, BUT DON'T HIT ANY TREES!",
                    TIME_EAT_PIZZA: "TIME TO EAT PIZZA, PICK YOUR CHARACTER",
                    WELCOME_GENIUS: "WELCOME TO THE GENIUS! FIND THE 10s... BUT BE CAREFUL!",
                    CLICK_ZS: "CLICK THE Zs TO KEEP HER AWAKE",
                    BALI_BEAUTIFUL: "Bali is beautiful, let's take a motorcycle ride through the jungle, but don't lose your hat!",
                    SOJU_CORRECTLY: "MAKE SURE YOU DRINK YOUR SOJU CORRECTLY",
                    HELP_BASTE: "TIME FOR CANADIAN THANKSGIVING! HELP JAMES'S MOM BASTE THE TURKEY!",
                    SIGN_LICENSE: "TIME TO MAKE IT OFFICIAL! SIGN THE MARRIAGE LICENSE!",
                    WATCH_OUT_ROMY: "HONEYMOON IN MEXICO! WATCH OUT FOR ROMY IN THE WATER!",
                    HOLD_STILL_BEAR: "A BLACK BEAR ON THE TRAIL! HOLD STILL WHEN IT LOOKS AT YOU!",
                    
                    // Additional story screens
                    PIZZA_QUESTION: 'PIZZA?',
                    PIZZA_WAS_GREAT: "PIZZA WAS GREAT, LET THE DATING BEGIN!",
                    GENIUS_GREAT_SHOW: "THE GENIUS IS A GREAT SHOW TO WATCH TOGETHER",
                    OPEN_10S_PASS: "OPEN THE 10s, PASS THE OTHER NUMBERS",
                    YOU_ARE_GENIUS: "YOU FIGURED IT OUT, YOU ARE A GENIUS! LET'S TAKE A TRIP!",
                    AT_SAIPAN_AIRPORT: "YOU'RE AT THE AIRPORT IN SAIPAN, CLICK THE Zs SO ROMY DOESN'T FALL ASLEEP",
                    COVID_SEPARATED_WORLD: "2020... COVID-19 SEPARATED THE WORLD. THEY COULDN'T SEE EACH OTHER...",
                    FOREST_FIRE_SMOKE: "FOREST FIRE SEASON... THE SMOKE IS THICK. JUMP OVER THE HAZARDS!",
                    EVEN_ACROSS_WORLD: "EVEN ACROSS THE WORLD THEIR CONNECTION STAYED STRONG",
                    PLAN_TRIP_CANADA: "LET'S PLAN A TRIP ACROSS CANADA! SELECT THE PROVINCES YOU'LL VISIT!",
                    GREAT_PLAN_ROAD: "THAT'S A GREAT PLAN, LET'S HIT THE ROAD!",
                    FOREST_FIRE_JUMP: "IT'S FOREST FIRE SEASON, JUMP OVER THE OBSTACLES",
                    WOW_ENCOUNTER: "WOW, WHAT AN ENCOUNTER! GOOD THING WE STAYED CALM.",
                    MOVE_AGAIN_WHERE: "LET'S MOVE AGAIN... BUT WHERE TO?",
                    MOVE_TO_KOREA: "TIME TO MOVE TO KOREA! CATCH THE LETTERS TO SPELL KOREA!",
                    NEW_ADVENTURE: "A NEW ADVENTURE AWAITS!",
                    TIME_NORAEBANG: "TIME FOR NORAEBANG! WHO WANTS TO SING?",
                    AMAZING_PERFORMANCE: "AMAZING PERFORMANCE! TIME FOR MORE FUN!",
                    COZY_EVENING: "TIME TO GET COZY! LET'S RELAX ON THE COUCH..."
                },
                ko: {
                    // Buttons
                    START: '',
                    NEXT: '',
                    YES: '',
                    NO: '',
                    MAIN_MENU: ' ',
                    
                    // Status text
                    SCORE: '',
                    PIZZAS: '',
                    WAKE_UP: '',
                    TIME: '',
                    BASTES: '',
                    
                    // Game states
                    TAP_THE_HAT_NOW: '  !',
                    SAFE: '!',
                    ENJOY_THE_RIDE: '',
                    WAIT_FOR_DAD: ' ...',
                    CHEERS_NOW: '!',
                    EAT: '!',
                    TAP_TO_DROP: ' !',
                    EVERYONE_IS_COZY: ' !',
                    
                    // Level names
                    HAN_RIVER_PARK: '',
                    YONGMASAN: '',
                    CHEESEWICK: '',
                    THE_GENIUS: ' ',
                    SAIPAN_AIRPORT: ' ',
                    BALI_RIDE: ' ',
                    KBBQ: ' ',
                    LETS_MOVE_1: '! 1',
                    THANKSGIVING: '',
                    WANNA_GET_MARRIED: '?',
                    MEXICO: '',
                    LONG_DISTANCE_CALL: ' ',
                    SMOKY_HIGHWAY: '  ',
                    BANFF_ENCOUNTER: ' ',
                    HOSPITAL: '',
                    LETS_MOVE_2: '! 2',
                    NORAEBANG_SHOWDOWN: ' ',
                    STUFFIE_STACK: ' ',
                    HAN_RIVER_DRONE_SHOW: '  ',
                    THE_FOREVER_LOOP: ' ',
                    
                    // Story text
                    THEY_DIDNT_TALK: '    ...     ...',
                    MISSION_SUCCESS: ' !',
                    JAMES_MADE_IT: ' !   .  !',
                    LET_DATING_BEGIN: ' !',
                    PERFECT_STRATEGY: ' !    !',
                    GOOD_THING_AWAKE: ' .    ',
                    HAT_IS_SAFE: '.   ',
                    YOU_SAVED_HAT: ' !',
                    BACK_TO_KOREA: '   !   !',
                    MASTERED_KBBQ: '  .     ...  ?',
                    OFF_TO_CANADA: '   !',
                    FIRST_THANKSGIVING: '   .    !',
                    PERFECT_TURKEY: ' !   ?',
                    DRESS_UP_NICELY: ' ....',
                    OFFICIALLY_MARRIED: ' !',
                    TRIP_TO_MEXICO: '  .    !',
                    WHAT_A_HERO: ' !',
                    COVID_SEPARATED: '19  ...  !',
                    LOVE_NO_DISTANCE: '     !',
                    SMOKY_DESCRIPTION: ' ...  .  !',
                    THROUGH_SMOKE: '     !',
                    BLACK_BEAR: ' !     !',
                    SCARY_BUT_COOL: ' !   .',
                    HOSPITAL_VISIT: '     ...   .',
                    BACK_TO_SEOUL: ' !   !',
                    CHOOSE_BEST_SINGER: '     !',
                    SUMMER_NIGHTS: ' ...',
                    NEVER_MISS_DRONE: '    ',
                    WOW_DONE_LOT: ',     ...',
                    TIME_COZY: ' !   ...',
                    
                    // Level intros
                    FIND_PARTNER: '   . 6   !',
                    PIZZA_SOUNDS_GOOD: '  .     .     !',
                    TIME_EAT_PIZZA: '  .  ',
                    WELCOME_GENIUS: '    ! 10 ...  !',
                    CLICK_ZS: 'Z   ',
                    BALI_BEAUTIFUL: ' .    .   !',
                    SOJU_CORRECTLY: '   ',
                    HELP_BASTE: ' !       !',
                    SIGN_LICENSE: '  !   !',
                    WATCH_OUT_ROMY: ' !   !',
                    HOLD_STILL_BEAR: ' !     !',
                    
                    // Additional story screens
                    PIZZA_QUESTION: '?',
                    PIZZA_WAS_GREAT: ' .  !',
                    GENIUS_GREAT_SHOW: '     ',
                    OPEN_10S_PASS: '10    ',
                    YOU_ARE_GENIUS: '!  !  !',
                    AT_SAIPAN_AIRPORT: '  . Z     ',
                    COVID_SEPARATED_WORLD: '2020... 19  .    ...',
                    FOREST_FIRE_SMOKE: ' ...  .  !',
                    EVEN_ACROSS_WORLD: '     ',
                    PLAN_TRIP_CANADA: '  !   !',
                    GREAT_PLAN_ROAD: ' . !',
                    FOREST_FIRE_JUMP: ' .  ',
                    WOW_ENCOUNTER: ',   !   .',
                    MOVE_AGAIN_WHERE: '  ...  ?',
                    MOVE_TO_KOREA: '  !   KOREA !',
                    NEW_ADVENTURE: '  !',
                    TIME_NORAEBANG: ' !  ?',
                    AMAZING_PERFORMANCE: ' !   !',
                    COZY_EVENING: ' !  ...'
                }
            };
            
            const t = (key) => translations[gameState.language]?.[key] || translations.en[key] || key;
            
            // Helper to translate level names
            const getLevelName = (themeName) => {
                const nameMap = {
                    'HAN RIVER PARK': 'HAN_RIVER_PARK',
                    'YONGMASAN': 'YONGMASAN',
                    'CHEESEWICK': 'CHEESEWICK',
                    'THE GENIUS': 'THE_GENIUS',
                    'SAIPAN AIRPORT': 'SAIPAN_AIRPORT',
                    'BALI RIDE': 'BALI_RIDE',
                    'KBBQ': 'KBBQ',
                    "LET'S MOVE! PART 1": 'LETS_MOVE_1',
                    'THANKSGIVING': 'THANKSGIVING',
                    'WANNA GET MARRIED?': 'WANNA_GET_MARRIED',
                    'MEXICO': 'MEXICO',
                    'THE LONG DISTANCE CALL': 'LONG_DISTANCE_CALL',
                    'THE SMOKY HIGHWAY': 'SMOKY_HIGHWAY',
                    'THE BANFF ENCOUNTER': 'BANFF_ENCOUNTER',
                    'HOSPITAL': 'HOSPITAL',
                    "LET'S MOVE! PART 2": 'LETS_MOVE_2',
                    'NORAEBANG SHOWDOWN': 'NORAEBANG_SHOWDOWN',
                    'THE STUFFIE STACK': 'STUFFIE_STACK',
                    'HAN RIVER DRONE SHOW': 'HAN_RIVER_DRONE_SHOW',
                    'THE FOREVER LOOP': 'THE_FOREVER_LOOP'
                };
                return t(nameMap[themeName] || themeName);
            };
            
            const scaleFactor = dimensions.width < 600 ? 0.6 : 1.0;
            const PLAYER_SIZE = PLAYER_SIZE_BASE * scaleFactor;
            const GROUND_HEIGHT = GROUND_HEIGHT_BASE * scaleFactor;
            const targetXRef = useRef(dimensions.width / 2);
            const mousePosRef = useRef({ x: 0, y: 0 });
            const baliHatRef = useRef({ state: 'attached', flyTimer: 0, saveTimer: 0, screenX: 0, screenY: 0, floatX: 0, floatY: 0, velocityX: 0 });
            const playerRef = useRef({ worldX: 0, x: dimensions.width / 2, y: 0, vy: 0, frame: 0, passedObstacles: new Set(), ritualState: 'WAITING', ritualTimer: 0 });
            const entitiesRef = useRef([]); 
            const isCelebrating = useRef(false);
            const hitZonesRef = useRef({});

            // Initialize Audio Context
            const getAudioContext = () => {
                if (!audioContextRef.current) {
                    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                return audioContextRef.current;
            };

            // Sound Effects
            const playJumpSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.1);
                    
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.1);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playLandSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.08);
                    
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.08);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playCollectSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.05);
                    
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.1);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playMissSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(300, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.15);
                    
                    gain.gain.setValueAtTime(0.15, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.15);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playCardFlipSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.05);
                    
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.08);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playCorrectSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523, ctx.currentTime); // C5
                    osc.frequency.setValueAtTime(659, ctx.currentTime + 0.1); // E5
                    osc.frequency.setValueAtTime(784, ctx.currentTime + 0.2); // G5
                    
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.3);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playWrongSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(150, ctx.currentTime + 0.2);
                    
                    gain.gain.setValueAtTime(0.25, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.2);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playPassSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.1);
                    
                    gain.gain.setValueAtTime(0.15, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.1);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playZClickSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(900, ctx.currentTime + 0.03);
                    osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.08);
                    
                    gain.gain.setValueAtTime(0.25, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.08);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playHatFlySound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sine';
                    // Whooshing upward sound
                    osc.frequency.setValueAtTime(300, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.3);
                    
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.3);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playHatCatchSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'triangle';
                    // Happy catch sound
                    osc.frequency.setValueAtTime(500, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.1);
                    osc.frequency.exponentialRampToValueAtTime(1000, ctx.currentTime + 0.15);
                    
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.15);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playMotorcycleSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    
                    // Create two oscillators for richer engine sound
                    const osc1 = ctx.createOscillator();
                    const osc2 = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(ctx.destination);
                    
                    // Low rumble
                    osc1.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(80, ctx.currentTime);
                    osc1.frequency.setValueAtTime(85, ctx.currentTime + 0.5);
                    osc1.frequency.setValueAtTime(80, ctx.currentTime + 1);
                    
                    // Higher engine tone
                    osc2.type = 'triangle';
                    osc2.frequency.setValueAtTime(160, ctx.currentTime);
                    osc2.frequency.setValueAtTime(170, ctx.currentTime + 0.5);
                    osc2.frequency.setValueAtTime(160, ctx.currentTime + 1);
                    
                    gain.gain.setValueAtTime(0.08, ctx.currentTime);
                    
                    osc1.start(ctx.currentTime);
                    osc2.start(ctx.currentTime);
                    osc1.stop(ctx.currentTime + 1);
                    osc2.stop(ctx.currentTime + 1);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playCheersSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'sine';
                    // Glass clinking sound - bright chime
                    osc.frequency.setValueAtTime(1200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1400, ctx.currentTime + 0.05);
                    osc.frequency.exponentialRampToValueAtTime(1000, ctx.currentTime + 0.15);
                    
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.15);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playEatSound = () => {
                if (isMuted) return;
                try {
                    const ctx = getAudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.type = 'triangle';
                    // Eating/chomping sound - quick descending tone
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.08);
                    
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.08);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            };

            const playOCanadaMelody = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    // Corrected Tempo and Frequencies
                    const notes = [
                        { f: 392.00, d: 0.6 }, // G4 (O...) - Longer
                        { f: 466.16, d: 0.3 }, // Bb4 (...Can-) - Short
                        { f: 466.16, d: 0.8 }, // Bb4 (-a-) - Longest
                        { f: 349.23, d: 0.6 }, // F4 (-da!)
                        { f: 311.13, d: 0.4 }, // Eb4 (Our...)
                        { f: 349.23, d: 0.4 }, // F4 (...home...)
                        { f: 392.00, d: 0.4 }, // G4 (...and...)
                        { f: 415.30, d: 0.4 }, // Ab4 (...na-)
                        { f: 466.16, d: 0.4 }, // Bb4 (-tive...)
                        { f: 349.23, d: 1.0 }  // F4 (...land!) - Hold it
                    ];

                    let time = audioCtx.currentTime;
                    notes.forEach(note => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.type = 'triangle'; // 'triangle' sounds softer and more anthem-like than 'square'
                        osc.frequency.setValueAtTime(note.f, time);
                        
                        gain.gain.setValueAtTime(0.1, time);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + note.d);
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start(time);
                        osc.stop(time + note.d);
                        time += note.d + 0.05; // Small gap between notes
                    });
                } catch (e) { console.log('Audio error:', e); }
            };

            const playAegukgaMelody = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    // Aegukga: "Donghae mulgwa Baekdusan-i..."
                    const notes = [
                        { f: 196.00, d: 0.5 }, // G3 (Dong-)
                        { f: 261.63, d: 0.5 }, // C4 (-hae)
                        { f: 261.63, d: 0.4 }, // C4 (mul-)
                        { f: 293.66, d: 0.4 }, // D4 (-gwa)
                        { f: 329.63, d: 0.6 }, // E4 (Baek-)
                        { f: 261.63, d: 0.3 }, // C4 (-du-)
                        { f: 329.63, d: 0.8 }, // E4 (san-)
                        { f: 392.00, d: 0.3 }, // G4 (-i)
                        { f: 440.00, d: 0.6 }, // A4 (ma-)
                        { f: 392.00, d: 0.4 }, // G4 (-reu-)
                        { f: 329.63, d: 0.4 }, // E4 (-go)
                        { f: 261.63, d: 0.4 }, // C4 (dal-)
                        { f: 293.66, d: 1.2 }  // D4 (-to-rok)
                    ];

                    let time = audioCtx.currentTime;
                    notes.forEach(note => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        // Triangle wave for a softer, orchestral feel
                        osc.type = 'triangle'; 
                        osc.frequency.setValueAtTime(note.f, time);
                        
                        gain.gain.setValueAtTime(0.08, time);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + note.d);
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        
                        osc.start(time);
                        osc.stop(time + note.d);
                        time += note.d + 0.02; // Minimal gap for smoother legato
                    });
                } catch (e) { console.log('Audio error:', e); }
            };

            const playWholeNewWorld = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const notes = [
                        { f: 311.13, d: 0.6 }, // Eb4 (I...)
                        { f: 349.23, d: 0.3 }, // F4 (...can)
                        { f: 392.00, d: 0.8 }, // G4 (show...)
                        { f: 311.13, d: 0.4 }, // Eb4 (...you)
                        { f: 349.23, d: 0.4 }, // F4 (the)
                        { f: 392.00, d: 0.8 }, // G4 (world...)
                        
                        { f: 311.13, d: 0.4 }, // Eb4 (Shi-)
                        { f: 349.23, d: 0.4 }, // F4 (-ning,)
                        { f: 392.00, d: 0.4 }, // G4 (shim-)
                        { f: 415.30, d: 0.4 }, // Ab4 (-mer-)
                        { f: 392.00, d: 0.4 }, // G4 (-ing,)
                        { f: 349.23, d: 0.4 }, // F4 (splen-)
                        { f: 311.13, d: 0.8 }, // Eb4 (-did!)

                        { f: 466.16, d: 0.6 }, // Bb4 (Tell...)
                        { f: 523.25, d: 0.3 }, // C5 (...me)
                        { f: 587.33, d: 0.8 }, // D5 (Prin-...)
                        { f: 466.16, d: 0.4 }, // Bb4 (...cess,)
                        { f: 523.25, d: 0.4 }, // C5 (now)
                        { f: 587.33, d: 0.6 }, // D5 (when)
                        { f: 523.25, d: 0.4 }, // C5 (did)
                        { f: 466.16, d: 0.4 }, // Bb4 (you)
                        { f: 440.00, d: 0.4 }, // A4 (last)
                        { f: 466.16, d: 1.0 }  // Bb4 (let your heart decide?)
                    ];

                    let time = audioCtx.currentTime;
                    notes.forEach(note => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        // 'Triangle' wave provides the softest, most romantic sound
                        osc.type = 'triangle'; 
                        osc.frequency.setValueAtTime(note.f, time);
                        
                        gain.gain.setValueAtTime(0.08, time);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + note.d);
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start(time);
                        osc.stop(time + note.d);
                        time += note.d + 0.05; 
                    });
                } catch (e) { console.log('Audio error:', e); }
            };

            const playBasteSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'triangle';
                    // Squishing/basting sound - descending tone
                    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.2);
                    
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.2);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playBasteFailSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sawtooth';
                    // Failure buzzer
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(120, audioCtx.currentTime + 0.1);
                    
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.3);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playSignatureSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sine';
                    // Pen stroke sound - smooth swoosh
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.15);
                    
                    gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.15);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playWeddingBellSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    // Create harmonics for bell sound
                    const createBell = (freq, time) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, time);
                        
                        gain.gain.setValueAtTime(0.08, time);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.8);
                        
                        osc.start(time);
                        osc.stop(time + 0.8);
                    };
                    
                    // Wedding bells - harmonious tones
                    const time = audioCtx.currentTime;
                    createBell(1047, time); // C6
                    createBell(1319, time + 0.2); // E6
                    createBell(1568, time + 0.4); // G6
                } catch (e) { console.log('Audio error:', e); }
            };

            const playSplashSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sine';
                    // Splash/rescue sound - watery swoosh
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                    
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.3);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playPhoneRingSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    
                    // Create two-tone phone ring
                    const createRingTone = (freq, time) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, time);
                        
                        gain.gain.setValueAtTime(0.15, time);
                        gain.gain.setValueAtTime(0.15, time + 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.3);
                        
                        osc.start(time);
                        osc.stop(time + 0.3);
                    };
                    
                    const time = audioCtx.currentTime;
                    createRingTone(800, time); // High tone
                    createRingTone(600, time + 0.05); // Low tone (slightly delayed)
                } catch (e) { console.log('Audio error:', e); }
            };

            const playPhonePickupSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sine';
                    // Phone pickup - quick ascending beep
                    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                    
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.1);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playCarEngineSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    
                    // Create two oscillators for realistic engine sound
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    // Low rumble + higher engine tone
                    osc1.type = 'sawtooth';
                    osc2.type = 'triangle';
                    osc1.frequency.setValueAtTime(90 + Math.random() * 5, audioCtx.currentTime);
                    osc2.frequency.setValueAtTime(180 + Math.random() * 10, audioCtx.currentTime);
                    
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                    
                    osc1.start(audioCtx.currentTime);
                    osc2.start(audioCtx.currentTime);
                    osc1.stop(audioCtx.currentTime + 0.3);
                    osc2.stop(audioCtx.currentTime + 0.3);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playCarJumpSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sine';
                    // Whoosh sound - ascending then descending
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.2);
                    osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.4);
                    
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.4);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playCarCrashSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sawtooth';
                    // Crash - harsh descending noise
                    osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.3);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playBearGrowlSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sawtooth';
                    // Deep growl
                    osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(70, audioCtx.currentTime + 0.2);
                    osc.frequency.setValueAtTime(85, audioCtx.currentTime + 0.4);
                    
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.5);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playHeartbeatSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    
                    // Two quick beats
                    const beat = (time) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(60, time);
                        
                        gain.gain.setValueAtTime(0.15, time);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.1);
                        
                        osc.start(time);
                        osc.stop(time + 0.1);
                    };
                    
                    const now = audioCtx.currentTime;
                    beat(now);
                    beat(now + 0.15);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playKpopBeat = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    
                    // Kick drum (bass)
                    const kick = () => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                        
                        gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
                        
                        osc.start(audioCtx.currentTime);
                        osc.stop(audioCtx.currentTime + 0.15);
                    };
                    
                    // Snare/clap
                    const snare = (time) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(250, time);
                        
                        gain.gain.setValueAtTime(0.2, time);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.08);
                        
                        osc.start(time);
                        osc.stop(time + 0.08);
                    };
                    
                    // Hi-hat
                    const hihat = (time) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(8000, time);
                        
                        gain.gain.setValueAtTime(0.08, time);
                        gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);
                        
                        osc.start(time);
                        osc.stop(time + 0.05);
                    };
                    
                    const now = audioCtx.currentTime;
                    // Pattern: kick on 1 and 3, snare on 2 and 4, hihats on every eighth
                    kick(); // Beat 1
                    hihat(now + 0.125);
                    snare(now + 0.25); // Beat 2
                    hihat(now + 0.375);
                } catch (e) { console.log('Audio error:', e); }
            };

            const playBadSingingSound = () => {
                if (isMuted) return;
                try {
                    const audioCtx = getAudioContext();
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sawtooth';
                    // Off-key, wavering notes
                    const baseFreq = 300 + Math.random() * 100;
                    osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(baseFreq + 50, audioCtx.currentTime + 0.1);
                    osc.frequency.setValueAtTime(baseFreq - 30, audioCtx.currentTime + 0.2);
                    
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.3);
                } catch (e) { console.log('Audio error:', e); }
            };


            // Initialize menu music
            useEffect(() => {
                geniusMusicRef.current = document.getElementById('geniusMusic');
                canadaMusicRef.current = document.getElementById('canadaMusic');
                koreaMusicRef.current = document.getElementById('koreaMusic');
                level14MusicRef.current = document.getElementById('level14Music');
                level19MusicRef.current = document.getElementById('level19Music');
                level20MusicRef.current = document.getElementById('level20Music');
                if (geniusMusicRef.current) {
                    geniusMusicRef.current.volume = 0.5; // Set volume to 50%
                }
            }, []);

            // Stop all music when leaving gameplay
            useEffect(() => {
                if (gameState.status !== GameStatus.PLAYING) {
                    // Stop all level music when not playing
                    if (geniusMusicRef.current) geniusMusicRef.current.pause();
                    if (canadaMusicRef.current) canadaMusicRef.current.pause();
                    if (koreaMusicRef.current) koreaMusicRef.current.pause();
                    if (level14MusicRef.current) level14MusicRef.current.pause();
                    if (level19MusicRef.current) level19MusicRef.current.pause();
                    if (level20MusicRef.current) level20MusicRef.current.pause();
                }
            }, [gameState.status]);

            // Save unlocked levels to localStorage whenever they change
            useEffect(() => {
                try {
                    localStorage.setItem('unlockedLevels', JSON.stringify(gameState.unlockedLevels));
                } catch (error) {
                    console.error('Failed to save unlocked levels:', error);
                }
            }, [gameState.unlockedLevels]);

            // Handle mute toggle - stop all music when muted
            useEffect(() => {
                if (isMuted) {
                    if (geniusMusicRef.current) geniusMusicRef.current.pause();
                    if (canadaMusicRef.current) canadaMusicRef.current.pause();
                    if (koreaMusicRef.current) koreaMusicRef.current.pause();
                    if (level14MusicRef.current) level14MusicRef.current.pause();
                    if (level19MusicRef.current) level19MusicRef.current.pause();
                    if (level20MusicRef.current) level20MusicRef.current.pause();
                }
            }, [isMuted]);

            useEffect(() => { statusRef.current = gameState.status; }, [gameState.status]);
            
            // Countdown timer - updates every second
            useEffect(() => {
                const updateTimer = () => {
                    const now = new Date();
                    const diff = RELEASE_DATE - now;
                    
                    // Developer bypass: ?dev=true in URL or localStorage
                    const urlParams = new URLSearchParams(window.location.search);
                    const devBypass = urlParams.get('dev') === 'true' || localStorage.getItem('devBypass') === 'true';
                    
                    setTimeUntilRelease(devBypass ? -1 : diff);
                };
                
                updateTimer(); // Initial update
                const interval = setInterval(updateTimer, 1000); // Update every second
                
                return () => clearInterval(interval);
            }, []);

            const loop = useCallback(() => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                if (statusRef.current === GameStatus.PLAYING) {
                    const config = getLevel(gameState.levelNumber);
                    const levelLogic = LevelLibrary[config.type];
                    const context = { 
                        player: playerRef.current, config, gameState, setGameState, 
                        isCelebrating, scaleFactor, dimensions, PLAYER_SIZE, GROUND_HEIGHT,
                        targetX: targetXRef, entities: entitiesRef, baliHat: baliHatRef,
                        mousePos: mousePosRef.current,
                        getGroundY: (wx) => LevelLibrary.platformer.getGroundY(wx, gameState.levelNumber, dimensions.height, scaleFactor, GROUND_HEIGHT),
                        hitZones: hitZonesRef.current,
                        playJumpSound, playLandSound, playCollectSound, playMissSound,
                        playCardFlipSound, playCorrectSound, playWrongSound, playPassSound, playZClickSound,
                        playHatFlySound, playHatCatchSound, playMotorcycleSound, playCheersSound, playEatSound,
                        playOCanadaMelody, playAegukgaMelody, playWholeNewWorld,
                        playBasteSound, playBasteFailSound, playSignatureSound, playWeddingBellSound,
                        playSplashSound, playPhoneRingSound, playPhonePickupSound,
                        playCarEngineSound, playCarJumpSound, playCarCrashSound, playBearGrowlSound, playHeartbeatSound,
                        playKpopBeat, playBadSingingSound,
                        t, // Add translation function to context
                        geniusMusicRef, // Genius level music
                        canadaMusicRef, koreaMusicRef, level14MusicRef, level19MusicRef, level20MusicRef, // Level music refs
                        isMuted // Add isMuted flag
                    };

                    playerRef.current.frame++;
                    ctx.clearRect(0, 0, dimensions.width, dimensions.height);
                    levelLogic.update(context);
                    levelLogic.draw(ctx, context);
                    // Store hit zones for levels that use them (like soju_ceremony)
                    if (config.type === 'soju_ceremony' && context.hitZones) {
                        hitZonesRef.current = context.hitZones;
                    }
                }
                requestRef.current = requestAnimationFrame(loop);
            }, [gameState.levelNumber, dimensions, scaleFactor, PLAYER_SIZE, GROUND_HEIGHT]);

            const isLevelUnlocked = (levelNum) => gameState.unlockedLevels.includes(levelNum);
            const tryUnlockLevel = (levelNum, password) => {
                if (!LEVEL_PASSWORDS[levelNum]) return false;
                if (password.toUpperCase() === LEVEL_PASSWORDS[levelNum]) {
                    setGameState(prev => ({ ...prev, unlockedLevels: [...new Set([...prev.unlockedLevels, levelNum])] }));
                    setPasswordModal({ show: false, levelNumber: null });
                    setPasswordInput('');
                    return true;
                }
                return false;
            };
            const tryMasterPassword = (password) => {
                if (password.toLowerCase() === 'romyandjamy99') {
                    // Unlock all levels
                    setGameState(prev => ({ ...prev, unlockedLevels: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] }));
                    // Bypass timer permanently via localStorage
                    localStorage.setItem('devBypass', 'true');
                    setTimeUntilRelease(-1);
                    setMasterPasswordModal(false);
                    setMasterPasswordInput('');
                    return true;
                }
                return false;
            };
            
            // Gem Digging Game Functions
            const initGemGame = () => {
                const grid = [];
                for (let y = 0; y < 8; y++) {
                    const row = [];
                    for (let x = 0; x < 8; x++) {
                        row.push({ dug: false, hasGem: false });
                    }
                    grid.push(row);
                }
                
                for (let i = 0; i < 8; i++) {
                    const width = Math.floor(Math.random() * 5) + 1;
                    const height = Math.floor(Math.random() * 5) + 1;
                    let placed = false;
                    let attempts = 0;
                    
                    while (!placed && attempts < 100) {
                        const startX = Math.floor(Math.random() * (9 - width));
                        const startY = Math.floor(Math.random() * (9 - height));
                        
                        let canPlace = true;
                        for (let y = startY; y < Math.min(startY + height, 8); y++) {
                            for (let x = startX; x < Math.min(startX + width, 8); x++) {
                                if (grid[y][x].hasGem) {
                                    canPlace = false;
                                    break;
                                }
                            }
                            if (!canPlace) break;
                        }
                        
                        if (canPlace) {
                            for (let y = startY; y < Math.min(startY + height, 8); y++) {
                                for (let x = startX; x < Math.min(startX + width, 8); x++) {
                                    grid[y][x].hasGem = true;
                                }
                            }
                            placed = true;
                        }
                        attempts++;
                    }
                }
                
                let totalGems = 0;
                grid.forEach(row => row.forEach(cell => { if (cell.hasGem) totalGems++; }));
                
                setGemGrid(grid);
                setGemClicks(0);
                setGemsRemaining(totalGems);
                setShowGemGame(true);
            };
            
            const digGemCell = (x, y) => {
                if (!gemGrid || gemGrid[y][x].dug) return;
                
                const newGrid = gemGrid.map(row => row.map(cell => ({ ...cell })));
                newGrid[y][x].dug = true;
                setGemGrid(newGrid);
                setGemClicks(prev => prev + 1);
                
                if (newGrid[y][x].hasGem) {
                    setGemsRemaining(prev => prev - 1);
                }
            };
            
            const safeStartLevel = (levelNum) => {
                if (isLevelUnlocked(levelNum)) {
                    startLevel(levelNum);
                } else {
                    setPasswordModal({ show: true, levelNumber: levelNum });
                    setPasswordInput('');
                }
            };
            const startLevel = (num, forcedChar = null) => {
                const config = getLevel(num);
                const char = forcedChar || config.forcedCharacter || gameState.character;
                
                // Initialize level-specific state
                if (config.type === 'bike_chase') {
                    baliHatRef.current = { state: 'attached', flyTimer: 0, saveTimer: 0, screenX: 0, screenY: 0, floatX: 0, floatY: 0, velocityX: 0 };
                }
                
                const initialX = 0;
                playerRef.current = { 
                    worldX: initialX, x: dimensions.width / 2, 
                    y: (config.type === 'platformer') ? LevelLibrary.platformer.getGroundY(initialX, num, dimensions.height, scaleFactor, GROUND_HEIGHT) - (PLAYER_SIZE * (config?.charScale || 1)) : dimensions.height/2, 
                    vy: 0, frame: 0, passedObstacles: new Set(), ritualState: 'WAITING', ritualTimer: 0, jamesGlassClickTime: null, meatClickTime: null
                };
                targetXRef.current = dimensions.width / 2; entitiesRef.current = []; isCelebrating.current = false;
                setGameState(prev => ({ ...prev, status: GameStatus.PLAYING, levelNumber: num, character: char, score: 0, pizzasCaught: 0, zsTapped: 0, ritualMessage: '' }));
            };

            const handleAction = useCallback((clientX, clientY) => {
                // Track mouse position for forever_loop NO button
                mousePosRef.current = { x: clientX, y: clientY };
                
                const config = getLevel(gameState.levelNumber);
                const player = playerRef.current;
                
                // Handle level-specific interactions by type
                if (config.type === 'soju_ceremony') {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const check = (zone) => zone && clientX >= zone[0] && clientX <= zone[0] + zone[2] && clientY >= zone[1] && clientY <= zone[1] + zone[3];
                    
                    if (player.ritualState === 'CHEERS_WINDOW') {
                        if (check(hitZonesRef.current.jamesGlass)) {
                            // Store when James's glass was clicked to animate it
                            player.jamesGlassClickTime = player.ritualTimer;
                            player.ritualState = 'EATING';
                            playCheersSound(); // Play glass clinking sound
                            // Don't reset ritualTimer - keep it continuous for animation timing
                        }
                    } else if (player.ritualState === 'EATING') {
                        if (check(hitZonesRef.current.jamesLettuce)) {
                            // Track when James's lettuce is clicked
                            if (!player.meatClickTime) {
                                player.meatClickTime = player.ritualTimer;
                                playEatSound(); // Play eating sound
                            }
                        }
                    }
                } else if (config.type === 'bike_chase') {
                    // Car level (Level 13) - jump on click
                    if (config.isCarLevel && !isCelebrating.current && playerRef.current.carObstacles) {
                        // Make car jump higher
                        if (!playerRef.current.isJumping) {
                            playerRef.current.isJumping = true;
                            playerRef.current.jumpVelocity = -20 * scaleFactor; // Higher jump (was -15)
                            playCarJumpSound(); // Jump sound
                        }
                    }
                    // Bali level (Level 5) - catch hat
                    else if (baliHatRef.current.state === 'flying') {
                        const dist = Math.sqrt((baliHatRef.current.screenX - clientX)**2 + (baliHatRef.current.screenY - clientY)**2);
                        if (dist < 180 * scaleFactor) { 
                            baliHatRef.current.state = 'saved'; 
                            baliHatRef.current.saveTimer = player.frame;
                            playHatCatchSound(); // Play catch sound
                        }
                    }
                } else if (config.type === "genius_logic") {
                    if (!isCelebrating.current && playerRef.current.genius) {
                        const g = playerRef.current.genius;
                        
                        // Can't click during animation, result display, or waiting for game over
                        if (g.animatingCard || g.showResult || !g.currentCard || g.waitingForGameOver) return;
                        
                        const checkButton = (btn) => btn && clientX >= btn.x && clientX <= btn.x + btn.w && clientY >= btn.y && clientY <= btn.y + btn.h;
                        
                        if (checkButton(g.openButton)) {
                            // OPEN button clicked - ALWAYS flip the card
                            playCardFlipSound(); // Card flip sound
                            g.cardFlipped = true;
                            
                            if (g.currentCard.value === g.targetNumber) {
                                // Correct!
                                // Start genius music on FIRST CORRECT OPEN only
                                if (!g.musicStarted && geniusMusicRef.current && !isMuted) {
                                    geniusMusicRef.current.play().catch(err => console.log('Audio play prevented:', err));
                                    g.musicStarted = true;
                                }
                                
                                playCorrectSound(); // Success sound
                                g.correctOpens++;
                                
                                // Animate card to bottom (no "ZING!" text)
                                g.animatingCard = { ...g.currentCard };
                                g.currentCard = null;
                            } else {
                                // Wrong - flip card, show it, THEN game over
                                playWrongSound(); // Wrong sound
                                g.resultText = 'WRONG!';
                                g.showResult = true;
                                g.resultTimer = 0;
                                g.waitingForGameOver = true;
                            }
                        } else if (checkButton(g.passButton)) {
                            // PASS button clicked (no music starts here)
                            playPassSound(); // Pass sound
                            g.resultText = 'PASS';
                            g.showResult = true;
                            g.resultTimer = 0;
                        }
                    }
                } else if (config.type === "stealth_engine") {
                    // Hold detection - set holding to true on touch/click
                    if (!isCelebrating.current && playerRef.current.stealth) {
                        playerRef.current.stealth.isHolding = true;
                    }
                } else if (config.type === "noraebang_logic") {
                    if (!isCelebrating.current && playerRef.current.noraebang) {
                        const n = playerRef.current.noraebang;
                        
                        // Only allow choosing if no singer chosen yet
                        if (!n.singerChosen && n.buttonBounds) {
                            // Check if James box clicked
                            if (clientX >= n.buttonBounds.james.x && 
                                clientX <= n.buttonBounds.james.x + n.buttonBounds.james.w &&
                                clientY >= n.buttonBounds.james.y && 
                                clientY <= n.buttonBounds.james.y + n.buttonBounds.james.h) {
                                n.singerChosen = 'james';
                                n.performanceTimer = 0;
                                n.noteParticles = [];
                            }
                            // Check if Romy box clicked
                            else if (clientX >= n.buttonBounds.romy.x && 
                                     clientX <= n.buttonBounds.romy.x + n.buttonBounds.romy.w &&
                                     clientY >= n.buttonBounds.romy.y && 
                                     clientY <= n.buttonBounds.romy.y + n.buttonBounds.romy.h) {
                                n.singerChosen = 'romy';
                                n.performanceTimer = 0;
                                n.noteParticles = [];
                            }
                        }
                    }
                } else if (config.type === "stuffie_stack") {
                    if (!isCelebrating.current && playerRef.current.stuffieStack) {
                        const s = playerRef.current.stuffieStack;
                        
                        // Drop the current stuffie if not already dropping
                        if (!s.isDropping && !s.fallingStuffie && s.currentStuffie < s.stuffieOrder.length) {
                            s.isDropping = true;
                            s.fallingStuffie = {
                                type: s.stuffieOrder[s.currentStuffie],
                                x: s.sliderX,
                                y: dimensions.height * 0.2,
                                vy: 0
                            };
                        }
                    }
                } else if (config.type === 'drone_show') {
                    const d = playerRef.current.droneShow;
                    if (!d || !d.canClick) return;
                    
                    // Toggle logic: If we are displaying a shape, go back to circle. 
                    // If we are in circle, move to the next shape.
                    if (d.state === 'displaying') {
                        d.canClick = false;
                        d.state = 'returning';
                        d.currentShape = (d.currentShape + 1) % d.shapes.length;
                        LevelLibrary.drone_show.setDroneFormation(d, dimensions);
                    } else if (d.state === 'circle') {
                        d.canClick = false;
                        d.state = 'forming';
                        d.currentShape = (d.currentShape + 1) % d.shapes.length;
                        LevelLibrary.drone_show.setDroneFormation(d, dimensions);
                    }
                    
                    // Check for level completion (Final Heart)
                    if (d.shapes[d.currentShape] === 'finalheart' && d.state === 'displaying') {
                        setTimeout(() => {
                            isCelebrating.current = true;
                            setTimeout(() => {
                                setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                            }, 3000);
                        }, 2000);
                    }
                } else if (config.type === 'forever_loop') {
                    const p = playerRef.current;
                    
                    // Check Main Menu button on final screen
                    if (p.showFinal && p.mainMenuButton) {
                        const btn = p.mainMenuButton;
                        if (clientX >= btn.x && clientX <= btn.x + btn.w &&
                            clientY >= btn.y && clientY <= btn.y + btn.h) {
                            // Return to main menu
                            setGameState(prev => ({ ...prev, status: GameStatus.MENU }));
                            return;
                        }
                    }
                    
                    if (!p.showButtons || p.flyingAway) return;
                    
                    // Check YES button click (fixed position)
                    const yesX = dimensions.width * 0.35;
                    const yesY = dimensions.height * 0.65;
                    if (clientX >= yesX && clientX <= yesX + 100 &&
                        clientY >= yesY && clientY <= yesY + 40) {
                        // Fly away!
                        p.flyingAway = true;
                    }
                    
                    // NO button does nothing - it just runs away!
                } else if (config.type === "catching") { 
                    if (!isCelebrating.current) targetXRef.current = Math.max(0, Math.min(dimensions.width, clientX)); 
                } else if (config.type === "letter_catch") {
                    if (!isCelebrating.current) targetXRef.current = Math.max(0, Math.min(dimensions.width, clientX));
                } else if (config.type === "basting_game") {
                    if (!isCelebrating.current && playerRef.current.bastingState && !playerRef.current.bastingState.isRestarting && playerRef.current.bastingState.canClick) {
                        const state = playerRef.current.bastingState;
                        
                        // Disable clicking temporarily
                        state.canClick = false;
                        state.clickCooldown = 0;
                        
                        // Calculate green zone threshold based on current size
                        const greenZoneThreshold = 1 - state.greenZoneSize;
                        
                        // Check if slider is in green zone (dynamic size)
                        if (state.sliderPosition >= greenZoneThreshold) {
                            // Success!
                            state.successfulBastes++;
                            state.showFeedback = true;
                            state.feedbackText = 'PERFECT!';
                            state.feedbackTimer = 0;
                            playBasteSound(); // Play basting sound
                            
                            // Reduce green zone for next baste
                            state.greenZoneSize = Math.max(0.1, state.greenZoneSize - 0.025); // Shrink green zone (minimum 10%)
                        } else {
                            // Failed - restart from beginning
                            state.showFeedback = true;
                            state.feedbackText = 'YOU FAILED TO BASTE THE TURKEY';
                            state.feedbackTimer = 0;
                            state.isRestarting = true;
                            playBasteFailSound(); // Play fail sound
                        }
                    }
                } else if (config.type === "city_hall_wedding") {
                    if (!isCelebrating.current && playerRef.current.weddingState && playerRef.current.weddingState.canClick && !playerRef.current.weddingState.showFeedback) {
                        const state = playerRef.current.weddingState;
                        const rect = canvasRef.current.getBoundingClientRect();
                        
                        state.canClick = false;
                        state.clickCooldown = 0;
                        
                        if (state.step === 0) {
                            // YES/NO buttons
                            const checkButton = (btn) => btn && clientX >= btn[0] && clientX <= btn[0] + btn[2] && clientY >= btn[1] && clientY <= btn[1] + btn[3];
                            
                            if (checkButton(state.yesButton)) {
                                // Clicked YES - SUCCESS!
                                state.step = 1;
                                state.textPosition = 0.5;
                                state.showFeedback = true;
                                state.feedbackText = 'SUCCESS!';
                                state.feedbackTimer = 0;
                                playWeddingBellSound(); // Play wedding bells!
                            } else if (checkButton(state.noButton)) {
                                // Clicked NO - FAIL!
                                state.showFeedback = true;
                                state.feedbackText = 'FAILED!';
                                state.feedbackTimer = 0;
                                setTimeout(() => {
                                    setGameState(prev => ({ ...prev, status: GameStatus.GAMEOVER, deathReason: 'said no' }));
                                }, 1500);
                            }
                        } else if (state.step === 1) {
                            // JAMES ROMANEK alignment
                            if (state.textPosition >= 0.45 && state.textPosition <= 0.55) {
                                // Success!
                                state.step = 2;
                                state.textPosition = 0.5;
                                state.showFeedback = true;
                                state.feedbackText = 'PERFECT!';
                                state.feedbackTimer = 0;
                                playSignatureSound(); // Play pen stroke sound
                            } else {
                                // Missed
                                state.showFeedback = true;
                                state.feedbackText = 'MISSED!';
                                state.feedbackTimer = 0;
                            }
                        } else if (state.step === 2) {
                            //  alignment
                            if (state.textPosition >= 0.45 && state.textPosition <= 0.55) {
                                // Success! Start 4-second transition delay
                                state.textPosition = 0.5;
                                state.showFeedback = true;
                                state.feedbackText = 'PERFECT!';
                                state.feedbackTimer = 0;
                                state.transitionDelay = true;
                                state.transitionTimer = 0;
                                playSignatureSound(); // Play pen stroke sound
                            } else {
                                // Missed
                                state.showFeedback = true;
                                state.feedbackText = 'MISSED!';
                                state.feedbackTimer = 0;
                            }
                        }
                    }
                } else if (config.type === "mexican_rescue") {
                    if (!isCelebrating.current && playerRef.current.mx) {
                        const mx = playerRef.current.mx;
                        if (mx.phase === 'drown') {
                            mx.phase = 'slide';
                            mx.timer = 0;
                            playSplashSound(); // Play splash/rescue sound
                        }
                    }
                } else if (config.type === "phone_call") {
                    if (!isCelebrating.current && playerRef.current.phone) {
                        const p = playerRef.current.phone;
                        if (p.phase === 'ringing' && p.buttonY) {
                            // Check if clicked on ACCEPT button
                            const buttonW = 120 * scaleFactor;
                            const buttonH = 40 * scaleFactor;
                            const buttonX = dimensions.width * 0.5 - buttonW / 2;
                            const buttonY = p.buttonY;
                            
                            if (clientX >= buttonX && clientX <= buttonX + buttonW &&
                                clientY >= buttonY && clientY <= buttonY + buttonH) {
                                p.phase = 'answered';
                                playPhonePickupSound(); // Play pickup sound
                            }
                        }
                    }
                } else if (config.type === "road_trip") {
                    if (!isCelebrating.current && playerRef.current.provinceSelect) {
                        const ps = playerRef.current.provinceSelect;
                        
                        // Don't allow clicks during error display
                        if (ps.showError) return;
                        
                        // Check which province was clicked
                        if (ps.provinceButtons) {
                            let clickedProvince = null;
                            for (const [province, bounds] of Object.entries(ps.provinceButtons)) {
                                if (clientX >= bounds.x && clientX <= bounds.x + bounds.w &&
                                    clientY >= bounds.y && clientY <= bounds.y + bounds.h) {
                                    clickedProvince = province;
                                    break;
                                }
                            }
                            
                            if (clickedProvince) {
                                // Don't allow clicking already selected provinces
                                if (ps.clickedProvinces.includes(clickedProvince)) return;
                                
                                // Check if this province is correct
                                if (ps.correctProvinces.includes(clickedProvince)) {
                                    // Correct! Add to clicked list
                                    ps.clickedProvinces.push(clickedProvince);
                                } else {
                                    // Wrong! Show error and restart
                                    ps.clickedProvinces.push(clickedProvince);
                                    ps.showError = true;
                                    ps.errorTimer = 0;
                                }
                            }
                        }
                    }
                } else if (config.type === "wakeup") {
                    let hit = false;
                    entitiesRef.current = entitiesRef.current.filter(z => {
                        if (Math.sqrt((z.x - clientX)**2 + (z.y - clientY)**2) < 60 * scaleFactor) { 
                            hit = true; 
                            return false; 
                        }
                        return true;
                    });
                    if (hit) {
                        playZClickSound(); // Play pop sound when clicking Z
                        setGameState(prev => {
                            const newVal = prev.zsTapped + 1;
                            if (newVal >= 10) {
                                isCelebrating.current = true;
                                const level = getLevel(gameState.levelNumber);
                                setTimeout(() => {
                                    if (level.nextLevelStory) {
                                        setGameState(s => ({ ...s, status: `LEVEL_${s.levelNumber}_COMPLETE_STORY` }));
                                    } else {
                                        setGameState(s => ({ ...s, status: GameStatus.LEVEL_COMPLETE }));
                                    }
                                }, 2500);
                            }
                            return { ...prev, zsTapped: newVal };
                        });
                    }
                } else if (config.type === 'platformer') {
                    const gy = LevelLibrary.platformer.getGroundY(player.worldX, gameState.levelNumber, dimensions.height, scaleFactor, GROUND_HEIGHT);
                    if (player.y + (PLAYER_SIZE * config.charScale) >= gy - 10) {
                        player.vy = config.jumpForce;
                        playJumpSound(); // Play jump sound
                    }
                }
            }, [gameState.levelNumber, dimensions, scaleFactor, PLAYER_SIZE, GROUND_HEIGHT]);

            useEffect(() => {
                const handleResize = () => { setDimensions({ width: window.innerWidth, height: window.innerHeight }); if (canvasRef.current) { canvasRef.current.width = window.innerWidth; canvasRef.current.height = window.innerHeight; }};
                window.addEventListener('resize', handleResize); handleResize();
                const handlePointer = (e) => {
                    if (!canvasRef.current) return;
                    const rect = canvasRef.current.getBoundingClientRect();
                    const clientXRaw = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX);
                    const clientYRaw = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY);
                    
                    // If we don't have valid coordinates, bail out
                    if (clientXRaw === undefined || clientYRaw === undefined) return;
                    
                    const x = clientXRaw - rect.left;
                    const y = clientYRaw - rect.top;
                    if (statusRef.current === GameStatus.PLAYING) handleAction(x, y);
                };
                const handlePointerMove = (e) => {
                    if (!canvasRef.current) return;
                    const rect = canvasRef.current.getBoundingClientRect();
                    const clientXRaw = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX);
                    const clientYRaw = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY);
                    
                    // If we don't have valid coordinates, bail out
                    if (clientXRaw === undefined || clientYRaw === undefined) return;
                    
                    const x = clientXRaw - rect.left;
                    const y = clientYRaw - rect.top;
                    
                    // Always track mouse position for forever_loop NO button
                    mousePosRef.current = { x, y };
                    
                    if (statusRef.current === GameStatus.PLAYING) {
                        const level = getLevel(gameState.levelNumber);
                        if (level.type === 'catching' || level.type === 'letter_catch') {
                            // Clamp targetX to screen bounds to prevent character going off-screen
                            targetXRef.current = Math.max(0, Math.min(dimensions.width, x));
                        }
                    }
                };
                const handlePointerRelease = () => {
                    // Release handler for stealth level
                    if (statusRef.current === GameStatus.PLAYING) {
                        const config = getLevel(gameState.levelNumber);
                        if (config.type === 'stealth_engine' && playerRef.current.stealth) {
                            playerRef.current.stealth.isHolding = false;
                        }
                    }
                };
                window.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'ArrowUp') handleAction(); });
                window.addEventListener('mousedown', handlePointer); 
                window.addEventListener('touchstart', handlePointer);
                window.addEventListener('mouseup', handlePointerRelease);
                window.addEventListener('touchend', handlePointerRelease);
                window.addEventListener('mousemove', handlePointerMove);
                window.addEventListener('touchmove', handlePointerMove);
                requestRef.current = requestAnimationFrame(loop);
                return () => { 
                    window.removeEventListener('resize', handleResize); 
                    window.removeEventListener('mousedown', handlePointer);
                    window.removeEventListener('touchstart', handlePointer);
                    window.removeEventListener('mouseup', handlePointerRelease);
                    window.removeEventListener('touchend', handlePointerRelease);
                    window.removeEventListener('mousemove', handlePointerMove);
                    window.removeEventListener('touchmove', handlePointerMove);
                    cancelAnimationFrame(requestRef.current); 
                };
            }, [loop, handleAction, gameState.levelNumber]);

            const pizzaGoal = gameState.character === 'male' ? 20 : 4;
            const btnClass = "bg-[#f43f5e] px-8 py-4 md:px-12 md:py-6 border-4 border-white shadow-[0_6px_0_0_#991b1b] active:translate-y-1 active:shadow-none transition-all text-[10px] md:text-sm uppercase";

            return (
                <div className="w-screen h-screen bg-[#0c0a1f] flex items-center justify-center overflow-hidden text-white select-none relative" style={{ fontFamily: "'Press Start 2P', cursive" }}>
                    {/* Mute button - show on menu and level select */}
                    {(gameState.status === GameStatus.MENU || gameState.status === GameStatus.LEVEL_SELECT) && (
                        <button 
                            onClick={() => setIsMuted(!isMuted)} 
                            className="mute-button"
                        >
                            {isMuted ? ' UNMUTE' : ' MUTE'}
                        </button>
                    )}
                    <canvas ref={canvasRef} className="fixed inset-0 w-full h-full z-0" />
                    {gameState.status === GameStatus.PLAYING && (() => {
                        const level = getLevel(gameState.levelNumber);
                        let statusText = `${t('SCORE')}: ${String(gameState.score).padStart(6, '0')}`;
                        
                        // Level-specific status text
                        if (level.type === 'catching') {
                            statusText = `${t('PIZZAS')}: ${gameState.pizzasCaught} / ${pizzaGoal}`;
                        } else if (level.type === 'wakeup') {
                            statusText = `${t('WAKE_UP')}: ${gameState.zsTapped} / 10`;
                        } else if (level.type === 'bike_chase') {
                            // Car level (Level 13) - show timer
                            if (level.isCarLevel) {
                                const surviveTime = level.surviveTime || 45;
                                const timeRemaining = Math.max(0, surviveTime - Math.floor(playerRef.current.frame / 60));
                                statusText = `${t('TIME')}: ${timeRemaining}s`;
                            } else {
                                // Bali level (Level 5) - hat status
                                statusText = baliHatRef.current.state === 'flying' ? t('TAP_THE_HAT_NOW') : 
                                            (baliHatRef.current.state === 'saved' ? t('SAFE') : t('ENJOY_THE_RIDE'));
                            }
                        } else if (level.type === 'soju_ceremony') {
                            statusText = playerRef.current.ritualState === 'WAITING' ? t('WAIT_FOR_DAD') : 
                                        (playerRef.current.ritualState === 'CHEERS_WINDOW' ? t('CHEERS_NOW') : t('EAT'));
                        } else if (level.type === 'letter_catch') {
                            // No status text for letter_catch - progress is shown in the boxes
                            statusText = null;
                        } else if (level.type === 'genius_logic') {
                            const state = playerRef.current.genius || { correctOpens: 0 };
                            const required = 5;
                            statusText = `${t('SCORE')}: ${state.correctOpens} / ${required}`;
                        } else if (level.type === 'basting_game') {
                            const state = playerRef.current.bastingState || { successfulBastes: 0 };
                            const bastesRequired = level.bastesRequired || 5;
                            statusText = `${t('BASTES')}: ${state.successfulBastes} / ${bastesRequired}`;
                        } else if (level.type === 'city_hall_wedding') {
                            // No status text needed for wedding level
                            statusText = null;
                        } else if (level.type === 'mexican_rescue') {
                            // No status text needed for mexican rescue level
                            statusText = null;
                        } else if (level.type === 'phone_call') {
                            // No status text needed for phone call level
                            statusText = null;
                        } else if (level.type === 'road_trip') {
                            // No status text needed for road trip level
                            statusText = null;
                        } else if (level.type === 'stealth_engine') {
                            // No status text needed - fear meter and instructions shown in-game
                            statusText = null;
                        } else if (level.type === 'noraebang_logic') {
                            // No status text needed - clean karaoke interface
                            statusText = null;
                        } else if (level.type === 'stuffie_stack') {
                            // No status text needed - clean stuffie stacking
                            statusText = null;
                        } else if (level.type === 'drone_show') {
                            // No status text needed - clean night sky
                            statusText = null;
                        } else if (level.type === 'forever_loop') {
                            // No status text needed - memory reel
                            statusText = null;
                        }
                        
                        return (
                            <div className="fixed top-4 md:top-8 left-0 right-0 px-4 md:px-8 flex flex-col md:flex-row justify-between items-center gap-2 z-40 pointer-events-none w-full max-w-5xl mx-auto">
                                <div className="bg-black/50 backdrop-blur-sm p-2 md:p-4 border-2 border-white/30 rounded-lg w-full md:w-auto text-center">
                                    <span className="text-[#f43f5e] text-[8px] md:text-xs uppercase">{getLevelName(level.themeName)}</span>
                                </div>
                                {statusText && (
                                    <div className="bg-black/50 backdrop-blur-sm p-2 md:p-4 border-2 border-white/30 rounded-lg w-full md:w-auto text-center">
                                        <span className="text-white text-[8px] md:text-xs">{statusText}</span>
                                </div>
                                )}
                            </div>
                        );
                    })()}
                    {gameState.status === GameStatus.SPLASH && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center z-50 bg-[#0c0a1f] p-4 text-center">
                            <h1 className="text-5xl md:text-7xl font-black mb-8 text-[#f43f5e] italic animate-pulse" style={{ textShadow: '6px 6px 0px #000' }}>JAROMY</h1>
                            
                            {/* James and Romy pixel art - clickable for master password */}
                            <div className="flex gap-8 md:gap-16 mb-12">
                                <button onClick={() => setMasterPasswordModal(true)} className="flex flex-col items-center hover:opacity-80 transition-opacity">
                                    <AvatarCanvas char="male" />
                                    <span className="text-[10px] md:text-sm mt-2 text-white font-bold">JAMES</span>
                                </button>
                                <button onClick={() => setMasterPasswordModal(true)} className="flex flex-col items-center hover:opacity-80 transition-opacity">
                                    <AvatarCanvas char="female" />
                                    <span className="text-[10px] md:text-sm mt-2 text-white font-bold">ROMY</span>
                                </button>
                            </div>
                            
                            {/* GO Button */}
                            <button 
                                onClick={() => {
                                    // No music on menu anymore - removed
                                    setGameState(prev => ({ ...prev, status: GameStatus.MENU }));
                                }} 
                                className={`${btnClass} text-xl md:text-2xl px-16 py-6 animate-bounce`}>
                                GO!
                            </button>
                            
                            {/* Master Password Button - subtle */}
                            <button 
                                onClick={() => setMasterPasswordModal(true)}
                                className="mt-8 text-[8px] md:text-[10px] opacity-30 hover:opacity-60 transition-opacity uppercase">
                                Master Password
                            </button>
                        </div>
                    )}
                    {gameState.status === GameStatus.MENU && (
                        <div className="flex flex-col items-center justify-center z-50 p-4 text-center">
                            <h1 className="text-4xl md:text-6xl font-black mb-12 text-[#f43f5e] italic" style={{ textShadow: '4px 4px 0px #000' }}>JAROMY</h1>
                            
                            {timeUntilRelease !== null && timeUntilRelease > 0 ? (
                                // LOCKED - Show countdown
                                <div className="flex flex-col items-center gap-6">
                                    <div className="text-6xl mb-4"></div>
                                    <p className="text-sm md:text-base mb-4 uppercase text-center">Anniversary Game<br/>Level One Unlocks In:</p>
                                    <div className="bg-slate-800 border-4 border-white p-6 rounded-lg">
                                        <div className="text-3xl md:text-5xl font-black text-[#f43f5e]">
                                            {Math.floor(timeUntilRelease / (1000 * 60 * 60 * 24))}d {Math.floor((timeUntilRelease % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))}h {Math.floor((timeUntilRelease % (1000 * 60 * 60)) / (1000 * 60))}m {Math.floor((timeUntilRelease % (1000 * 60)) / 1000)}s
                                        </div>
                                    </div>
                                    <p className="text-xs md:text-sm mt-4 opacity-70">February 21, 2026 at 12:00 PM</p>
                                    
                                    {/* Gem Digging Button */}
                                    <button 
                                        onClick={() => initGemGame()}
                                        className="mt-6 bg-amber-700 hover:bg-amber-600 px-6 py-3 border-2 border-amber-400 text-white text-xs uppercase transition-colors">
                                         Play Gem Digging
                                    </button>
                                </div>
                            ) : (
                                // UNLOCKED - Show buttons
                                <div className="flex flex-col gap-4 w-full max-w-xs">
                                    <button onClick={() => setGameState(prev => ({ ...prev, status: GameStatus.SELECT_CHAR }))} className={btnClass}>
                                        {gameState.language === 'ko' ? ' ' : 'START MISSION'}
                                    </button>
                                    <button onClick={() => setGameState(prev => ({ ...prev, status: GameStatus.LEVEL_SELECT }))} className="bg-slate-700 px-8 py-3 md:py-4 border-4 border-white text-[10px] md:text-sm">
                                        {gameState.language === 'ko' ? ' ' : 'SELECT MISSION'}
                                    </button>
                                    
                                    {/* Language Selection */}
                                    <div className="flex gap-2 mt-8 justify-center">
                                        <button 
                                            onClick={() => setGameState(prev => ({ ...prev, language: 'en' }))} 
                                            className={`px-4 py-2 border-2 text-[10px] md:text-xs ${gameState.language === 'en' ? 'bg-[#f43f5e] border-white' : 'bg-slate-700 border-slate-500'}`}>
                                            ENGLISH
                                        </button>
                                        <button 
                                            onClick={() => setGameState(prev => ({ ...prev, language: 'ko' }))} 
                                            className={`px-4 py-2 border-2 text-[10px] md:text-xs ${gameState.language === 'ko' ? 'bg-[#f43f5e] border-white' : 'bg-slate-700 border-slate-500'}`}>
                                            
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                    {gameState.status === GameStatus.SELECT_CHAR && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center z-50 bg-[#0c0a1f] p-4">
                            <h2 className="text-sm md:text-xl mb-12 uppercase">
                                {gameState.language === 'ko' ? ' ' : 'CHOOSE A CHARACTER'}
                            </h2>
                            <div className="flex flex-col md:flex-row gap-6 md:gap-12">
                                <button onClick={() => setGameState(prev => ({ ...prev, character: 'male', status: GameStatus.STORY_INTRO }))} className="flex flex-col items-center gap-2"><AvatarCanvas char="male" /><span className="text-[10px] md:text-xs font-bold">JAMES</span></button>
                                <button onClick={() => setGameState(prev => ({ ...prev, character: 'female', status: GameStatus.STORY_INTRO }))} className="flex flex-col items-center gap-2"><AvatarCanvas char="female" /><span className="text-[10px] md:text-xs font-bold">ROMY</span></button>
                            </div>
                        </div>
                    )}
                    {gameState.status === GameStatus.LEVEL_SELECT && (
                        <div className="absolute inset-0 flex flex-col z-50 bg-[#0c0a1f] overflow-y-auto custom-scroll">
                            <div className="flex-shrink-0 pt-8 pb-4 px-4 text-center sticky top-0 bg-[#0c0a1f] z-10">
                                <h2 className="text-sm md:text-xl text-[#f43f5e]">
                                    {gameState.language === 'ko' ? ' ' : 'SELECT MISSION'}
                                </h2>
                            </div>
                            <div className="flex-1 px-4 pb-20">
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-3xl mx-auto mb-8">
                                    {getAllLevelNumbers().map(num => {
                                        const level = getLevel(num);
                                        const unlocked = isLevelUnlocked(num);
                                        return (
                                            <button key={num} onClick={() => {
                                                if (!unlocked) {
                                                    setPasswordModal({ show: true, levelNumber: num });
                                                    setPasswordInput('');
                                                } else if (num === 1) {
                                                    setGameState(prev => ({ ...prev, status: GameStatus.STORY_INTRO }));
                                                } else if (level.requiresCharSelect) {
                                                    setGameState(prev => ({ ...prev, status: `LEVEL_${num}_CHAR_SELECT` }));
                                                } else {
                                                    startLevel(num);
                                                }
                                            }} className={`p-4 md:p-6 border-4 border-white hover:bg-[#f43f5e] transition-colors flex flex-col items-center gap-2 ${unlocked ? 'bg-slate-800' : 'bg-slate-900 opacity-60'}`}>
                                                <span className="text-[8px] md:text-[10px] opacity-50 font-bold">LEVEL {num}</span>
                                                {!unlocked && <span className="text-2xl"></span>}
                                                <span className={`text-[10px] md:text-xs ${!unlocked ? 'blur-sm select-none' : ''}`}>
                                                    {getLevelName(level.themeName)}
                                                </span>
                                                {!unlocked && <span className="text-[8px] opacity-60">ENTER CODE</span>}
                                            </button>
                                        );
                                    })}
                                </div>
                                <div className="flex justify-center mt-6">
                                    <button onClick={() => setGameState(prev => ({ ...prev, status: GameStatus.MENU }))} className="bg-slate-700 px-8 py-3 md:py-4 border-4 border-white text-[10px] md:text-sm uppercase hover:bg-slate-600 transition-colors">BACK</button>
                                </div>
                            </div>
                        </div>
                    )}
                    {/* Story screens - dynamically generated from level definitions */}
                    {(() => {
                        // Check if this is a story status
                        let storyText = null;
                        let nextAction = null;
                        let bgColor = '#0f172a';
                        let showYesNo = false;
                        
                        // Level intro (first level)
                        if (gameState.status === GameStatus.STORY_INTRO) {
                            storyText = t('FIND_PARTNER');
                            nextAction = () => safeStartLevel(1);
                        }
                        // Level 1 completion -> "THEY DIDN'T TALK..." screen
                        else if (gameState.status === 'LEVEL_1_COMPLETE_STORY') {
                            storyText = t('THEY_DIDNT_TALK');
                            nextAction = () => setGameState(s => ({ ...s, status: 'PIZZA_DECISION' }));
                        }
                        // Pizza decision screen (yellow background with yes/no buttons)
                        else if (gameState.status === 'PIZZA_DECISION') {
                            storyText = t('PIZZA_QUESTION');
                            bgColor = '#fbbf24'; // yellow background
                            showYesNo = true;
                        }
                        // Level 2 intro after saying yes to pizza
                        else if (gameState.status === 'LEVEL_2_INTRO') {
                            storyText = t('PIZZA_SOUNDS_GOOD');
                            nextAction = () => safeStartLevel(2);
                        }
                        // Level 2 completion
                        else if (gameState.status === 'LEVEL_2_COMPLETE_STORY') {
                            storyText = t('JAMES_MADE_IT');
                            nextAction = () => {
                                if (isLevelUnlocked(3)) {
                                    setGameState(s => ({ ...s, status: 'LEVEL_3_CHAR_SELECT' }));
                                } else {
                                    setPasswordModal({ show: true, levelNumber: 3 });
                                    setPasswordInput('');
                                }
                            };
                        }
                        // Level 3 (Pizza) completion -> "PIZZA WAS GREAT"
                        else if (gameState.status === 'LEVEL_3_COMPLETE_STORY') {
                            storyText = t('PIZZA_WAS_GREAT');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_4_PRE_INTRO_1' }));
                        }
                        // Level 4 pre-intro screen 1
                        else if (gameState.status === 'LEVEL_4_PRE_INTRO_1') {
                            storyText = t('GENIUS_GREAT_SHOW');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_4_PRE_INTRO_2' }));
                        }
                        // Level 4 pre-intro screen 2 (instructions)
                        else if (gameState.status === 'LEVEL_4_PRE_INTRO_2') {
                            storyText = t('OPEN_10S_PASS');
                            nextAction = () => safeStartLevel(4);
                        }
                        // Level 4 (Genius) completion -> "YOU'RE A GENIUS"
                        else if (gameState.status === 'LEVEL_4_COMPLETE_STORY') {
                            storyText = t('YOU_ARE_GENIUS');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_5_PRE_INTRO' }));
                        }
                        // Level 5 (Saipan) pre-intro
                        else if (gameState.status === 'LEVEL_5_PRE_INTRO') {
                            storyText = t('AT_SAIPAN_AIRPORT');
                            nextAction = () => safeStartLevel(5);
                        }
                        // Level 5 (Saipan) completion
                        else if (gameState.status === 'LEVEL_5_COMPLETE_STORY') {
                            storyText = t('GOOD_THING_AWAKE');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_6_INTRO' }));
                        }
                        // Level 6 (Bali) intro
                        else if (gameState.status === 'LEVEL_6_INTRO') {
                            storyText = t('BALI_BEAUTIFUL');
                            nextAction = () => safeStartLevel(6);
                        }
                        // Level 6 (Bali) completion -> "YOU SAVED THE HAT"
                        else if (gameState.status === 'LEVEL_6_COMPLETE_STORY') {
                            storyText = t('YOU_SAVED_HAT');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_7_PRE_INTRO' }));
                        }
                        // Level 7 (KBBQ) pre-intro
                        else if (gameState.status === 'LEVEL_7_PRE_INTRO') {
                            storyText = t('BACK_TO_KOREA');
                            nextAction = () => safeStartLevel(7);
                        }
                        // Level 7 (KBBQ) completion
                        else if (gameState.status === 'LEVEL_7_COMPLETE_STORY') {
                            storyText = t('MASTERED_KBBQ');
                            nextAction = () => safeStartLevel(8);
                        }
                        // Level 8 (CANADA letters) completion -> "OFF TO CANADA"
                        else if (gameState.status === 'LEVEL_8_COMPLETE_STORY') {
                            storyText = t('OFF_TO_CANADA');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_9_PRE_INTRO' }));
                        }
                        // Level 9 (Thanksgiving) pre-intro
                        else if (gameState.status === 'LEVEL_9_PRE_INTRO') {
                            storyText = t('FIRST_THANKSGIVING');
                            nextAction = () => safeStartLevel(9);
                        }
                        // Level 9 (Thanksgiving) completion -> "PERFECT TURKEY"
                        else if (gameState.status === 'LEVEL_9_COMPLETE_STORY') {
                            storyText = t('PERFECT_TURKEY');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_10_PRE_INTRO' }));
                        }
                        // Level 10 (Wedding) pre-intro
                        else if (gameState.status === 'LEVEL_10_PRE_INTRO') {
                            storyText = t('DRESS_UP_NICELY');
                            nextAction = () => safeStartLevel(10);
                        }
                        // Level 10 (Wedding) completion -> "YOU'RE OFFICIALLY MARRIED!"
                        else if (gameState.status === 'LEVEL_10_COMPLETE_STORY') {
                            storyText = t('OFFICIALLY_MARRIED');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_11_PRE_INTRO' }));
                        }
                        // Level 11 (Mexico) pre-intro
                        else if (gameState.status === 'LEVEL_11_PRE_INTRO') {
                            storyText = t('TRIP_TO_MEXICO');
                            nextAction = () => safeStartLevel(11);
                        }
                        // Level 11 (Mexico) completion
                        else if (gameState.status === 'LEVEL_11_COMPLETE_STORY') {
                            storyText = t('WHAT_A_HERO');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_12_PRE_INTRO' }));
                        }
                        // Level 12 (Phone Call) pre-intro
                        else if (gameState.status === 'LEVEL_12_PRE_INTRO') {
                            storyText = t('COVID_SEPARATED_WORLD');
                            nextAction = () => safeStartLevel(12);
                        }
                        // Level 12 (Phone Call) completion -> "EVEN ACROSS THE WORLD"
                        else if (gameState.status === 'LEVEL_12_COMPLETE_STORY') {
                            storyText = t('EVEN_ACROSS_WORLD');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_13_PRE_INTRO' }));
                        }
                        // Level 13 (Road Trip) pre-intro
                        else if (gameState.status === 'LEVEL_13_PRE_INTRO') {
                            storyText = t('PLAN_TRIP_CANADA');
                            nextAction = () => safeStartLevel(13);
                        }
                        // Level 13 (Road Trip) completion -> "THAT'S A GREAT PLAN"
                        else if (gameState.status === 'LEVEL_13_COMPLETE_STORY') {
                            storyText = t('GREAT_PLAN_ROAD');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_14_PRE_INTRO' }));
                        }
                        // Level 14 (Smoky Highway) pre-intro
                        else if (gameState.status === 'LEVEL_14_PRE_INTRO') {
                            storyText = t('FOREST_FIRE_JUMP');
                            nextAction = () => safeStartLevel(14);
                        }
                        // Level 14 (Smoky Highway) completion
                        else if (gameState.status === 'LEVEL_14_COMPLETE_STORY') {
                            storyText = t('THROUGH_SMOKE');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_15_PRE_INTRO' }));
                        }
                        // Level 15 (Banff Bear) pre-intro
                        else if (gameState.status === 'LEVEL_15_PRE_INTRO') {
                            storyText = t('HOLD_STILL_BEAR');
                            nextAction = () => safeStartLevel(15);
                        }
                        // Level 15 (Banff Bear) completion
                        else if (gameState.status === 'LEVEL_15_COMPLETE_STORY') {
                            storyText = t('WOW_ENCOUNTER');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_15_TO_16_TRANSITION' }));
                        }
                        // Level 15 to 16 transition
                        else if (gameState.status === 'LEVEL_15_TO_16_TRANSITION') {
                            storyText = t('MOVE_AGAIN_WHERE');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_16_PRE_INTRO' }));
                        }
                        // Level 16 (Korea Move) pre-intro
                        else if (gameState.status === 'LEVEL_16_PRE_INTRO') {
                            storyText = t('MOVE_TO_KOREA');
                            nextAction = () => safeStartLevel(16);
                        }
                        // Level 16 (Korea Move) completion
                        else if (gameState.status === 'LEVEL_16_COMPLETE_STORY') {
                            storyText = t('NEW_ADVENTURE');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_16_TO_17_TRANSITION' }));
                        }
                        // Level 16 to 17 transition
                        else if (gameState.status === 'LEVEL_16_TO_17_TRANSITION') {
                            storyText = t('TIME_NORAEBANG');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_17_PRE_INTRO' }));
                        }
                        // Level 17 (Noraebang) pre-intro
                        else if (gameState.status === 'LEVEL_17_PRE_INTRO') {
                            storyText = t('CHOOSE_BEST_SINGER');
                            nextAction = () => safeStartLevel(17);
                        }
                        // Level 17 (Noraebang) completion
                        else if (gameState.status === 'LEVEL_17_COMPLETE_STORY') {
                            storyText = t('AMAZING_PERFORMANCE');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_18_PRE_INTRO' }));
                        }
                        // Level 18 (Stuffie Stack) pre-intro
                        else if (gameState.status === 'LEVEL_18_PRE_INTRO') {
                            storyText = t('TIME_COZY');
                            nextAction = () => safeStartLevel(18);
                        }
                        // Level 18 (Stuffie Stack) completion
                        else if (gameState.status === 'LEVEL_18_COMPLETE_STORY') {
                            storyText = t('COZY_EVENING');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_19_PRE_INTRO' }));
                        }
                        // Level 19 (Drone Show) pre-intro
                        else if (gameState.status === 'LEVEL_19_PRE_INTRO') {
                            storyText = t('SUMMER_NIGHTS');
                            nextAction = () => safeStartLevel(19);
                        }
                        // Level 19 (Drone Show) completion
                        else if (gameState.status === 'LEVEL_19_COMPLETE_STORY') {
                            storyText = t('NEVER_MISS_DRONE');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_20_PRE_INTRO' }));
                        }
                        else if (gameState.status === 'LEVEL_20_PRE_INTRO') {
                            storyText = t('WOW_DONE_LOT');
                            nextAction = () => setGameState(s => ({ ...s, status: 'LEVEL_20_INTRO' }));
                        }
                        else if (gameState.status === 'LEVEL_20_INTRO') {
                            storyText = t('WOW_DONE_LOT');
                            nextAction = () => safeStartLevel(20);
                        }
                        // Generic handler for any other level completion stories
                        else if (gameState.status.startsWith('LEVEL_') && gameState.status.endsWith('_COMPLETE_STORY')) {
                            const levelNum = parseInt(gameState.status.match(/LEVEL_(\d+)_/)[1]);
                            const level = getLevel(levelNum);
                            storyText = level.nextLevelStory;
                            nextAction = () => setGameState(s => ({ ...s, status: GameStatus.MENU }));
                        }
                        
                        // Special background colors
                        if (gameState.status === 'PIZZA_DECISION') {
                            bgColor = '#fbbf24';
                        }
                        
                        if (storyText && (nextAction || showYesNo)) {
                            const textColor = bgColor === '#fbbf24' ? 'text-black' : 'text-white';
                            return (
                                <div className="absolute inset-0 flex flex-col items-center justify-center z-50 p-6 text-center" style={{ backgroundColor: bgColor }}>
                                    <div className="max-w-md flex flex-col items-center gap-8">
                                        <p className={`text-[10px] md:text-sm uppercase leading-loose ${textColor}`}>
                                            {storyText}
                                        </p>
                                        {showYesNo ? (
                                            <div className="flex flex-col gap-4 items-center">
                                                <div className="flex gap-4">
                                                    <button onClick={() => {
                                                        if (isLevelUnlocked(2)) {
                                                            setGameState(s => ({ ...s, status: 'LEVEL_2_INTRO' }));
                                                        } else {
                                                            setPasswordModal({ show: true, levelNumber: 2 });
                                                            setPasswordInput('');
                                                        }
                                                    }} className="bg-green-600 px-8 py-4 border-4 border-black text-white text-[10px] md:text-sm uppercase">{t('YES')}</button>
                                                    <button onClick={() => setGameState(s => ({ ...s, status: GameStatus.MENU }))} className="bg-red-600 px-8 py-4 border-4 border-black text-white text-[10px] md:text-sm uppercase">{t('NO')}</button>
                                                </div>
                                                <button onClick={() => setGameState(s => ({ ...s, status: GameStatus.MENU }))} className="bg-slate-700 px-6 py-2 border-2 border-white text-white text-[8px] md:text-[10px] uppercase mt-4">{t('MAIN_MENU')}</button>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col gap-4 items-center">
                                                <button onClick={nextAction} className={btnClass}>
                                                    {gameState.status.includes('INTRO') || 
                                                     gameState.status.includes('PRE_INTRO') || 
                                                     gameState.status === 'LEVEL_4_PRE_INTRO_2' || 
                                                     gameState.status === 'LEVEL_5_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_11_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_13_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_14_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_15_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_15_TO_16_TRANSITION' ||
                                                     gameState.status === 'LEVEL_16_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_16_TO_17_TRANSITION' ||
                                                     gameState.status === 'LEVEL_17_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_18_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_19_PRE_INTRO' ||
                                                     gameState.status === 'LEVEL_20_PRE_INTRO' ? t('START') : t('NEXT')}
                                                </button>
                                                <button onClick={() => setGameState(s => ({ ...s, status: GameStatus.MENU }))} className="bg-slate-700 px-6 py-2 border-2 border-white text-white text-[8px] md:text-[10px] uppercase">{t('MAIN_MENU')}</button>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            );
                        }
                        return null;
                    })()}
                    {/* Dynamic character select for any level that requires it */}
                    {gameState.status.startsWith('LEVEL_') && gameState.status.endsWith('_CHAR_SELECT') && (() => {
                        const levelNum = parseInt(gameState.status.match(/LEVEL_(\d+)_/)[1]);
                        const level = getLevel(levelNum);
                        if (!level.requiresCharSelect) return null;
                        
                        // Special handling for level 3 (pizza catching)
                        const isPizzaLevel = levelNum === 3;
                        
                        return (
                            <div className="absolute inset-0 flex flex-col items-center justify-center z-50 bg-[#fbbf24] p-4 text-center">
                                <h2 className="text-xs md:text-xl mb-12 uppercase text-black font-black">
                                    {isPizzaLevel ? 'WHO WANTS PIZZA?' : 'CHOOSE A CHARACTER'}
                                </h2>
                                <div className="flex flex-col md:flex-row gap-8">
                                    <button onClick={() => startLevel(levelNum, 'male')} className="flex flex-col items-center gap-2">
                                        <AvatarCanvas char="male" color="#2563eb" />
                                        <span className="text-[8px] md:text-[10px] text-black font-bold uppercase">
                                            JAMES{isPizzaLevel ? ' (20)' : ''}
                                        </span>
                                    </button>
                                    <button onClick={() => startLevel(levelNum, 'female')} className="flex flex-col items-center gap-2">
                                        <AvatarCanvas char="female" color="#f43f5e" />
                                        <span className="text-[8px] md:text-[10px] text-black font-bold uppercase">
                                            ROMY{isPizzaLevel ? ' (4)' : ''}
                                        </span>
                                    </button>
                                </div>
                            </div>
                        );
                    })()}
                    {gameState.status === GameStatus.GAMEOVER && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center z-50 bg-black/90 p-4">
                            <h2 className="text-xl md:text-2xl mb-8 text-red-500 uppercase">MISSION FAILED</h2>
                            <p className="text-[8px] md:text-[10px] mb-8 text-white uppercase text-center">{gameState.deathReason}</p>
                            <div className="flex flex-col gap-4">
                                <button onClick={() => startLevel(gameState.levelNumber)} className={btnClass}>
                                    {t('START')}
                                </button>
                                <button onClick={() => setGameState(prev => ({ ...prev, status: GameStatus.MENU }))} className="bg-slate-700 px-8 py-3 md:py-4 border-4 border-white text-white text-[10px] md:text-sm uppercase">
                                    {t('MAIN_MENU')}
                                </button>
                            </div>
                        </div>
                    )}
                    {gameState.status === GameStatus.LEVEL_COMPLETE && (() => {
                        const level = getLevel(gameState.levelNumber);
                        const completionText = gameState.ritualMessage || level.completionText || "The mission was a success!";
                        return (
                            <div className="absolute inset-0 flex flex-col items-center justify-center z-50 bg-green-900 text-center p-6">
                                <h2 className="text-sm md:text-2xl mb-6 uppercase">MISSION COMPLETE!</h2>
                                <p className="text-[10px] md:text-xs mb-8 uppercase leading-relaxed max-w-xs md:max-w-md">
                                    {completionText}
                                </p>
                                <button onClick={() => setGameState(prev => ({ ...prev, status: GameStatus.MENU }))} className="bg-white text-black px-8 py-3 text-[10px]">RETURN</button>
                            </div>
                        );
                    })()}
                    {passwordModal.show && (
                        <div className="absolute inset-0 flex items-center justify-center z-[100] bg-black bg-opacity-80">
                            <div className="bg-slate-800 border-4 border-white p-8 max-w-md w-full mx-4">
                                <h3 className="text-sm md:text-lg mb-4 text-center"> LEVEL {passwordModal.levelNumber} LOCKED</h3>
                                <p className="text-[10px] md:text-xs mb-6 text-center opacity-70">Enter the secret code</p>
                                <input type="text" value={passwordInput} onChange={(e) => setPasswordInput(e.target.value)}
                                    onKeyPress={(e) => { if (e.key === 'Enter') { if (!tryUnlockLevel(passwordModal.levelNumber, passwordInput)) { alert(' Wrong code!'); setPasswordInput(''); } } }}
                                    placeholder="ENTER CODE" className="w-full p-3 border-2 border-white bg-slate-900 text-white text-center text-sm uppercase mb-4" autoFocus />
                                <div className="flex gap-4">
                                    <button onClick={() => { if (!tryUnlockLevel(passwordModal.levelNumber, passwordInput)) { alert(' Wrong code!'); setPasswordInput(''); } }}
                                        className="flex-1 bg-[#f43f5e] border-2 border-white py-3 text-[10px] uppercase">UNLOCK</button>
                                    <button onClick={() => { setPasswordModal({ show: false, levelNumber: null }); setPasswordInput(''); }}
                                        className="flex-1 bg-slate-700 border-2 border-white py-3 text-[10px] uppercase">CANCEL</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* MASTER PASSWORD MODAL */}
                    {masterPasswordModal && (
                        <div className="absolute inset-0 flex items-center justify-center z-[100] bg-black bg-opacity-80">
                            <div className="bg-slate-800 border-4 border-white p-8 max-w-md w-full mx-4">
                                <h3 className="text-sm md:text-lg mb-4 text-center"> MASTER PASSWORD</h3>
                                <p className="text-[10px] md:text-xs mb-6 text-center opacity-70">Unlock all levels at once</p>
                                <input type="password" value={masterPasswordInput} onChange={(e) => setMasterPasswordInput(e.target.value)}
                                    onKeyPress={(e) => { if (e.key === 'Enter') { if (!tryMasterPassword(masterPasswordInput)) { alert(' Wrong master password!'); setMasterPasswordInput(''); } } }}
                                    placeholder="MASTER PASSWORD" className="w-full p-3 border-2 border-white bg-slate-900 text-white text-center text-sm mb-4" autoFocus />
                                <div className="flex gap-4">
                                    <button onClick={() => { if (!tryMasterPassword(masterPasswordInput)) { alert(' Wrong master password!'); setMasterPasswordInput(''); } }}
                                        className="flex-1 bg-[#f43f5e] border-2 border-white py-3 text-[10px] uppercase">UNLOCK ALL</button>
                                    <button onClick={() => { setMasterPasswordModal(false); setMasterPasswordInput(''); }}
                                        className="flex-1 bg-slate-700 border-2 border-white py-3 text-[10px] uppercase">CANCEL</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* GEM DIGGING GAME OVERLAY */}
                    {showGemGame && gemGrid && (
                        <div className="absolute inset-0 flex items-center justify-center z-[200] bg-gradient-to-b from-amber-900 to-amber-950 overflow-y-auto">
                            <div className="text-center p-4 max-w-md w-full">
                                <h2 className="text-3xl md:text-4xl font-black mb-4 text-amber-400"> GEM DIGGING</h2>
                                
                                <div className="flex gap-8 justify-center mb-6 text-white">
                                    <div>
                                        <div className="text-xs opacity-70">GEMS LEFT</div>
                                        <div className="text-2xl font-bold text-amber-400">{gemsRemaining}</div>
                                    </div>
                                    <div>
                                        <div className="text-xs opacity-70">CLICKS</div>
                                        <div className="text-2xl font-bold text-white">{gemClicks}</div>
                                    </div>
                                </div>
                                
                                <div className="grid grid-cols-8 gap-1 mb-6 mx-auto" style={{maxWidth: '400px'}}>
                                    {gemGrid.map((row, y) => 
                                        row.map((cell, x) => (
                                            <button
                                                key={`${x}-${y}`}
                                                onClick={() => digGemCell(x, y)}
                                                className={`aspect-square border-2 transition-all text-xl ${
                                                    cell.dug
                                                        ? cell.hasGem
                                                            ? 'bg-amber-400 border-amber-500'
                                                            : 'bg-amber-900 border-amber-800'
                                                        : 'bg-amber-700 border-amber-600 hover:bg-amber-600'
                                                }`}>
                                                {cell.dug && cell.hasGem && ''}
                                            </button>
                                        ))
                                    )}
                                </div>
                                
                                <div className="flex gap-4 justify-center">
                                    <button onClick={() => initGemGame()} className="bg-amber-600 hover:bg-amber-500 px-6 py-3 border-2 border-white text-white text-xs uppercase font-bold">
                                        NEW GAME
                                    </button>
                                    <button onClick={() => setShowGemGame(false)} className="bg-slate-700 hover:bg-slate-600 px-6 py-3 border-2 border-white text-white text-xs uppercase font-bold">
                                        BACK
                                    </button>
                                </div>
                                
                                {gemsRemaining === 0 && (
                                    <div className="mt-6 text-xl font-bold text-amber-400">
                                         ALL GEMS FOUND!<br/>
                                        <span className="text-sm text-white">Score: {gemClicks} clicks</span>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const AvatarCanvas = ({ char, color }) => {
            const ref = useRef(null);
            useEffect(() => { if (!ref.current) return; const ctx = ref.current.getContext('2d'); ctx.clearRect(0,0,100,100); renderCharacterBase(ctx, char); }, [char]);
            return <div className={`w-32 h-40 md:w-48 md:h-56 ${color ? '' : (char === 'male' ? 'bg-[#2563eb]' : 'bg-[#f43f5e]')} border-4 border-white flex items-center justify-center`} style={{ backgroundColor: color }}><canvas ref={ref} width="100" height="100" className="scale-150" /></div>;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>